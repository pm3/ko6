/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		3: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!****************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/tko/tko.observable.js ***!
  \****************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extenders = exports.applyExtenders = exports.valuesArePrimitiveAndEqual = exports.deferUpdates = exports.toJSON = exports.toJS = exports.arrayChangeEventName = exports.trackArrayChanges = exports.observableArray = exports.subscribable = exports.isSubscribable = exports.isWritableObservable = exports.isWriteableObservable = exports.peek = exports.unwrap = exports.isObservable = exports.observable = exports.dependencyDetection = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _tkoUtils = __webpack_require__(/*! ./tko.utils.js */ 2);\n\n//\n//  Defer Updates\n//  ===\n//\nfunction deferUpdates(target) {\n  if (!target._deferUpdates) {\n    target._deferUpdates = true;\n    target.limit(function (callback) {\n      var handle;\n      return function () {\n        tasks.cancel(handle);\n        handle = tasks.schedule(callback);\n        target.notifySubscribers(undefined, 'dirty');\n      };\n    });\n  }\n}\n\n//\n// Observable extenders\n// ---\n//\nvar primitiveTypes = {\n  'undefined': 1, 'boolean': 1, 'number': 1, 'string': 1\n};\n\nfunction valuesArePrimitiveAndEqual(a, b) {\n  var oldValueIsPrimitive = a === null || (typeof a === 'undefined' ? 'undefined' : _typeof(a)) in primitiveTypes;\n  return oldValueIsPrimitive ? a === b : false;\n}\n\nfunction applyExtenders(requestedExtenders) {\n  var target = this;\n  if (requestedExtenders) {\n    (0, _tkoUtils.objectForEach)(requestedExtenders, function (key, value) {\n      var extenderHandler = extenders[key];\n      if (typeof extenderHandler === 'function') {\n        target = extenderHandler(target, value) || target;\n      } else {\n        _tkoUtils.options.onError(new Error('Extender not found: ' + key));\n      }\n    });\n  }\n  return target;\n}\n\n/*\n                --- DEFAULT EXTENDERS ---\n */\n\n// Change when notifications are published.\nfunction notify(target, notifyWhen) {\n  target.equalityComparer = notifyWhen == 'always' ? null : // null equalityComparer means to always notify\n  valuesArePrimitiveAndEqual;\n}\n\nfunction deferred(target, option) {\n  if (option !== true) {\n    throw new Error('The \\'deferred\\' extender only accepts the value \\'true\\', because it is not supported to turn deferral off once enabled.');\n  }\n  deferUpdates(target);\n}\n\nfunction rateLimit(target, options$$1) {\n  var timeout, method, limitFunction;\n\n  if (typeof options$$1 === 'number') {\n    timeout = options$$1;\n  } else {\n    timeout = options$$1.timeout;\n    method = options$$1.method;\n  }\n\n  // rateLimit supersedes deferred updates\n  target._deferUpdates = false;\n\n  limitFunction = method == 'notifyWhenChangesStop' ? _tkoUtils.debounce : _tkoUtils.throttle;\n\n  target.limit(function (callback) {\n    return limitFunction(callback, timeout);\n  });\n}\n\nvar extenders = {\n  notify: notify,\n  deferred: deferred,\n  rateLimit: rateLimit\n};\n\n/* eslint no-cond-assign: 0 */\nfunction subscription(target, callback, disposeCallback) {\n  this._target = target;\n  this.callback = callback;\n  this.disposeCallback = disposeCallback;\n  this.isDisposed = false;\n}\n\nsubscription.prototype.dispose = function () {\n  this.isDisposed = true;\n  this.disposeCallback();\n  window.count--;\n};\n\nfunction subscribable() {\n  (0, _tkoUtils.setPrototypeOfOrExtend)(this, ko_subscribable_fn);\n  ko_subscribable_fn.init(this);\n}\n\nvar defaultEvent = 'change';\n\nvar ko_subscribable_fn = {\n  init: function init(instance) {\n    instance._subscriptions = {};\n    instance._versionNumber = 1;\n  },\n  subscribe: function subscribe(callback, callbackTarget, event) {\n    var self = this;\n\n    event = event || defaultEvent;\n    var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;\n\n    var subscriptionInstance = new subscription(self, boundCallback, function () {\n      (0, _tkoUtils.arrayRemoveItem)(self._subscriptions[event], subscriptionInstance);\n      if (self.afterSubscriptionRemove) {\n        self.afterSubscriptionRemove(event);\n      }\n    });\n\n    if (self.beforeSubscriptionAdd) {\n      self.beforeSubscriptionAdd(event);\n    }\n\n    if (!self._subscriptions[event]) {\n      self._subscriptions[event] = [];\n    }\n    self._subscriptions[event].push(subscriptionInstance);\n\n    return subscriptionInstance;\n  },\n  notifySubscribers: function notifySubscribers(valueToNotify, event) {\n    event = event || defaultEvent;\n    if (event === defaultEvent) {\n      this.updateVersion();\n    }\n    if (this.hasSubscriptionsForEvent(event)) {\n      try {\n        begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)\n        for (var a = this._subscriptions[event].slice(0), i = 0, subscriptionInstance; subscriptionInstance = a[i]; ++i) {\n          // In case a subscription was disposed during the arrayForEach cycle, check\n          // for isDisposed on each subscription before invoking its callback\n          if (!subscriptionInstance.isDisposed) {\n            subscriptionInstance.callback(valueToNotify);\n          }\n        }\n      } finally {\n        end(); // End suppressing dependency detection\n      }\n    }\n  },\n  getVersion: function getVersion() {\n    return this._versionNumber;\n  },\n  hasChanged: function hasChanged(versionToCheck) {\n    return this.getVersion() !== versionToCheck;\n  },\n  updateVersion: function updateVersion() {\n    ++this._versionNumber;\n  },\n  hasSubscriptionsForEvent: function hasSubscriptionsForEvent(event) {\n    return this._subscriptions[event] && this._subscriptions[event].length;\n  },\n  getSubscriptionsCount: function getSubscriptionsCount(event) {\n    if (event) {\n      return this._subscriptions[event] && this._subscriptions[event].length || 0;\n    } else {\n      var total = 0;\n      (0, _tkoUtils.objectForEach)(this._subscriptions, function (eventName, subscriptions) {\n        if (eventName !== 'dirty') {\n          total += subscriptions.length;\n        }\n      });\n      return total;\n    }\n  },\n  isDifferent: function isDifferent(oldValue, newValue) {\n    return !this.equalityComparer || !this.equalityComparer(oldValue, newValue);\n  },\n  once: function once(cb) {\n    var subs = this.subscribe(function (nv) {\n      subs.dispose();\n      cb(nv);\n    });\n  },\n  when: function when(test, returnValue) {\n    var _this = this;\n\n    var current = this.peek();\n    var givenRv = arguments.length > 1;\n    var testFn = typeof test === 'function' ? test : function (v) {\n      return v === test;\n    };\n    if (testFn(current)) {\n      return _tkoUtils.options.Promise.resolve(givenRv ? returnValue : current);\n    }\n    return new _tkoUtils.options.Promise(function (resolve, reject) {\n      var subs = _this.subscribe(function (newValue) {\n        if (testFn(newValue)) {\n          subs.dispose();\n          resolve(givenRv ? returnValue : newValue);\n        }\n      });\n    });\n  },\n  yet: function yet(test) {\n    var testFn = typeof test === 'function' ? test : function (v) {\n      return v === test;\n    };\n    var negated = function negated(v) {\n      return !testFn(v);\n    };\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return this.when.apply(this, [negated].concat(args));\n  },\n  next: function next() {\n    var _this2 = this;\n\n    return new Promise(function (resolve) {\n      return _this2.once(resolve);\n    });\n  },\n\n\n  extend: applyExtenders\n};\n\n// For browsers that support proto assignment, we overwrite the prototype of each\n// observable instance. Since observables are functions, we need Function.prototype\n// to still be in the prototype chain.\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(ko_subscribable_fn, Function.prototype);\n}\n\nsubscribable.fn = ko_subscribable_fn;\n\nfunction isSubscribable(instance) {\n  return instance != null && typeof instance.subscribe === 'function' && typeof instance.notifySubscribers === 'function';\n}\n\n//\n// dependencyDetection\n// ---\n//\n// In KO 3.x, dependencyDetection was also known as computedContext.\n//\nvar outerFrames = [];\nvar currentFrame = void 0;\nvar lastId = 0;\n\n// Return a unique ID that can be assigned to an observable for dependency tracking.\n// Theoretically, you could eventually overflow the number storage size, resulting\n// in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53\n// or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would\n// take over 285 years to reach that number.\n// Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html\nfunction getId() {\n  return ++lastId;\n}\n\nfunction begin(options$$1) {\n  outerFrames.push(currentFrame);\n  currentFrame = options$$1;\n}\n\nfunction end() {\n  currentFrame = outerFrames.pop();\n}\n\nfunction registerDependency(subscribable$$1) {\n  if (currentFrame) {\n    if (!isSubscribable(subscribable$$1)) {\n      throw new Error('Only subscribable things can act as dependencies');\n    }\n    currentFrame.callback.call(currentFrame.callbackTarget, subscribable$$1, subscribable$$1._id || (subscribable$$1._id = getId()));\n  }\n}\n\nfunction ignore(callback, callbackTarget, callbackArgs) {\n  try {\n    begin();\n    return callback.apply(callbackTarget, callbackArgs || []);\n  } finally {\n    end();\n  }\n}\n\nfunction getDependenciesCount() {\n  if (currentFrame) {\n    return currentFrame.computed.getDependenciesCount();\n  }\n}\n\nfunction isInitial() {\n  if (currentFrame) {\n    return currentFrame.isInitial;\n  }\n}\n\nvar dependencyDetection = Object.freeze({\n  begin: begin,\n  end: end,\n  registerDependency: registerDependency,\n  ignore: ignore,\n  getDependenciesCount: getDependenciesCount,\n  isInitial: isInitial,\n  ignoreDependencies: ignore\n});\n\n//\n//  Observable values\n//  ---\n//\nvar observableLatestValue = (0, _tkoUtils.createSymbolOrString)('_latestValue');\n\nfunction observable(initialValue) {\n  function Observable() {\n    if (arguments.length > 0) {\n      // Write\n      // Ignore writes if the value hasn't changed\n      if (Observable.isDifferent(Observable[observableLatestValue], arguments[0])) {\n        Observable.valueWillMutate();\n        Observable[observableLatestValue] = arguments[0];\n        Observable.valueHasMutated();\n      }\n      return this; // Permits chained assignments\n    } else {\n      // Read\n      registerDependency(Observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n      return Observable[observableLatestValue];\n    }\n  }\n\n  Observable[observableLatestValue] = initialValue;\n\n  // Inherit from 'subscribable'\n  if (!_tkoUtils.canSetPrototype) {\n    // 'subscribable' won't be on the prototype chain unless we put it there directly\n    (0, _tkoUtils.extend)(Observable, subscribable.fn);\n  }\n  subscribable.fn.init(Observable);\n\n  // Inherit from 'observable'\n  (0, _tkoUtils.setPrototypeOfOrExtend)(Observable, observable.fn);\n\n  if (_tkoUtils.options.deferUpdates) {\n    deferUpdates(Observable);\n  }\n\n  return Observable;\n}\n\n// Define prototype for observables\nobservable.fn = {\n  equalityComparer: valuesArePrimitiveAndEqual,\n  peek: function peek() {\n    return this[observableLatestValue];\n  },\n  valueHasMutated: function valueHasMutated() {\n    this.notifySubscribers(this[observableLatestValue]);\n  },\n  valueWillMutate: function valueWillMutate() {\n    this.notifySubscribers(this[observableLatestValue], 'beforeChange');\n  },\n  then: function then(res, rej) {\n    try {\n      res(this());\n    } catch (e) {\n      rej(e);\n    }\n  }\n};\n\n// Moved out of \"limit\" to avoid the extra closure\nfunction limitNotifySubscribers(value, event) {\n  if (!event || event === defaultEvent) {\n    this._limitChange(value);\n  } else if (event === 'beforeChange') {\n    this._limitBeforeChange(value);\n  } else {\n    this._origNotifySubscribers(value, event);\n  }\n}\n\n// Add `limit` function to the subscribable prototype\nsubscribable.fn.limit = function limit(limitFunction) {\n  var self = this;\n  var selfIsObservable = isObservable(self);\n  var beforeChange = 'beforeChange';\n  var ignoreBeforeChange, previousValue, pendingValue;\n\n  if (!self._origNotifySubscribers) {\n    self._origNotifySubscribers = self.notifySubscribers;\n    self.notifySubscribers = limitNotifySubscribers;\n  }\n\n  var finish = limitFunction(function () {\n    self._notificationIsPending = false;\n\n    // If an observable provided a reference to itself, access it to get the latest value.\n    // This allows computed observables to delay calculating their value until needed.\n    if (selfIsObservable && pendingValue === self) {\n      pendingValue = self();\n    }\n    ignoreBeforeChange = false;\n    if (self.isDifferent(previousValue, pendingValue)) {\n      self._origNotifySubscribers(previousValue = pendingValue);\n    }\n  });\n\n  self._limitChange = function (value) {\n    self._notificationIsPending = ignoreBeforeChange = true;\n    pendingValue = value;\n    finish();\n  };\n  self._limitBeforeChange = function (value) {\n    if (!ignoreBeforeChange) {\n      previousValue = value;\n      self._origNotifySubscribers(value, beforeChange);\n    }\n  };\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the observable constructor\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(observable.fn, subscribable.fn);\n}\n\nvar protoProperty = observable.protoProperty = _tkoUtils.options.protoProperty;\nobservable.fn[protoProperty] = observable;\n\nfunction isObservable(instance) {\n  return (0, _tkoUtils.hasPrototype)(instance, observable);\n}\n\nfunction unwrap(value) {\n  return isObservable(value) ? value() : value;\n}\n\nfunction peek(value) {\n  return isObservable(value) ? value.peek() : value;\n}\n\nfunction isWriteableObservable(instance) {\n  // Observable\n  if (typeof instance === 'function' && instance[protoProperty] === observable) {\n    return true;\n  }\n  // Writeable dependent observable\n  if (typeof instance === 'function' && /* && (instance[protoProperty] === ko.dependentObservable) */instance.hasWriteFunction) {\n    return true;\n  }\n  // Anything else\n  return false;\n}\n\n//\n// Observable Array - Change Tracking Extender\n// ---\n//\n/* eslint no-fallthrough: 0*/\n\nvar arrayChangeEventName = 'arrayChange';\n\nfunction trackArrayChanges(target, options$$1) {\n  // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n  target.compareArrayOptions = {};\n  if (options$$1 && (typeof options$$1 === 'undefined' ? 'undefined' : _typeof(options$$1)) == \"object\") {\n    (0, _tkoUtils.extend)(target.compareArrayOptions, options$$1);\n  }\n  target.compareArrayOptions.sparse = true;\n\n  // Only modify the target observable once\n  if (target.cacheDiffForKnownOperation) {\n    return;\n  }\n  var trackingChanges = false,\n      cachedDiff = null,\n      arrayChangeSubscription,\n      pendingNotifications = 0,\n      underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,\n      underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n  // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n  target.beforeSubscriptionAdd = function (event) {\n    if (underlyingBeforeSubscriptionAddFunction) underlyingBeforeSubscriptionAddFunction.call(target, event);\n    if (event === arrayChangeEventName) {\n      trackChanges();\n    }\n  };\n\n  // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n  target.afterSubscriptionRemove = function (event) {\n    if (underlyingAfterSubscriptionRemoveFunction) underlyingAfterSubscriptionRemoveFunction.call(target, event);\n    if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n      if (arrayChangeSubscription) {\n        arrayChangeSubscription.dispose();\n      }\n      arrayChangeSubscription = null;\n      trackingChanges = false;\n    }\n  };\n\n  function trackChanges() {\n    // Calling 'trackChanges' multiple times is the same as calling it once\n    if (trackingChanges) {\n      return;\n    }\n\n    trackingChanges = true;\n\n    // Intercept \"notifySubscribers\" to track how many times it was called.\n    var underlyingNotifySubscribersFunction = target['notifySubscribers'];\n    target['notifySubscribers'] = function (valueToNotify, event) {\n      if (!event || event === defaultEvent) {\n        ++pendingNotifications;\n      }\n      return underlyingNotifySubscribersFunction.apply(this, arguments);\n    };\n\n    // Each time the array changes value, capture a clone so that on the next\n    // change it's possible to produce a diff\n    var previousContents = [].concat(target.peek() || []);\n    cachedDiff = null;\n    arrayChangeSubscription = target.subscribe(function (currentContents) {\n      // Make a copy of the current contents and ensure it's an array\n      currentContents = [].concat(currentContents || []);\n\n      // Compute the diff and issue notifications, but only if someone is listening\n      if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n        var changes = getChanges(previousContents, currentContents);\n      }\n\n      // Eliminate references to the old, removed items, so they can be GCed\n      previousContents = currentContents;\n      cachedDiff = null;\n      pendingNotifications = 0;\n\n      if (changes && changes.length) {\n        target['notifySubscribers'](changes, arrayChangeEventName);\n      }\n    });\n  }\n\n  function getChanges(previousContents, currentContents) {\n    // We try to re-use cached diffs.\n    // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n    // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n    // notifications are issued immediately so we wouldn't be queueing up more than one.\n    if (!cachedDiff || pendingNotifications > 1) {\n      cachedDiff = trackArrayChanges.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n    }\n\n    return cachedDiff;\n  }\n\n  target.cacheDiffForKnownOperation = function (rawArray, operationName, args) {\n    var index, argsIndex;\n    // Only run if we're currently tracking changes for this observable array\n    // and there aren't any pending deferred notifications.\n    if (!trackingChanges || pendingNotifications) {\n      return;\n    }\n    var diff = [],\n        arrayLength = rawArray.length,\n        argsLength = args.length,\n        offset = 0;\n\n    function pushDiff(status, value, index) {\n      return diff[diff.length] = { 'status': status, 'value': value, 'index': index };\n    }\n    switch (operationName) {\n      case 'push':\n        offset = arrayLength;\n      case 'unshift':\n        for (index = 0; index < argsLength; index++) {\n          pushDiff('added', args[index], offset + index);\n        }\n        break;\n\n      case 'pop':\n        offset = arrayLength - 1;\n      case 'shift':\n        if (arrayLength) {\n          pushDiff('deleted', rawArray[offset], offset);\n        }\n        break;\n\n      case 'splice':\n        // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n            endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n            endAddIndex = startIndex + argsLength - 2,\n            endIndex = Math.max(endDeleteIndex, endAddIndex),\n            additions = [],\n            deletions = [];\n        for (index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n          if (index < endDeleteIndex) deletions.push(pushDiff('deleted', rawArray[index], index));\n          if (index < endAddIndex) additions.push(pushDiff('added', args[argsIndex], index));\n        }\n        (0, _tkoUtils.findMovesInArrayComparison)(deletions, additions);\n        break;\n\n      default:\n        return;\n    }\n    cachedDiff = diff;\n  };\n}\n\n// Expose compareArrays for testing.\ntrackArrayChanges.compareArrays = _tkoUtils.compareArrays;\n\n// Add the trackArrayChanges extender so we can use\n// obs.extend({ trackArrayChanges: true })\nextenders.trackArrayChanges = trackArrayChanges;\n\n//\n// Observable Arrays\n// ===\n//\nfunction observableArray(initialValues) {\n  initialValues = initialValues || [];\n\n  if ((typeof initialValues === 'undefined' ? 'undefined' : _typeof(initialValues)) !== 'object' || !('length' in initialValues)) {\n    throw new Error('The argument passed when initializing an observable array must be an array, or null, or undefined.');\n  }\n\n  var result = observable(initialValues);\n  (0, _tkoUtils.setPrototypeOfOrExtend)(result, observableArray.fn);\n  trackArrayChanges(result);\n  // ^== result.extend({ trackArrayChanges: true })\n  return result;\n}\n\nobservableArray.fn = {\n  remove: function remove(valueOrPredicate) {\n    var underlyingArray = this.peek();\n    var removedValues = [];\n    var predicate = typeof valueOrPredicate === 'function' && !isObservable(valueOrPredicate) ? valueOrPredicate : function (value) {\n      return value === valueOrPredicate;\n    };\n    for (var i = 0; i < underlyingArray.length; i++) {\n      var value = underlyingArray[i];\n      if (predicate(value)) {\n        if (removedValues.length === 0) {\n          this.valueWillMutate();\n        }\n        removedValues.push(value);\n        underlyingArray.splice(i, 1);\n        i--;\n      }\n    }\n    if (removedValues.length) {\n      this.valueHasMutated();\n    }\n    return removedValues;\n  },\n\n  removeAll: function removeAll(arrayOfValues) {\n    // If you passed zero args, we remove everything\n    if (arrayOfValues === undefined) {\n      var underlyingArray = this.peek();\n      var allValues = underlyingArray.slice(0);\n      this.valueWillMutate();\n      underlyingArray.splice(0, underlyingArray.length);\n      this.valueHasMutated();\n      return allValues;\n    }\n    // If you passed an arg, we interpret it as an array of entries to remove\n    if (!arrayOfValues) {\n      return [];\n    }\n    return this['remove'](function (value) {\n      return (0, _tkoUtils.arrayIndexOf)(arrayOfValues, value) >= 0;\n    });\n  },\n\n  destroy: function destroy(valueOrPredicate) {\n    var underlyingArray = this.peek();\n    var predicate = typeof valueOrPredicate === 'function' && !isObservable(valueOrPredicate) ? valueOrPredicate : function (value) {\n      return value === valueOrPredicate;\n    };\n    this.valueWillMutate();\n    for (var i = underlyingArray.length - 1; i >= 0; i--) {\n      var value = underlyingArray[i];\n      if (predicate(value)) {\n        underlyingArray[i]['_destroy'] = true;\n      }\n    }\n    this.valueHasMutated();\n  },\n\n  destroyAll: function destroyAll(arrayOfValues) {\n    // If you passed zero args, we destroy everything\n    if (arrayOfValues === undefined) {\n      return this.destroy(function () {\n        return true;\n      });\n    }\n\n    // If you passed an arg, we interpret it as an array of entries to destroy\n    if (!arrayOfValues) {\n      return [];\n    }\n    return this.destroy(function (value) {\n      return (0, _tkoUtils.arrayIndexOf)(arrayOfValues, value) >= 0;\n    });\n  },\n\n  indexOf: function indexOf(item) {\n    var underlyingArray = this();\n    return (0, _tkoUtils.arrayIndexOf)(underlyingArray, item);\n  },\n\n  replace: function replace(oldItem, newItem) {\n    var index = this.indexOf(oldItem);\n    if (index >= 0) {\n      this.valueWillMutate();\n      this.peek()[index] = newItem;\n      this.valueHasMutated();\n    }\n  }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observableArray constructor\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(observableArray.fn, observable.fn);\n}\n\n// Populate ko.observableArray.fn with read/write functions from native arrays\n// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array\n// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale\n(0, _tkoUtils.arrayForEach)(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {\n  observableArray.fn[methodName] = function () {\n    // Use \"peek\" to avoid creating a subscription in any computed that we're executing in the context of\n    // (for consistency with mutating regular observables)\n    var underlyingArray = this.peek();\n    this.valueWillMutate();\n    this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n    var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n    this.valueHasMutated();\n    // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.\n    return methodCallResult === underlyingArray ? this : methodCallResult;\n  };\n});\n\n// Populate ko.observableArray.fn with read-only functions from native arrays\n(0, _tkoUtils.arrayForEach)(['slice'], function (methodName) {\n  observableArray.fn[methodName] = function () {\n    var underlyingArray = this();\n    return underlyingArray[methodName].apply(underlyingArray, arguments);\n  };\n});\n\n//\n// Helpers\n// ---\n// toJS & toJSON\n//\nvar maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)\n\nfunction toJS(rootObject) {\n  if (arguments.length == 0) throw new Error(\"When calling ko.toJS, pass the object you want to convert.\");\n\n  // We just unwrap everything at every level in the object graph\n  return mapJsObjectGraph(rootObject, function (valueToMap) {\n    // Loop because an observable's value might in turn be another observable wrapper\n    for (var i = 0; isObservable(valueToMap) && i < maxNestedObservableDepth; i++) {\n      valueToMap = valueToMap();\n    }return valueToMap;\n  });\n}\n\nfunction toJSON(rootObject, replacer, space) {\n  // replacer and space are optional\n  var plainJavaScriptObject = toJS(rootObject);\n  return (0, _tkoUtils.stringifyJson)(plainJavaScriptObject, replacer, space);\n}\n\nfunction mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {\n  visitedObjects = visitedObjects || new objectLookup();\n\n  rootObject = mapInputCallback(rootObject);\n  var canHaveProperties = (typeof rootObject === 'undefined' ? 'undefined' : _typeof(rootObject)) == \"object\" && rootObject !== null && rootObject !== undefined && !(rootObject instanceof RegExp) && !(rootObject instanceof Date) && !(rootObject instanceof String) && !(rootObject instanceof Number) && !(rootObject instanceof Boolean);\n  if (!canHaveProperties) return rootObject;\n\n  var outputProperties = rootObject instanceof Array ? [] : {};\n  visitedObjects.save(rootObject, outputProperties);\n\n  visitPropertiesOrArrayEntries(rootObject, function (indexer) {\n    var propertyValue = mapInputCallback(rootObject[indexer]);\n\n    switch (typeof propertyValue === 'undefined' ? 'undefined' : _typeof(propertyValue)) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n      case \"function\":\n        outputProperties[indexer] = propertyValue;\n        break;\n      case \"object\":\n      case \"undefined\":\n        var previouslyMappedValue = visitedObjects.get(propertyValue);\n        outputProperties[indexer] = previouslyMappedValue !== undefined ? previouslyMappedValue : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n        break;\n    }\n  });\n\n  return outputProperties;\n}\n\nfunction visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n  if (rootObject instanceof Array) {\n    for (var i = 0; i < rootObject.length; i++) {\n      visitorCallback(i);\n    } // For arrays, also respect toJSON property for custom mappings (fixes #278)\n    if (typeof rootObject['toJSON'] == 'function') visitorCallback('toJSON');\n  } else {\n    for (var propertyName in rootObject) {\n      visitorCallback(propertyName);\n    }\n  }\n}\n\nfunction objectLookup() {\n  this.keys = [];\n  this.values = [];\n}\n\nobjectLookup.prototype = {\n  constructor: objectLookup,\n  save: function save(key, value) {\n    var existingIndex = (0, _tkoUtils.arrayIndexOf)(this.keys, key);\n    if (existingIndex >= 0) this.values[existingIndex] = value;else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n  },\n  get: function get(key) {\n    var existingIndex = (0, _tkoUtils.arrayIndexOf)(this.keys, key);\n    return existingIndex >= 0 ? this.values[existingIndex] : undefined;\n  }\n};\n\n//\n// Observables.\n// ---\n//\n// The following are added to the root `[t]ko` object.\n//\n\nexports.dependencyDetection = dependencyDetection;\nexports.observable = observable;\nexports.isObservable = isObservable;\nexports.unwrap = unwrap;\nexports.peek = peek;\nexports.isWriteableObservable = isWriteableObservable;\nexports.isWritableObservable = isWriteableObservable;\nexports.isSubscribable = isSubscribable;\nexports.subscribable = subscribable;\nexports.observableArray = observableArray;\nexports.trackArrayChanges = trackArrayChanges;\nexports.arrayChangeEventName = arrayChangeEventName;\nexports.toJS = toJS;\nexports.toJSON = toJSON;\nexports.deferUpdates = deferUpdates;\nexports.valuesArePrimitiveAndEqual = valuesArePrimitiveAndEqual;\nexports.applyExtenders = applyExtenders;\nexports.extenders = extenders;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28ub2JzZXJ2YWJsZS5qcz82MzdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycmF5Rm9yRWFjaCwgYXJyYXlJbmRleE9mLCBhcnJheVJlbW92ZUl0ZW0sIGNhblNldFByb3RvdHlwZSwgY29tcGFyZUFycmF5cywgY3JlYXRlU3ltYm9sT3JTdHJpbmcsIGRlYm91bmNlLCBleHRlbmQsIGZpbmRNb3Zlc0luQXJyYXlDb21wYXJpc29uLCBoYXNQcm90b3R5cGUsIG9iamVjdEZvckVhY2gsIG9wdGlvbnMsIHNldFByb3RvdHlwZU9mLCBzZXRQcm90b3R5cGVPZk9yRXh0ZW5kLCBzdHJpbmdpZnlKc29uLCB0aHJvdHRsZSB9IGZyb20gJy4vdGtvLnV0aWxzLmpzJztcblxuLy9cbi8vICBEZWZlciBVcGRhdGVzXG4vLyAgPT09XG4vL1xuZnVuY3Rpb24gZGVmZXJVcGRhdGVzKHRhcmdldCkge1xuICAgIGlmICghdGFyZ2V0Ll9kZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgdGFyZ2V0Ll9kZWZlclVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB0YXJnZXQubGltaXQoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0YXNrcy5jYW5jZWwoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSB0YXNrcy5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm5vdGlmeVN1YnNjcmliZXJzKHVuZGVmaW5lZCwgJ2RpcnR5Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vXG4vLyBPYnNlcnZhYmxlIGV4dGVuZGVyc1xuLy8gLS0tXG4vL1xudmFyIHByaW1pdGl2ZVR5cGVzID0ge1xuICAndW5kZWZpbmVkJzogMSwgJ2Jvb2xlYW4nOiAxLCAnbnVtYmVyJzogMSwgJ3N0cmluZyc6IDFcbn07XG5cbmZ1bmN0aW9uIHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsIChhLCBiKSB7XG4gIHZhciBvbGRWYWx1ZUlzUHJpbWl0aXZlID0gKGEgPT09IG51bGwpIHx8ICh0eXBlb2YgKGEpIGluIHByaW1pdGl2ZVR5cGVzKTtcbiAgcmV0dXJuIG9sZFZhbHVlSXNQcmltaXRpdmUgPyAoYSA9PT0gYikgOiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhcHBseUV4dGVuZGVycyAocmVxdWVzdGVkRXh0ZW5kZXJzKSB7XG4gIHZhciB0YXJnZXQgPSB0aGlzO1xuICBpZiAocmVxdWVzdGVkRXh0ZW5kZXJzKSB7XG4gICAgb2JqZWN0Rm9yRWFjaChyZXF1ZXN0ZWRFeHRlbmRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZXh0ZW5kZXJIYW5kbGVyID0gZXh0ZW5kZXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGV4dGVuZGVySGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0YXJnZXQgPSBleHRlbmRlckhhbmRsZXIodGFyZ2V0LCB2YWx1ZSkgfHwgdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5vbkVycm9yKG5ldyBFcnJvcignRXh0ZW5kZXIgbm90IGZvdW5kOiAnICsga2V5KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKlxuICAgICAgICAgICAgICAgIC0tLSBERUZBVUxUIEVYVEVOREVSUyAtLS1cbiAqL1xuXG4vLyBDaGFuZ2Ugd2hlbiBub3RpZmljYXRpb25zIGFyZSBwdWJsaXNoZWQuXG5mdW5jdGlvbiBub3RpZnkgKHRhcmdldCwgbm90aWZ5V2hlbikge1xuICB0YXJnZXQuZXF1YWxpdHlDb21wYXJlciA9IG5vdGlmeVdoZW4gPT0gJ2Fsd2F5cycgP1xuICAgICAgICBudWxsIDogIC8vIG51bGwgZXF1YWxpdHlDb21wYXJlciBtZWFucyB0byBhbHdheXMgbm90aWZ5XG4gICAgICAgIHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsO1xufVxuXG5mdW5jdGlvbiBkZWZlcnJlZCAodGFyZ2V0LCBvcHRpb24pIHtcbiAgaWYgKG9wdGlvbiAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIFxcJ2RlZmVycmVkXFwnIGV4dGVuZGVyIG9ubHkgYWNjZXB0cyB0aGUgdmFsdWUgXFwndHJ1ZVxcJywgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHR1cm4gZGVmZXJyYWwgb2ZmIG9uY2UgZW5hYmxlZC4nKVxuICB9XG4gIGRlZmVyVXBkYXRlcyh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiByYXRlTGltaXQgKHRhcmdldCwgb3B0aW9ucyQkMSkge1xuICB2YXIgdGltZW91dCwgbWV0aG9kLCBsaW1pdEZ1bmN0aW9uO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyQkMSA9PT0gJ251bWJlcicpIHtcbiAgICB0aW1lb3V0ID0gb3B0aW9ucyQkMTtcbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gb3B0aW9ucyQkMS50aW1lb3V0O1xuICAgIG1ldGhvZCA9IG9wdGlvbnMkJDEubWV0aG9kO1xuICB9XG5cbiAgICAvLyByYXRlTGltaXQgc3VwZXJzZWRlcyBkZWZlcnJlZCB1cGRhdGVzXG4gIHRhcmdldC5fZGVmZXJVcGRhdGVzID0gZmFsc2U7XG5cbiAgbGltaXRGdW5jdGlvbiA9IG1ldGhvZCA9PSAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJyA/IGRlYm91bmNlIDogdGhyb3R0bGU7XG5cbiAgdGFyZ2V0LmxpbWl0KGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiBsaW1pdEZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lb3V0KVxuICB9KTtcbn1cblxudmFyIGV4dGVuZGVycyA9IHtcbiAgbm90aWZ5OiBub3RpZnksXG4gIGRlZmVycmVkOiBkZWZlcnJlZCxcbiAgcmF0ZUxpbWl0OiByYXRlTGltaXRcbn07XG5cbi8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xuZnVuY3Rpb24gc3Vic2NyaXB0aW9uICh0YXJnZXQsIGNhbGxiYWNrLCBkaXNwb3NlQ2FsbGJhY2spIHtcbiAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuZGlzcG9zZUNhbGxiYWNrID0gZGlzcG9zZUNhbGxiYWNrO1xuICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbn1cblxuc3Vic2NyaXB0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICB0aGlzLmRpc3Bvc2VDYWxsYmFjaygpO1xuICB3aW5kb3cuY291bnQtLTtcbn07XG5cbmZ1bmN0aW9uIHN1YnNjcmliYWJsZSAoKSB7XG4gIHNldFByb3RvdHlwZU9mT3JFeHRlbmQodGhpcywga29fc3Vic2NyaWJhYmxlX2ZuKTtcbiAga29fc3Vic2NyaWJhYmxlX2ZuLmluaXQodGhpcyk7XG59XG5cbnZhciBkZWZhdWx0RXZlbnQgPSAnY2hhbmdlJztcblxudmFyIGtvX3N1YnNjcmliYWJsZV9mbiA9IHtcbiAgaW5pdCAoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5fc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgIGluc3RhbmNlLl92ZXJzaW9uTnVtYmVyID0gMTtcbiAgfSxcblxuICBzdWJzY3JpYmUgKGNhbGxiYWNrLCBjYWxsYmFja1RhcmdldCwgZXZlbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBldmVudCA9IGV2ZW50IHx8IGRlZmF1bHRFdmVudDtcbiAgICB2YXIgYm91bmRDYWxsYmFjayA9IGNhbGxiYWNrVGFyZ2V0ID8gY2FsbGJhY2suYmluZChjYWxsYmFja1RhcmdldCkgOiBjYWxsYmFjaztcblxuICAgIHZhciBzdWJzY3JpcHRpb25JbnN0YW5jZSA9IG5ldyBzdWJzY3JpcHRpb24oc2VsZiwgYm91bmRDYWxsYmFjaywgZnVuY3Rpb24gKCkge1xuICAgICAgYXJyYXlSZW1vdmVJdGVtKHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLCBzdWJzY3JpcHRpb25JbnN0YW5jZSk7XG4gICAgICBpZiAoc2VsZi5hZnRlclN1YnNjcmlwdGlvblJlbW92ZSkge1xuICAgICAgICBzZWxmLmFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzZWxmLmJlZm9yZVN1YnNjcmlwdGlvbkFkZCkge1xuICAgICAgc2VsZi5iZWZvcmVTdWJzY3JpcHRpb25BZGQoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5fc3Vic2NyaXB0aW9uc1tldmVudF0pIHtcbiAgICAgIHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIHNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLnB1c2goc3Vic2NyaXB0aW9uSW5zdGFuY2UpO1xuXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbkluc3RhbmNlXG4gIH0sXG5cbiAgbm90aWZ5U3Vic2NyaWJlcnMgKHZhbHVlVG9Ob3RpZnksIGV2ZW50KSB7XG4gICAgZXZlbnQgPSBldmVudCB8fCBkZWZhdWx0RXZlbnQ7XG4gICAgaWYgKGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgIHRoaXMudXBkYXRlVmVyc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQoZXZlbnQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBiZWdpbigpOyAvLyBCZWdpbiBzdXBwcmVzc2luZyBkZXBlbmRlbmN5IGRldGVjdGlvbiAoYnkgc2V0dGluZyB0aGUgdG9wIGZyYW1lIHRvIHVuZGVmaW5lZClcbiAgICAgICAgZm9yICh2YXIgYSA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLnNsaWNlKDApLCBpID0gMCwgc3Vic2NyaXB0aW9uSW5zdGFuY2U7IHN1YnNjcmlwdGlvbkluc3RhbmNlID0gYVtpXTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgYSBzdWJzY3JpcHRpb24gd2FzIGRpc3Bvc2VkIGR1cmluZyB0aGUgYXJyYXlGb3JFYWNoIGN5Y2xlLCBjaGVja1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgaXNEaXNwb3NlZCBvbiBlYWNoIHN1YnNjcmlwdGlvbiBiZWZvcmUgaW52b2tpbmcgaXRzIGNhbGxiYWNrXG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb25JbnN0YW5jZS5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25JbnN0YW5jZS5jYWxsYmFjayh2YWx1ZVRvTm90aWZ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVuZCgpOyAvLyBFbmQgc3VwcHJlc3NpbmcgZGVwZW5kZW5jeSBkZXRlY3Rpb25cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmVyc2lvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25OdW1iZXJcbiAgfSxcblxuICBoYXNDaGFuZ2VkICh2ZXJzaW9uVG9DaGVjaykge1xuICAgIHJldHVybiB0aGlzLmdldFZlcnNpb24oKSAhPT0gdmVyc2lvblRvQ2hlY2tcbiAgfSxcblxuICB1cGRhdGVWZXJzaW9uICgpIHtcbiAgICArK3RoaXMuX3ZlcnNpb25OdW1iZXI7XG4gIH0sXG5cbiAgaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50IChldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XSAmJiB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XS5sZW5ndGhcbiAgfSxcblxuICBnZXRTdWJzY3JpcHRpb25zQ291bnQgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0gJiYgdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0ubGVuZ3RoIHx8IDBcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIG9iamVjdEZvckVhY2godGhpcy5fc3Vic2NyaXB0aW9ucywgZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3Vic2NyaXB0aW9ucykge1xuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSAnZGlydHknKSB7XG4gICAgICAgICAgdG90YWwgKz0gc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRvdGFsXG4gICAgfVxuICB9LFxuXG4gIGlzRGlmZmVyZW50IChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICByZXR1cm4gIXRoaXMuZXF1YWxpdHlDb21wYXJlciB8fFxuICAgICAgICAgICAgICAgIXRoaXMuZXF1YWxpdHlDb21wYXJlcihvbGRWYWx1ZSwgbmV3VmFsdWUpXG4gIH0sXG5cbiAgb25jZSAoY2IpIHtcbiAgICBjb25zdCBzdWJzID0gdGhpcy5zdWJzY3JpYmUoKG52KSA9PiB7XG4gICAgICBzdWJzLmRpc3Bvc2UoKTtcbiAgICAgIGNiKG52KTtcbiAgICB9KTtcbiAgfSxcblxuICB3aGVuICh0ZXN0LCByZXR1cm5WYWx1ZSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnBlZWsoKTtcbiAgICBjb25zdCBnaXZlblJ2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgdGVzdEZuID0gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgPyB0ZXN0IDogdiA9PiB2ID09PSB0ZXN0O1xuICAgIGlmICh0ZXN0Rm4oY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLlByb21pc2UucmVzb2x2ZShnaXZlblJ2ID8gcmV0dXJuVmFsdWUgOiBjdXJyZW50KVxuICAgIH1cbiAgICByZXR1cm4gbmV3IG9wdGlvbnMuUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzdWJzID0gdGhpcy5zdWJzY3JpYmUobmV3VmFsdWUgPT4ge1xuICAgICAgICBpZiAodGVzdEZuKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIHN1YnMuZGlzcG9zZSgpO1xuICAgICAgICAgIHJlc29sdmUoZ2l2ZW5SdiA/IHJldHVyblZhbHVlIDogbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICB9LFxuXG4gIHlldCAodGVzdCwgLi4uYXJncykge1xuICAgIGNvbnN0IHRlc3RGbiA9IHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nID8gdGVzdCA6IHYgPT4gdiA9PT0gdGVzdDtcbiAgICBjb25zdCBuZWdhdGVkID0gdiA9PiAhdGVzdEZuKHYpO1xuICAgIHJldHVybiB0aGlzLndoZW4obmVnYXRlZCwgLi4uYXJncylcbiAgfSxcblxuICBuZXh0ICgpIHsgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5vbmNlKHJlc29sdmUpKSB9LFxuXG4gIGV4dGVuZDogYXBwbHlFeHRlbmRlcnNcbn07XG5cbi8vIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgcHJvdG8gYXNzaWdubWVudCwgd2Ugb3ZlcndyaXRlIHRoZSBwcm90b3R5cGUgb2YgZWFjaFxuLy8gb2JzZXJ2YWJsZSBpbnN0YW5jZS4gU2luY2Ugb2JzZXJ2YWJsZXMgYXJlIGZ1bmN0aW9ucywgd2UgbmVlZCBGdW5jdGlvbi5wcm90b3R5cGVcbi8vIHRvIHN0aWxsIGJlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5pZiAoY2FuU2V0UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKGtvX3N1YnNjcmliYWJsZV9mbiwgRnVuY3Rpb24ucHJvdG90eXBlKTtcbn1cblxuc3Vic2NyaWJhYmxlLmZuID0ga29fc3Vic2NyaWJhYmxlX2ZuO1xuXG5mdW5jdGlvbiBpc1N1YnNjcmliYWJsZSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlICE9IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2Uubm90aWZ5U3Vic2NyaWJlcnMgPT09ICdmdW5jdGlvbidcbn1cblxuLy9cbi8vIGRlcGVuZGVuY3lEZXRlY3Rpb25cbi8vIC0tLVxuLy9cbi8vIEluIEtPIDMueCwgZGVwZW5kZW5jeURldGVjdGlvbiB3YXMgYWxzbyBrbm93biBhcyBjb21wdXRlZENvbnRleHQuXG4vL1xuY29uc3Qgb3V0ZXJGcmFtZXMgPSBbXTtcbmxldCBjdXJyZW50RnJhbWU7XG5sZXQgbGFzdElkID0gMDtcblxuLy8gUmV0dXJuIGEgdW5pcXVlIElEIHRoYXQgY2FuIGJlIGFzc2lnbmVkIHRvIGFuIG9ic2VydmFibGUgZm9yIGRlcGVuZGVuY3kgdHJhY2tpbmcuXG4vLyBUaGVvcmV0aWNhbGx5LCB5b3UgY291bGQgZXZlbnR1YWxseSBvdmVyZmxvdyB0aGUgbnVtYmVyIHN0b3JhZ2Ugc2l6ZSwgcmVzdWx0aW5nXG4vLyBpbiBkdXBsaWNhdGUgSURzLiBCdXQgaW4gSmF2YVNjcmlwdCwgdGhlIGxhcmdlc3QgZXhhY3QgaW50ZWdyYWwgdmFsdWUgaXMgMl41M1xuLy8gb3IgOSwwMDcsMTk5LDI1NCw3NDAsOTkyLiBJZiB5b3UgY3JlYXRlZCAxLDAwMCwwMDAgSURzIHBlciBzZWNvbmQsIGl0IHdvdWxkXG4vLyB0YWtlIG92ZXIgMjg1IHllYXJzIHRvIHJlYWNoIHRoYXQgbnVtYmVyLlxuLy8gUmVmZXJlbmNlIGh0dHA6Ly9ibG9nLnZqZXV4LmNvbS8yMDEwL2phdmFzY3JpcHQvamF2YXNjcmlwdC1tYXhfaW50LW51bWJlci1saW1pdHMuaHRtbFxuZnVuY3Rpb24gZ2V0SWQgKCkge1xuICByZXR1cm4gKytsYXN0SWRcbn1cblxuZnVuY3Rpb24gYmVnaW4gKG9wdGlvbnMkJDEpIHtcbiAgb3V0ZXJGcmFtZXMucHVzaChjdXJyZW50RnJhbWUpO1xuICBjdXJyZW50RnJhbWUgPSBvcHRpb25zJCQxO1xufVxuXG5mdW5jdGlvbiBlbmQgKCkge1xuICBjdXJyZW50RnJhbWUgPSBvdXRlckZyYW1lcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJEZXBlbmRlbmN5IChzdWJzY3JpYmFibGUkJDEpIHtcbiAgaWYgKGN1cnJlbnRGcmFtZSkge1xuICAgIGlmICghaXNTdWJzY3JpYmFibGUoc3Vic2NyaWJhYmxlJCQxKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgc3Vic2NyaWJhYmxlIHRoaW5ncyBjYW4gYWN0IGFzIGRlcGVuZGVuY2llcycpIH1cbiAgICBjdXJyZW50RnJhbWUuY2FsbGJhY2suY2FsbChjdXJyZW50RnJhbWUuY2FsbGJhY2tUYXJnZXQsIHN1YnNjcmliYWJsZSQkMSwgc3Vic2NyaWJhYmxlJCQxLl9pZCB8fCAoc3Vic2NyaWJhYmxlJCQxLl9pZCA9IGdldElkKCkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmUgKGNhbGxiYWNrLCBjYWxsYmFja1RhcmdldCwgY2FsbGJhY2tBcmdzKSB7XG4gIHRyeSB7XG4gICAgYmVnaW4oKTtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2tUYXJnZXQsIGNhbGxiYWNrQXJncyB8fCBbXSlcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXNDb3VudCAoKSB7XG4gIGlmIChjdXJyZW50RnJhbWUpIHsgcmV0dXJuIGN1cnJlbnRGcmFtZS5jb21wdXRlZC5nZXREZXBlbmRlbmNpZXNDb3VudCgpIH1cbn1cblxuZnVuY3Rpb24gaXNJbml0aWFsICgpIHtcbiAgaWYgKGN1cnJlbnRGcmFtZSkgeyByZXR1cm4gY3VycmVudEZyYW1lLmlzSW5pdGlhbCB9XG59XG5cblxuXG5cbnZhciBkZXBlbmRlbmN5RGV0ZWN0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGJlZ2luOiBiZWdpbixcblx0ZW5kOiBlbmQsXG5cdHJlZ2lzdGVyRGVwZW5kZW5jeTogcmVnaXN0ZXJEZXBlbmRlbmN5LFxuXHRpZ25vcmU6IGlnbm9yZSxcblx0Z2V0RGVwZW5kZW5jaWVzQ291bnQ6IGdldERlcGVuZGVuY2llc0NvdW50LFxuXHRpc0luaXRpYWw6IGlzSW5pdGlhbCxcblx0aWdub3JlRGVwZW5kZW5jaWVzOiBpZ25vcmVcbn0pO1xuXG4vL1xuLy8gIE9ic2VydmFibGUgdmFsdWVzXG4vLyAgLS0tXG4vL1xudmFyIG9ic2VydmFibGVMYXRlc3RWYWx1ZSA9IGNyZWF0ZVN5bWJvbE9yU3RyaW5nKCdfbGF0ZXN0VmFsdWUnKTtcblxuZnVuY3Rpb24gb2JzZXJ2YWJsZSAoaW5pdGlhbFZhbHVlKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgICAgIC8vIElnbm9yZSB3cml0ZXMgaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkXG4gICAgICBpZiAoT2JzZXJ2YWJsZS5pc0RpZmZlcmVudChPYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV0sIGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgT2JzZXJ2YWJsZS52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgICAgT2JzZXJ2YWJsZVtvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBPYnNlcnZhYmxlLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMgLy8gUGVybWl0cyBjaGFpbmVkIGFzc2lnbm1lbnRzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWRcbiAgICAgIHJlZ2lzdGVyRGVwZW5kZW5jeShPYnNlcnZhYmxlKTsgLy8gVGhlIGNhbGxlciBvbmx5IG5lZWRzIHRvIGJlIG5vdGlmaWVkIG9mIGNoYW5nZXMgaWYgdGhleSBkaWQgYSBcInJlYWRcIiBvcGVyYXRpb25cbiAgICAgIHJldHVybiBPYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV1cbiAgICB9XG4gIH1cblxuICBPYnNlcnZhYmxlW29ic2VydmFibGVMYXRlc3RWYWx1ZV0gPSBpbml0aWFsVmFsdWU7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ3N1YnNjcmliYWJsZSdcbiAgaWYgKCFjYW5TZXRQcm90b3R5cGUpIHtcbiAgICAgICAgLy8gJ3N1YnNjcmliYWJsZScgd29uJ3QgYmUgb24gdGhlIHByb3RvdHlwZSBjaGFpbiB1bmxlc3Mgd2UgcHV0IGl0IHRoZXJlIGRpcmVjdGx5XG4gICAgZXh0ZW5kKE9ic2VydmFibGUsIHN1YnNjcmliYWJsZS5mbik7XG4gIH1cbiAgc3Vic2NyaWJhYmxlLmZuLmluaXQoT2JzZXJ2YWJsZSk7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ29ic2VydmFibGUnXG4gIHNldFByb3RvdHlwZU9mT3JFeHRlbmQoT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZS5mbik7XG5cbiAgaWYgKG9wdGlvbnMuZGVmZXJVcGRhdGVzKSB7XG4gICAgZGVmZXJVcGRhdGVzKE9ic2VydmFibGUpO1xuICB9XG5cbiAgcmV0dXJuIE9ic2VydmFibGVcbn1cblxuLy8gRGVmaW5lIHByb3RvdHlwZSBmb3Igb2JzZXJ2YWJsZXNcbm9ic2VydmFibGUuZm4gPSB7XG4gIGVxdWFsaXR5Q29tcGFyZXI6IHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsLFxuICBwZWVrICgpIHsgcmV0dXJuIHRoaXNbb2JzZXJ2YWJsZUxhdGVzdFZhbHVlXSB9LFxuICB2YWx1ZUhhc011dGF0ZWQgKCkgeyB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbb2JzZXJ2YWJsZUxhdGVzdFZhbHVlXSk7IH0sXG4gIHZhbHVlV2lsbE11dGF0ZSAoKSB7XG4gICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV0sICdiZWZvcmVDaGFuZ2UnKTtcbiAgfSxcbiAgdGhlbiAocmVzLCByZWopIHsgdHJ5IHsgcmVzKHRoaXMoKSk7IH0gY2F0Y2ggKGUpIHsgcmVqKGUpOyB9IH0sXG59O1xuXG4vLyBNb3ZlZCBvdXQgb2YgXCJsaW1pdFwiIHRvIGF2b2lkIHRoZSBleHRyYSBjbG9zdXJlXG5mdW5jdGlvbiBsaW1pdE5vdGlmeVN1YnNjcmliZXJzICh2YWx1ZSwgZXZlbnQpIHtcbiAgaWYgKCFldmVudCB8fCBldmVudCA9PT0gZGVmYXVsdEV2ZW50KSB7XG4gICAgdGhpcy5fbGltaXRDaGFuZ2UodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnYmVmb3JlQ2hhbmdlJykge1xuICAgIHRoaXMuX2xpbWl0QmVmb3JlQ2hhbmdlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIGV2ZW50KTtcbiAgfVxufVxuXG4vLyBBZGQgYGxpbWl0YCBmdW5jdGlvbiB0byB0aGUgc3Vic2NyaWJhYmxlIHByb3RvdHlwZVxuc3Vic2NyaWJhYmxlLmZuLmxpbWl0ID0gZnVuY3Rpb24gbGltaXQgKGxpbWl0RnVuY3Rpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VsZklzT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZShzZWxmKTtcbiAgdmFyIGJlZm9yZUNoYW5nZSA9ICdiZWZvcmVDaGFuZ2UnO1xuICB2YXIgaWdub3JlQmVmb3JlQ2hhbmdlLCBwcmV2aW91c1ZhbHVlLCBwZW5kaW5nVmFsdWU7XG5cbiAgaWYgKCFzZWxmLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnMpIHtcbiAgICBzZWxmLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnMgPSBzZWxmLm5vdGlmeVN1YnNjcmliZXJzO1xuICAgIHNlbGYubm90aWZ5U3Vic2NyaWJlcnMgPSBsaW1pdE5vdGlmeVN1YnNjcmliZXJzO1xuICB9XG5cbiAgdmFyIGZpbmlzaCA9IGxpbWl0RnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX25vdGlmaWNhdGlvbklzUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElmIGFuIG9ic2VydmFibGUgcHJvdmlkZWQgYSByZWZlcmVuY2UgdG8gaXRzZWxmLCBhY2Nlc3MgaXQgdG8gZ2V0IHRoZSBsYXRlc3QgdmFsdWUuXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGNvbXB1dGVkIG9ic2VydmFibGVzIHRvIGRlbGF5IGNhbGN1bGF0aW5nIHRoZWlyIHZhbHVlIHVudGlsIG5lZWRlZC5cbiAgICBpZiAoc2VsZklzT2JzZXJ2YWJsZSAmJiBwZW5kaW5nVmFsdWUgPT09IHNlbGYpIHtcbiAgICAgIHBlbmRpbmdWYWx1ZSA9IHNlbGYoKTtcbiAgICB9XG4gICAgaWdub3JlQmVmb3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgaWYgKHNlbGYuaXNEaWZmZXJlbnQocHJldmlvdXNWYWx1ZSwgcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHByZXZpb3VzVmFsdWUgPSBwZW5kaW5nVmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2VsZi5fbGltaXRDaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBzZWxmLl9ub3RpZmljYXRpb25Jc1BlbmRpbmcgPSBpZ25vcmVCZWZvcmVDaGFuZ2UgPSB0cnVlO1xuICAgIHBlbmRpbmdWYWx1ZSA9IHZhbHVlO1xuICAgIGZpbmlzaCgpO1xuICB9O1xuICBzZWxmLl9saW1pdEJlZm9yZUNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghaWdub3JlQmVmb3JlQ2hhbmdlKSB7XG4gICAgICBwcmV2aW91c1ZhbHVlID0gdmFsdWU7XG4gICAgICBzZWxmLl9vcmlnTm90aWZ5U3Vic2NyaWJlcnModmFsdWUsIGJlZm9yZUNoYW5nZSk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gTm90ZSB0aGF0IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvdG8gYXNzaWdubWVudCwgdGhlXG4vLyBpbmhlcml0YW5jZSBjaGFpbiBpcyBjcmVhdGVkIG1hbnVhbGx5IGluIHRoZSBvYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG5pZiAoY2FuU2V0UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKG9ic2VydmFibGUuZm4sIHN1YnNjcmliYWJsZS5mbik7XG59XG5cbnZhciBwcm90b1Byb3BlcnR5ID0gb2JzZXJ2YWJsZS5wcm90b1Byb3BlcnR5ID0gb3B0aW9ucy5wcm90b1Byb3BlcnR5O1xub2JzZXJ2YWJsZS5mbltwcm90b1Byb3BlcnR5XSA9IG9ic2VydmFibGU7XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGhhc1Byb3RvdHlwZShpbnN0YW5jZSwgb2JzZXJ2YWJsZSlcbn1cblxuZnVuY3Rpb24gdW53cmFwICh2YWx1ZSkge1xuICByZXR1cm4gaXNPYnNlcnZhYmxlKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBwZWVrICh2YWx1ZSkge1xuICByZXR1cm4gaXNPYnNlcnZhYmxlKHZhbHVlKSA/IHZhbHVlLnBlZWsoKSA6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGlzV3JpdGVhYmxlT2JzZXJ2YWJsZSAoaW5zdGFuY2UpIHtcbiAgICAvLyBPYnNlcnZhYmxlXG4gIGlmICgodHlwZW9mIGluc3RhbmNlID09PSAnZnVuY3Rpb24nKSAmJiBpbnN0YW5jZVtwcm90b1Byb3BlcnR5XSA9PT0gb2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgICAvLyBXcml0ZWFibGUgZGVwZW5kZW50IG9ic2VydmFibGVcbiAgaWYgKCh0eXBlb2YgaW5zdGFuY2UgPT09ICdmdW5jdGlvbicpIC8qICYmIChpbnN0YW5jZVtwcm90b1Byb3BlcnR5XSA9PT0ga28uZGVwZW5kZW50T2JzZXJ2YWJsZSkgKi8gJiYgKGluc3RhbmNlLmhhc1dyaXRlRnVuY3Rpb24pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICAgIC8vIEFueXRoaW5nIGVsc2VcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vXG4vLyBPYnNlcnZhYmxlIEFycmF5IC0gQ2hhbmdlIFRyYWNraW5nIEV4dGVuZGVyXG4vLyAtLS1cbi8vXG4vKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IDAqL1xuXG52YXIgYXJyYXlDaGFuZ2VFdmVudE5hbWUgPSAnYXJyYXlDaGFuZ2UnO1xuXG5cbmZ1bmN0aW9uIHRyYWNrQXJyYXlDaGFuZ2VzKHRhcmdldCwgb3B0aW9ucyQkMSkge1xuICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgb3B0aW9ucy0tZWFjaCBjYWxsIHRvIHRyYWNrQXJyYXlDaGFuZ2VzIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzbHkgc2V0IG9wdGlvbnNcbiAgICB0YXJnZXQuY29tcGFyZUFycmF5T3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zJCQxICYmIHR5cGVvZiBvcHRpb25zJCQxID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZXh0ZW5kKHRhcmdldC5jb21wYXJlQXJyYXlPcHRpb25zLCBvcHRpb25zJCQxKTtcbiAgICB9XG4gICAgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnMuc3BhcnNlID0gdHJ1ZTtcblxuICAgIC8vIE9ubHkgbW9kaWZ5IHRoZSB0YXJnZXQgb2JzZXJ2YWJsZSBvbmNlXG4gICAgaWYgKHRhcmdldC5jYWNoZURpZmZGb3JLbm93bk9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0cmFja2luZ0NoYW5nZXMgPSBmYWxzZSxcbiAgICAgICAgY2FjaGVkRGlmZiA9IG51bGwsXG4gICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uLFxuICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDAsXG4gICAgICAgIHVuZGVybHlpbmdCZWZvcmVTdWJzY3JpcHRpb25BZGRGdW5jdGlvbiA9IHRhcmdldC5iZWZvcmVTdWJzY3JpcHRpb25BZGQsXG4gICAgICAgIHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uID0gdGFyZ2V0LmFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlO1xuXG4gICAgLy8gV2F0Y2ggXCJzdWJzY3JpYmVcIiBjYWxscywgYW5kIGZvciBhcnJheSBjaGFuZ2UgZXZlbnRzLCBlbnN1cmUgY2hhbmdlIHRyYWNraW5nIGlzIGVuYWJsZWRcbiAgICB0YXJnZXQuYmVmb3JlU3Vic2NyaXB0aW9uQWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24pXG4gICAgICAgICAgICB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24uY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBhcnJheUNoYW5nZUV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdHJhY2tDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2F0Y2ggXCJkaXNwb3NlXCIgY2FsbHMsIGFuZCBmb3IgYXJyYXkgY2hhbmdlIGV2ZW50cywgZW5zdXJlIGNoYW5nZSB0cmFja2luZyBpcyBkaXNhYmxlZCB3aGVuIGFsbCBhcmUgZGlzcG9zZWRcbiAgICB0YXJnZXQuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uKVxuICAgICAgICAgICAgdW5kZXJseWluZ0FmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlRnVuY3Rpb24uY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBhcnJheUNoYW5nZUV2ZW50TmFtZSAmJiAhdGFyZ2V0Lmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudChhcnJheUNoYW5nZUV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRyYWNraW5nQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyYWNrQ2hhbmdlcygpIHtcbiAgICAgICAgLy8gQ2FsbGluZyAndHJhY2tDaGFuZ2VzJyBtdWx0aXBsZSB0aW1lcyBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIGl0IG9uY2VcbiAgICAgICAgaWYgKHRyYWNraW5nQ2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2tpbmdDaGFuZ2VzID0gdHJ1ZTtcblxuICAgICAgICAvLyBJbnRlcmNlcHQgXCJub3RpZnlTdWJzY3JpYmVyc1wiIHRvIHRyYWNrIGhvdyBtYW55IHRpbWVzIGl0IHdhcyBjYWxsZWQuXG4gICAgICAgIHZhciB1bmRlcmx5aW5nTm90aWZ5U3Vic2NyaWJlcnNGdW5jdGlvbiA9IHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXTtcbiAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddID0gZnVuY3Rpb24odmFsdWVUb05vdGlmeSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQgfHwgZXZlbnQgPT09IGRlZmF1bHRFdmVudCkge1xuICAgICAgICAgICAgICAgICsrcGVuZGluZ05vdGlmaWNhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFYWNoIHRpbWUgdGhlIGFycmF5IGNoYW5nZXMgdmFsdWUsIGNhcHR1cmUgYSBjbG9uZSBzbyB0aGF0IG9uIHRoZSBuZXh0XG4gICAgICAgIC8vIGNoYW5nZSBpdCdzIHBvc3NpYmxlIHRvIHByb2R1Y2UgYSBkaWZmXG4gICAgICAgIHZhciBwcmV2aW91c0NvbnRlbnRzID0gW10uY29uY2F0KHRhcmdldC5wZWVrKCkgfHwgW10pO1xuICAgICAgICBjYWNoZWREaWZmID0gbnVsbDtcbiAgICAgICAgYXJyYXlDaGFuZ2VTdWJzY3JpcHRpb24gPSB0YXJnZXQuc3Vic2NyaWJlKGZ1bmN0aW9uKGN1cnJlbnRDb250ZW50cykge1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgY29udGVudHMgYW5kIGVuc3VyZSBpdCdzIGFuIGFycmF5XG4gICAgICAgICAgICBjdXJyZW50Q29udGVudHMgPSBbXS5jb25jYXQoY3VycmVudENvbnRlbnRzIHx8IFtdKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBhbmQgaXNzdWUgbm90aWZpY2F0aW9ucywgYnV0IG9ubHkgaWYgc29tZW9uZSBpcyBsaXN0ZW5pbmdcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGFycmF5Q2hhbmdlRXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gZ2V0Q2hhbmdlcyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGltaW5hdGUgcmVmZXJlbmNlcyB0byB0aGUgb2xkLCByZW1vdmVkIGl0ZW1zLCBzbyB0aGV5IGNhbiBiZSBHQ2VkXG4gICAgICAgICAgICBwcmV2aW91c0NvbnRlbnRzID0gY3VycmVudENvbnRlbnRzO1xuICAgICAgICAgICAgY2FjaGVkRGlmZiA9IG51bGw7XG4gICAgICAgICAgICBwZW5kaW5nTm90aWZpY2F0aW9ucyA9IDA7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYmIGNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Wydub3RpZnlTdWJzY3JpYmVycyddKGNoYW5nZXMsIGFycmF5Q2hhbmdlRXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2hhbmdlcyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMpIHtcbiAgICAgICAgLy8gV2UgdHJ5IHRvIHJlLXVzZSBjYWNoZWQgZGlmZnMuXG4gICAgICAgIC8vIFRoZSBzY2VuYXJpb3Mgd2hlcmUgcGVuZGluZ05vdGlmaWNhdGlvbnMgPiAxIGFyZSB3aGVuIHVzaW5nIHJhdGUtbGltaXRpbmcgb3IgdGhlIERlZmVycmVkIFVwZGF0ZXNcbiAgICAgICAgLy8gcGx1Z2luLCB3aGljaCB3aXRob3V0IHRoaXMgY2hlY2sgd291bGQgbm90IGJlIGNvbXBhdGlibGUgd2l0aCBhcnJheUNoYW5nZSBub3RpZmljYXRpb25zLiBOb3JtYWxseSxcbiAgICAgICAgLy8gbm90aWZpY2F0aW9ucyBhcmUgaXNzdWVkIGltbWVkaWF0ZWx5IHNvIHdlIHdvdWxkbid0IGJlIHF1ZXVlaW5nIHVwIG1vcmUgdGhhbiBvbmUuXG4gICAgICAgIGlmICghY2FjaGVkRGlmZiB8fCBwZW5kaW5nTm90aWZpY2F0aW9ucyA+IDEpIHtcbiAgICAgICAgICAgIGNhY2hlZERpZmYgPSB0cmFja0FycmF5Q2hhbmdlcy5jb21wYXJlQXJyYXlzKHByZXZpb3VzQ29udGVudHMsIGN1cnJlbnRDb250ZW50cywgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlZERpZmY7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uID0gZnVuY3Rpb24ocmF3QXJyYXksIG9wZXJhdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4LCBhcmdzSW5kZXg7XG4gICAgICAgIC8vIE9ubHkgcnVuIGlmIHdlJ3JlIGN1cnJlbnRseSB0cmFja2luZyBjaGFuZ2VzIGZvciB0aGlzIG9ic2VydmFibGUgYXJyYXlcbiAgICAgICAgLy8gYW5kIHRoZXJlIGFyZW4ndCBhbnkgcGVuZGluZyBkZWZlcnJlZCBub3RpZmljYXRpb25zLlxuICAgICAgICBpZiAoIXRyYWNraW5nQ2hhbmdlcyB8fCBwZW5kaW5nTm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWZmID0gW10sXG4gICAgICAgICAgICBhcnJheUxlbmd0aCA9IHJhd0FycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gcHVzaERpZmYoc3RhdHVzLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWZmW2RpZmYubGVuZ3RoXSA9IHsgJ3N0YXR1cyc6IHN0YXR1cywgJ3ZhbHVlJzogdmFsdWUsICdpbmRleCc6IGluZGV4IH07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgb2Zmc2V0ID0gYXJyYXlMZW5ndGg7XG4gICAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXJnc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHB1c2hEaWZmKCdhZGRlZCcsIGFyZ3NbaW5kZXhdLCBvZmZzZXQgKyBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb3AnOlxuICAgICAgICAgICAgb2Zmc2V0ID0gYXJyYXlMZW5ndGggLSAxO1xuICAgICAgICBjYXNlICdzaGlmdCc6XG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwdXNoRGlmZignZGVsZXRlZCcsIHJhd0FycmF5W29mZnNldF0sIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgICAgLy8gTmVnYXRpdmUgc3RhcnQgaW5kZXggbWVhbnMgJ2Zyb20gZW5kIG9mIGFycmF5Jy4gQWZ0ZXIgdGhhdCB3ZSBjbGFtcCB0byBbMC4uLmFycmF5TGVuZ3RoXS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2VcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYXJnc1swXSA8IDAgPyBhcnJheUxlbmd0aCArIGFyZ3NbMF0gOiBhcmdzWzBdKSwgYXJyYXlMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGVuZERlbGV0ZUluZGV4ID0gYXJnc0xlbmd0aCA9PT0gMSA/IGFycmF5TGVuZ3RoIDogTWF0aC5taW4oc3RhcnRJbmRleCArIChhcmdzWzFdIHx8IDApLCBhcnJheUxlbmd0aCksXG4gICAgICAgICAgICAgICAgZW5kQWRkSW5kZXggPSBzdGFydEluZGV4ICsgYXJnc0xlbmd0aCAtIDIsXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBNYXRoLm1heChlbmREZWxldGVJbmRleCwgZW5kQWRkSW5kZXgpLFxuICAgICAgICAgICAgICAgIGFkZGl0aW9ucyA9IFtdLCBkZWxldGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSBzdGFydEluZGV4LCBhcmdzSW5kZXggPSAyOyBpbmRleCA8IGVuZEluZGV4OyArK2luZGV4LCArK2FyZ3NJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGVuZERlbGV0ZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChwdXNoRGlmZignZGVsZXRlZCcsIHJhd0FycmF5W2luZGV4XSwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmRBZGRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2gocHVzaERpZmYoJ2FkZGVkJywgYXJnc1thcmdzSW5kZXhdLCBpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24oZGVsZXRpb25zLCBhZGRpdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWREaWZmID0gZGlmZjtcbiAgICB9O1xufVxuXG5cbi8vIEV4cG9zZSBjb21wYXJlQXJyYXlzIGZvciB0ZXN0aW5nLlxudHJhY2tBcnJheUNoYW5nZXMuY29tcGFyZUFycmF5cyA9IGNvbXBhcmVBcnJheXM7XG5cblxuLy8gQWRkIHRoZSB0cmFja0FycmF5Q2hhbmdlcyBleHRlbmRlciBzbyB3ZSBjYW4gdXNlXG4vLyBvYnMuZXh0ZW5kKHsgdHJhY2tBcnJheUNoYW5nZXM6IHRydWUgfSlcbmV4dGVuZGVycy50cmFja0FycmF5Q2hhbmdlcyA9IHRyYWNrQXJyYXlDaGFuZ2VzO1xuXG4vL1xuLy8gT2JzZXJ2YWJsZSBBcnJheXNcbi8vID09PVxuLy9cbmZ1bmN0aW9uIG9ic2VydmFibGVBcnJheSAoaW5pdGlhbFZhbHVlcykge1xuICBpbml0aWFsVmFsdWVzID0gaW5pdGlhbFZhbHVlcyB8fCBbXTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZXMgIT09ICdvYmplY3QnIHx8ICEoJ2xlbmd0aCcgaW4gaW5pdGlhbFZhbHVlcykpIHsgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXJndW1lbnQgcGFzc2VkIHdoZW4gaW5pdGlhbGl6aW5nIGFuIG9ic2VydmFibGUgYXJyYXkgbXVzdCBiZSBhbiBhcnJheSwgb3IgbnVsbCwgb3IgdW5kZWZpbmVkLicpIH1cblxuICB2YXIgcmVzdWx0ID0gb2JzZXJ2YWJsZShpbml0aWFsVmFsdWVzKTtcbiAgc2V0UHJvdG90eXBlT2ZPckV4dGVuZChyZXN1bHQsIG9ic2VydmFibGVBcnJheS5mbik7XG4gIHRyYWNrQXJyYXlDaGFuZ2VzKHJlc3VsdCk7XG4gICAgICAgIC8vIF49PSByZXN1bHQuZXh0ZW5kKHsgdHJhY2tBcnJheUNoYW5nZXM6IHRydWUgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5vYnNlcnZhYmxlQXJyYXkuZm4gPSB7XG4gIHJlbW92ZTogZnVuY3Rpb24gKHZhbHVlT3JQcmVkaWNhdGUpIHtcbiAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcy5wZWVrKCk7XG4gICAgdmFyIHJlbW92ZWRWYWx1ZXMgPSBbXTtcbiAgICB2YXIgcHJlZGljYXRlID0gdHlwZW9mIHZhbHVlT3JQcmVkaWNhdGUgPT09ICdmdW5jdGlvbicgJiYgIWlzT2JzZXJ2YWJsZSh2YWx1ZU9yUHJlZGljYXRlKSA/IHZhbHVlT3JQcmVkaWNhdGUgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSB2YWx1ZU9yUHJlZGljYXRlIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVuZGVybHlpbmdBcnJheVtpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgIGlmIChyZW1vdmVkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgdW5kZXJseWluZ0FycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtb3ZlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkVmFsdWVzXG4gIH0sXG5cbiAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoYXJyYXlPZlZhbHVlcykge1xuICAgICAgICAvLyBJZiB5b3UgcGFzc2VkIHplcm8gYXJncywgd2UgcmVtb3ZlIGV2ZXJ5dGhpbmdcbiAgICBpZiAoYXJyYXlPZlZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcy5wZWVrKCk7XG4gICAgICB2YXIgYWxsVmFsdWVzID0gdW5kZXJseWluZ0FycmF5LnNsaWNlKDApO1xuICAgICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICAgIHVuZGVybHlpbmdBcnJheS5zcGxpY2UoMCwgdW5kZXJseWluZ0FycmF5Lmxlbmd0aCk7XG4gICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgICAgcmV0dXJuIGFsbFZhbHVlc1xuICAgIH1cbiAgICAgICAgLy8gSWYgeW91IHBhc3NlZCBhbiBhcmcsIHdlIGludGVycHJldCBpdCBhcyBhbiBhcnJheSBvZiBlbnRyaWVzIHRvIHJlbW92ZVxuICAgIGlmICghYXJyYXlPZlZhbHVlcykge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIHJldHVybiB0aGlzWydyZW1vdmUnXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYXJyYXlPZlZhbHVlcywgdmFsdWUpID49IDBcbiAgICB9KVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICh2YWx1ZU9yUHJlZGljYXRlKSB7XG4gICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgIHZhciBwcmVkaWNhdGUgPSB0eXBlb2YgdmFsdWVPclByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYnNlcnZhYmxlKHZhbHVlT3JQcmVkaWNhdGUpID8gdmFsdWVPclByZWRpY2F0ZSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHZhbHVlT3JQcmVkaWNhdGUgfTtcbiAgICB0aGlzLnZhbHVlV2lsbE11dGF0ZSgpO1xuICAgIGZvciAodmFyIGkgPSB1bmRlcmx5aW5nQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB2YWx1ZSA9IHVuZGVybHlpbmdBcnJheVtpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgIHVuZGVybHlpbmdBcnJheVtpXVsnX2Rlc3Ryb3knXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWVIYXNNdXRhdGVkKCk7XG4gIH0sXG5cbiAgZGVzdHJveUFsbDogZnVuY3Rpb24gKGFycmF5T2ZWYWx1ZXMpIHtcbiAgICAgICAgLy8gSWYgeW91IHBhc3NlZCB6ZXJvIGFyZ3MsIHdlIGRlc3Ryb3kgZXZlcnl0aGluZ1xuICAgIGlmIChhcnJheU9mVmFsdWVzID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHRoaXMuZGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH0pIH1cblxuICAgICAgICAvLyBJZiB5b3UgcGFzc2VkIGFuIGFyZywgd2UgaW50ZXJwcmV0IGl0IGFzIGFuIGFycmF5IG9mIGVudHJpZXMgdG8gZGVzdHJveVxuICAgIGlmICghYXJyYXlPZlZhbHVlcykge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGFycmF5T2ZWYWx1ZXMsIHZhbHVlKSA+PSAwXG4gICAgfSlcbiAgfSxcblxuICBpbmRleE9mOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzKCk7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih1bmRlcmx5aW5nQXJyYXksIGl0ZW0pXG4gIH0sXG5cbiAgcmVwbGFjZTogZnVuY3Rpb24gKG9sZEl0ZW0sIG5ld0l0ZW0pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2Yob2xkSXRlbSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICB0aGlzLnBlZWsoKVtpbmRleF0gPSBuZXdJdGVtO1xuICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIE5vdGUgdGhhdCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHRoZVxuLy8gaW5oZXJpdGFuY2UgY2hhaW4gaXMgY3JlYXRlZCBtYW51YWxseSBpbiB0aGUga28ub2JzZXJ2YWJsZUFycmF5IGNvbnN0cnVjdG9yXG5pZiAoY2FuU2V0UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKG9ic2VydmFibGVBcnJheS5mbiwgb2JzZXJ2YWJsZS5mbik7XG59XG5cbi8vIFBvcHVsYXRlIGtvLm9ic2VydmFibGVBcnJheS5mbiB3aXRoIHJlYWQvd3JpdGUgZnVuY3Rpb25zIGZyb20gbmF0aXZlIGFycmF5c1xuLy8gSW1wb3J0YW50OiBEbyBub3QgYWRkIGFueSBhZGRpdGlvbmFsIGZ1bmN0aW9ucyBoZXJlIHRoYXQgbWF5IHJlYXNvbmFibHkgYmUgdXNlZCB0byAqcmVhZCogZGF0YSBmcm9tIHRoZSBhcnJheVxuLy8gYmVjYXVzZSB3ZSdsbCBldmFsIHRoZW0gd2l0aG91dCBjYXVzaW5nIHN1YnNjcmlwdGlvbnMsIHNvIGtvLmNvbXB1dGVkIG91dHB1dCBjb3VsZCBlbmQgdXAgZ2V0dGluZyBzdGFsZVxuYXJyYXlGb3JFYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIG9ic2VydmFibGVBcnJheS5mblttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlIFwicGVla1wiIHRvIGF2b2lkIGNyZWF0aW5nIGEgc3Vic2NyaXB0aW9uIGluIGFueSBjb21wdXRlZCB0aGF0IHdlJ3JlIGV4ZWN1dGluZyBpbiB0aGUgY29udGV4dCBvZlxuICAgICAgICAvLyAoZm9yIGNvbnNpc3RlbmN5IHdpdGggbXV0YXRpbmcgcmVndWxhciBvYnNlcnZhYmxlcylcbiAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcy5wZWVrKCk7XG4gICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICB0aGlzLmNhY2hlRGlmZkZvcktub3duT3BlcmF0aW9uKHVuZGVybHlpbmdBcnJheSwgbWV0aG9kTmFtZSwgYXJndW1lbnRzKTtcbiAgICB2YXIgbWV0aG9kQ2FsbFJlc3VsdCA9IHVuZGVybHlpbmdBcnJheVttZXRob2ROYW1lXS5hcHBseSh1bmRlcmx5aW5nQXJyYXksIGFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgLy8gVGhlIG5hdGl2ZSBzb3J0IGFuZCByZXZlcnNlIG1ldGhvZHMgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSwgYnV0IGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gcmV0dXJuIHRoZSBvYnNlcnZhYmxlIGFycmF5IGluc3RlYWQuXG4gICAgcmV0dXJuIG1ldGhvZENhbGxSZXN1bHQgPT09IHVuZGVybHlpbmdBcnJheSA/IHRoaXMgOiBtZXRob2RDYWxsUmVzdWx0XG4gIH07XG59KTtcblxuLy8gUG9wdWxhdGUga28ub2JzZXJ2YWJsZUFycmF5LmZuIHdpdGggcmVhZC1vbmx5IGZ1bmN0aW9ucyBmcm9tIG5hdGl2ZSBhcnJheXNcbmFycmF5Rm9yRWFjaChbJ3NsaWNlJ10sIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIG9ic2VydmFibGVBcnJheS5mblttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcygpO1xuICAgIHJldHVybiB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpXG4gIH07XG59KTtcblxuLy9cbi8vIEhlbHBlcnNcbi8vIC0tLVxuLy8gdG9KUyAmIHRvSlNPTlxuLy9cbnZhciBtYXhOZXN0ZWRPYnNlcnZhYmxlRGVwdGggPSAxMDsgLy8gRXNjYXBlIHRoZSAodW5saWtlbHkpIHBhdGhhbG9naWNhbCBjYXNlIHdoZXJlIGFuIG9ic2VydmFibGUncyBjdXJyZW50IHZhbHVlIGlzIGl0c2VsZiAob3Igc2ltaWxhciByZWZlcmVuY2UgY3ljbGUpXG5cbmZ1bmN0aW9uIHRvSlMocm9vdE9iamVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBrby50b0pTLCBwYXNzIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gY29udmVydC5cIik7XG5cbiAgICAvLyBXZSBqdXN0IHVud3JhcCBldmVyeXRoaW5nIGF0IGV2ZXJ5IGxldmVsIGluIHRoZSBvYmplY3QgZ3JhcGhcbiAgICByZXR1cm4gbWFwSnNPYmplY3RHcmFwaChyb290T2JqZWN0LCBmdW5jdGlvbih2YWx1ZVRvTWFwKSB7XG4gICAgICAgIC8vIExvb3AgYmVjYXVzZSBhbiBvYnNlcnZhYmxlJ3MgdmFsdWUgbWlnaHQgaW4gdHVybiBiZSBhbm90aGVyIG9ic2VydmFibGUgd3JhcHBlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaXNPYnNlcnZhYmxlKHZhbHVlVG9NYXApICYmIChpIDwgbWF4TmVzdGVkT2JzZXJ2YWJsZURlcHRoKTsgaSsrKVxuICAgICAgICAgICAgdmFsdWVUb01hcCA9IHZhbHVlVG9NYXAoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlVG9NYXA7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRvSlNPTihyb290T2JqZWN0LCByZXBsYWNlciwgc3BhY2UpIHsgICAgIC8vIHJlcGxhY2VyIGFuZCBzcGFjZSBhcmUgb3B0aW9uYWxcbiAgICB2YXIgcGxhaW5KYXZhU2NyaXB0T2JqZWN0ID0gdG9KUyhyb290T2JqZWN0KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5SnNvbihwbGFpbkphdmFTY3JpcHRPYmplY3QsIHJlcGxhY2VyLCBzcGFjZSk7XG59XG5cbmZ1bmN0aW9uIG1hcEpzT2JqZWN0R3JhcGgocm9vdE9iamVjdCwgbWFwSW5wdXRDYWxsYmFjaywgdmlzaXRlZE9iamVjdHMpIHtcbiAgICB2aXNpdGVkT2JqZWN0cyA9IHZpc2l0ZWRPYmplY3RzIHx8IG5ldyBvYmplY3RMb29rdXAoKTtcblxuICAgIHJvb3RPYmplY3QgPSBtYXBJbnB1dENhbGxiYWNrKHJvb3RPYmplY3QpO1xuICAgIHZhciBjYW5IYXZlUHJvcGVydGllcyA9ICh0eXBlb2Ygcm9vdE9iamVjdCA9PSBcIm9iamVjdFwiKSAmJiAocm9vdE9iamVjdCAhPT0gbnVsbCkgJiYgKHJvb3RPYmplY3QgIT09IHVuZGVmaW5lZCkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIFJlZ0V4cCkpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBEYXRlKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgQm9vbGVhbikpO1xuICAgIGlmICghY2FuSGF2ZVByb3BlcnRpZXMpXG4gICAgICAgIHJldHVybiByb290T2JqZWN0O1xuXG4gICAgdmFyIG91dHB1dFByb3BlcnRpZXMgPSByb290T2JqZWN0IGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuICAgIHZpc2l0ZWRPYmplY3RzLnNhdmUocm9vdE9iamVjdCwgb3V0cHV0UHJvcGVydGllcyk7XG5cbiAgICB2aXNpdFByb3BlcnRpZXNPckFycmF5RW50cmllcyhyb290T2JqZWN0LCBmdW5jdGlvbihpbmRleGVyKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gbWFwSW5wdXRDYWxsYmFjayhyb290T2JqZWN0W2luZGV4ZXJdKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIG91dHB1dFByb3BlcnRpZXNbaW5kZXhlcl0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgdmFyIHByZXZpb3VzbHlNYXBwZWRWYWx1ZSA9IHZpc2l0ZWRPYmplY3RzLmdldChwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIG91dHB1dFByb3BlcnRpZXNbaW5kZXhlcl0gPSAocHJldmlvdXNseU1hcHBlZFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgPyBwcmV2aW91c2x5TWFwcGVkVmFsdWVcbiAgICAgICAgICAgICAgICA6IG1hcEpzT2JqZWN0R3JhcGgocHJvcGVydHlWYWx1ZSwgbWFwSW5wdXRDYWxsYmFjaywgdmlzaXRlZE9iamVjdHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXRQcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiB2aXNpdFByb3BlcnRpZXNPckFycmF5RW50cmllcyhyb290T2JqZWN0LCB2aXNpdG9yQ2FsbGJhY2spIHtcbiAgICBpZiAocm9vdE9iamVjdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdE9iamVjdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHZpc2l0b3JDYWxsYmFjayhpKTtcblxuICAgICAgICAvLyBGb3IgYXJyYXlzLCBhbHNvIHJlc3BlY3QgdG9KU09OIHByb3BlcnR5IGZvciBjdXN0b20gbWFwcGluZ3MgKGZpeGVzICMyNzgpXG4gICAgICAgIGlmICh0eXBlb2Ygcm9vdE9iamVjdFsndG9KU09OJ10gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHZpc2l0b3JDYWxsYmFjaygndG9KU09OJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHJvb3RPYmplY3QpIHtcbiAgICAgICAgICAgIHZpc2l0b3JDYWxsYmFjayhwcm9wZXJ0eU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvYmplY3RMb29rdXAoKSB7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbn1cblxub2JqZWN0TG9va3VwLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3Rvcjogb2JqZWN0TG9va3VwLFxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nSW5kZXggPSBhcnJheUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKVxuICAgICAgICAgICAgdGhpcy52YWx1ZXNbZXhpc3RpbmdJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBleGlzdGluZ0luZGV4ID0gYXJyYXlJbmRleE9mKHRoaXMua2V5cywga2V5KTtcbiAgICAgICAgcmV0dXJuIChleGlzdGluZ0luZGV4ID49IDApID8gdGhpcy52YWx1ZXNbZXhpc3RpbmdJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLy9cbi8vIE9ic2VydmFibGVzLlxuLy8gLS0tXG4vL1xuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgdG8gdGhlIHJvb3QgYFt0XWtvYCBvYmplY3QuXG4vL1xuXG5leHBvcnQgeyBkZXBlbmRlbmN5RGV0ZWN0aW9uLCBvYnNlcnZhYmxlLCBpc09ic2VydmFibGUsIHVud3JhcCwgcGVlaywgaXNXcml0ZWFibGVPYnNlcnZhYmxlLCBpc1dyaXRlYWJsZU9ic2VydmFibGUgYXMgaXNXcml0YWJsZU9ic2VydmFibGUsIGlzU3Vic2NyaWJhYmxlLCBzdWJzY3JpYmFibGUsIG9ic2VydmFibGVBcnJheSwgdHJhY2tBcnJheUNoYW5nZXMsIGFycmF5Q2hhbmdlRXZlbnROYW1lLCB0b0pTLCB0b0pTT04sIGRlZmVyVXBkYXRlcywgdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwsIGFwcGx5RXh0ZW5kZXJzLCBleHRlbmRlcnMgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28ub2JzZXJ2YWJsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQXZIQTtBQUNBO0FBeUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0VBO0FBQ0E7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!*******************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/renderCtx.js ***!
  \*******************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.createStamp = exports.insertNode = exports.Ctx = exports.renderBlock = exports.renderElement = exports.renderCtx = undefined;\n\nvar _tkoObservable = __webpack_require__(/*! ./tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ./tko/tko.computed.js */ 3);\n\nvar _blockComponent = __webpack_require__(/*! ./blocks/blockComponent.js */ 5);\n\nfunction renderCtx(parentEl, tpl, ctx, level) {\n\tif (Array.isArray(tpl)) {\n\t\t//is array\n\t\tfor (var i = 0, max = tpl.length; i < max; i++) {\n\t\t\trenderCtx(parentEl, tpl[i], ctx, level);\n\t\t}\n\t} else if (tpl.tag) {\n\t\tif (tpl.tag.toLowerCase() != tpl.tag || tpl.tag.indexOf('-') > 0) {\n\t\t\t//is block\n\t\t\trenderBlock(parentEl, tpl, ctx, level);\n\t\t} else {\n\t\t\t//is html element\n\t\t\trenderElement(parentEl, tpl, ctx, level);\n\t\t}\n\t} else if (tpl && typeof tpl == \"function\") {\n\t\t//is text expresssion\n\t\tvar n = document.createTextNode(\"\");\n\t\tif (level == 0) ctx.rootNodes.push(n);\n\t\tinsertNode(parentEl, n);\n\t\ttextExpr(n, tpl, ctx, level);\n\t} else if (tpl !== undefined || tpl !== null) {\n\t\t//is text\n\t\tvar _n = document.createTextNode(\"\" + tpl);\n\t\tif (level == 0) ctx.rootNodes.push(_n);\n\t\tinsertNode(parentEl, _n);\n\t}\n}\n\nfunction insertNode(parentEl, n) {\n\tif (parentEl.nodeType) {\n\t\tparentEl.appendChild(n);\n\t} else {\n\t\tparentEl[0].insertBefore(n, parentEl[1]);\n\t}\n}\n\nfunction createStamp(parentEl, name) {\n\tvar stamp = document.createComment(name);\n\tif (parentEl.nodeType) {\n\t\tparentEl.appendChild(stamp);\n\t\treturn [parentEl, stamp];\n\t} else {\n\t\tparentEl[0].insertBefore(stamp, parentEl[1]);\n\t\treturn [parentEl[0], stamp];\n\t}\n}\n\nfunction attrExpr(el, key, val, ctx) {\n\tvar binding = renderCtx.bindingHandlers[key];\n\tif (binding) {\n\t\tif (binding.init) {\n\t\t\tvar val2 = ctx.expr(val);\n\t\t\tbinding.init(el, val2, ctx);\n\t\t}\n\t\tif (binding.update) {\n\t\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\t\tvar val2 = ctx.expr(val);\n\t\t\t\tbinding.update(el, val2, ctx);\n\t\t\t}, this);\n\t\t\tkv();\n\t\t\tctx.subscribers.push(kv);\n\t\t}\n\t\tif (binding.dispose && binding.dispose.call) {\n\t\t\tvar obj = {};\n\t\t\tobj.dispose = function () {\n\t\t\t\tbinding.dispose(el, ctx);\n\t\t\t};\n\t\t\tctx.subscribers.push(obj);\n\t\t}\n\t} else {\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = ctx.expr(val);\n\t\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\t\tel.setAttribute(key, val2);\n\t\t}, this);\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n};\n\nfunction textExpr(n, val, ctx, level) {\n\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\tvar val2 = ctx.expr(val);\n\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\tn.nodeValue = \"\" + val2;\n\t\treturn val2;\n\t}, this);\n\tkv();\n\tif (kv.getDependenciesCount() > 0) {\n\t\tctx.subscribers.push(kv);\n\t} else {\n\t\tkv.dispose();\n\t}\n};\n\nfunction renderElement(parentEl, tpl, ctx, level) {\n\tvar el = document.createElement(tpl.tag);\n\tif (level == 0) ctx.rootNodes.push(el);\n\tfor (var key in tpl.attrs) {\n\t\tvar val = tpl.attrs[key];\n\t\tif (typeof val == \"function\") {\n\t\t\tattrExpr(el, key, val, ctx);\n\t\t} else {\n\t\t\tel.setAttribute(key, val);\n\t\t}\n\t}\n\tinsertNode(parentEl, el);\n\tif (tpl.children) {\n\t\tfor (var i = 0, max = tpl.children.length; i < max; i++) {\n\t\t\trenderCtx(el, tpl.children[i], ctx, level + 1);\n\t\t}\n\t}\n};\n\nfunction renderBlock(parentEl, tpl, ctx, level) {\n\tvar blockFn = renderCtx.blocks[tpl.tag];\n\tif (!(blockFn && blockFn.call)) {\n\t\tblockFn = _blockComponent.blockComponent;\n\t\ttpl.attrs._name = function () {\n\t\t\treturn tpl.tag;\n\t\t};\n\t}\n\n\tvar stamp = createStamp(parentEl, tpl.tag);\n\tif (level == 0) ctx.rootNodes.push(stamp[1]);\n\n\tvar ctx0 = ctx.createChild();\n\n\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\tblockFn(stamp, tpl, ctx0, level);\n\t}, this);\n\tkv();\n\tif (kv.getDependenciesCount() > 0) {\n\t\tctx.subscribers.push(kv);\n\t} else {\n\t\tkv.dispose();\n\t}\n};\n\nrenderCtx.blocks = {};\n\nrenderCtx.bindingHandlers = {};\n\nfunction Ctx(model, parent, root, component) {\n\tthis.model = model;\n\tthis.parent = parent;\n\tthis.root = root;\n\tthis.component = component;\n\tthis.rootNodes = [];\n\tthis.subscribers = [];\n}\nCtx.prototype.dispose = function () {\n\tfor (var i = 0, max = this.subscribers.length; i < max; i++) {\n\t\tvar e = this.subscribers[i];\n\t\tif (e.dispose) e.dispose();\n\t}\n\tthis.subscribers = [];\n\tfor (var _i = 0, _max = this.rootNodes.length; _i < _max; _i++) {\n\t\tvar n = this.rootNodes[_i];\n\t\tif (n.parentNode) n.parentNode.removeChild(n);\n\t}\n\tthis.rootNodes = [];\n};\nCtx.prototype.createChild = function (model) {\n\tvar ctx0 = new Ctx(model || this.model, this.parent, this.root, this.component);\n\tthis.subscribers.push(ctx0);\n\treturn ctx0;\n};\nCtx.prototype.expr = function (f) {\n\treturn f(this.model, this);\n};\n\nexports.renderCtx = renderCtx;\nexports.renderElement = renderElement;\nexports.renderBlock = renderBlock;\nexports.Ctx = Ctx;\nexports.insertNode = insertNode;\nexports.createStamp = createStamp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3JlbmRlckN0eC5qcz9kOGYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVud3JhcCB9ICBmcm9tICcuL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVkIH0gIGZyb20gJy4vdGtvL3Rrby5jb21wdXRlZC5qcyc7XHJcblxyXG5pbXBvcnQgeyBibG9ja0NvbXBvbmVudCB9ICAgZnJvbSAnLi9ibG9ja3MvYmxvY2tDb21wb25lbnQuanMnO1xyXG5cclxuZnVuY3Rpb24gcmVuZGVyQ3R4KHBhcmVudEVsLCB0cGwsIGN0eCwgbGV2ZWwpe1xyXG5cdGlmKEFycmF5LmlzQXJyYXkodHBsKSl7XHJcblx0XHQvL2lzIGFycmF5XHJcblx0XHRmb3IobGV0IGk9MCwgbWF4PXRwbC5sZW5ndGg7IGk8bWF4OyBpKyspe1xyXG5cdFx0XHRyZW5kZXJDdHgocGFyZW50RWwsIHRwbFtpXSwgY3R4LCBsZXZlbCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmKHRwbC50YWcpe1xyXG5cdFx0aWYodHBsLnRhZy50b0xvd2VyQ2FzZSgpIT10cGwudGFnIHx8IHRwbC50YWcuaW5kZXhPZignLScpPjApe1xyXG5cdCAgIFx0XHQvL2lzIGJsb2NrXHJcblx0ICAgXHRcdHJlbmRlckJsb2NrKHBhcmVudEVsLCB0cGwsIGN0eCwgbGV2ZWwpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly9pcyBodG1sIGVsZW1lbnRcclxuXHRcdFx0cmVuZGVyRWxlbWVudChwYXJlbnRFbCwgdHBsLCBjdHgsIGxldmVsKVxyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZih0cGwgJiYgdHlwZW9mIHRwbCA9PSBcImZ1bmN0aW9uXCIpe1xyXG5cdFx0Ly9pcyB0ZXh0IGV4cHJlc3NzaW9uXHJcblx0XHRjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XHJcblx0XHRpZihsZXZlbD09MCkgY3R4LnJvb3ROb2Rlcy5wdXNoKG4pO1xyXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnRFbCwgbik7XHJcblx0XHR0ZXh0RXhwcihuLCB0cGwsIGN0eCwgbGV2ZWwpO1xyXG5cdH0gZWxzZSBpZih0cGwgIT09IHVuZGVmaW5lZCB8fCB0cGwgIT09IG51bGwpe1xyXG5cdFx0Ly9pcyB0ZXh0XHJcblx0XHRjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIit0cGwpO1xyXG5cdFx0aWYobGV2ZWw9PTApIGN0eC5yb290Tm9kZXMucHVzaChuKTtcclxuXHRcdGluc2VydE5vZGUocGFyZW50RWwsIG4pO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnRFbCwgbikge1xyXG5cdGlmKHBhcmVudEVsLm5vZGVUeXBlKSB7XHJcblx0XHRwYXJlbnRFbC5hcHBlbmRDaGlsZChuKTtcclxuXHR9IGVsc2V7XHJcblx0XHRwYXJlbnRFbFswXS5pbnNlcnRCZWZvcmUobiwgcGFyZW50RWxbMV0pO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3RhbXAocGFyZW50RWwsIG5hbWUpe1xyXG5cdGNvbnN0IHN0YW1wID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChuYW1lKTtcclxuXHRpZihwYXJlbnRFbC5ub2RlVHlwZSkge1xyXG5cdFx0cGFyZW50RWwuYXBwZW5kQ2hpbGQoc3RhbXApO1xyXG5cdFx0cmV0dXJuIFtwYXJlbnRFbCwgc3RhbXBdO1xyXG5cdH0gZWxzZXtcclxuXHRcdHBhcmVudEVsWzBdLmluc2VydEJlZm9yZShzdGFtcCwgcGFyZW50RWxbMV0pO1xyXG5cdFx0cmV0dXJuIFtwYXJlbnRFbFswXSwgc3RhbXBdO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXR0ckV4cHIoZWwsIGtleSwgdmFsLCBjdHgpe1xyXG5cdHZhciBiaW5kaW5nID0gcmVuZGVyQ3R4LmJpbmRpbmdIYW5kbGVyc1trZXldO1xyXG5cdGlmKGJpbmRpbmcpe1xyXG5cdFx0aWYoYmluZGluZy5pbml0KXtcclxuXHRcdFx0dmFyIHZhbDIgPSBjdHguZXhwcih2YWwpO1xyXG5cdFx0XHRiaW5kaW5nLmluaXQoZWwsIHZhbDIsIGN0eCk7XHJcblx0XHR9XHJcblx0XHRpZihiaW5kaW5nLnVwZGF0ZSl7XHJcblx0XHRcdHZhciBrdiA9IGNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0dmFyIHZhbDIgPSBjdHguZXhwcih2YWwpO1xyXG5cdFx0XHRcdGJpbmRpbmcudXBkYXRlKGVsLCB2YWwyLCBjdHgpO1xyXG5cdFx0XHR9LHRoaXMpO1xyXG5cdFx0XHRrdigpO1xyXG5cdFx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChrdik7XHJcblx0XHR9XHJcblx0XHRpZihiaW5kaW5nLmRpc3Bvc2UgJiYgYmluZGluZy5kaXNwb3NlLmNhbGwpe1xyXG5cdFx0XHR2YXIgb2JqID0ge307XHJcblx0XHRcdG9iai5kaXNwb3NlID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRiaW5kaW5nLmRpc3Bvc2UoZWwsIGN0eCk7XHJcblx0XHRcdH07XHJcblx0XHRcdGN0eC5zdWJzY3JpYmVycy5wdXNoKG9iaik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBrdiA9IGNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciB2YWwyID0gY3R4LmV4cHIodmFsKTtcclxuXHRcdFx0dmFsMiA9IHVud3JhcCh2YWwyKTtcclxuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsMik7XHJcblx0XHR9LHRoaXMpO1xyXG5cdFx0a3YoKTtcclxuXHRcdGlmKGt2LmdldERlcGVuZGVuY2llc0NvdW50KCk+MCl7XHJcblx0XHRcdGN0eC5zdWJzY3JpYmVycy5wdXNoKGt2KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGt2LmRpc3Bvc2UoKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiB0ZXh0RXhwcihuLCB2YWwsIGN0eCwgbGV2ZWwpe1xyXG5cdHZhciBrdiA9IGNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblx0XHR2YXIgdmFsMiA9IGN0eC5leHByKHZhbCk7XHJcblx0XHR2YWwyID0gdW53cmFwKHZhbDIpO1xyXG5cdFx0bi5ub2RlVmFsdWUgPSBcIlwiK3ZhbDI7XHJcblx0XHRyZXR1cm4gdmFsMjtcclxuXHR9LCB0aGlzKTtcclxuXHRrdigpO1xyXG5cdGlmKGt2LmdldERlcGVuZGVuY2llc0NvdW50KCk+MCl7XHJcblx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChrdik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGt2LmRpc3Bvc2UoKTtcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZW5kZXJFbGVtZW50KHBhcmVudEVsLCB0cGwsIGN0eCwgbGV2ZWwpe1xyXG5cdGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0cGwudGFnKTtcclxuXHRpZihsZXZlbD09MCkgY3R4LnJvb3ROb2Rlcy5wdXNoKGVsKTtcclxuXHRmb3IgKGxldCBrZXkgaW4gdHBsLmF0dHJzKSB7XHJcblx0XHRjb25zdCB2YWwgPSB0cGwuYXR0cnNba2V5XTtcclxuXHRcdGlmKHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0YXR0ckV4cHIoZWwsIGtleSwgdmFsLCBjdHgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aW5zZXJ0Tm9kZShwYXJlbnRFbCwgZWwpO1xyXG5cdGlmKHRwbC5jaGlsZHJlbikge1xyXG5cdFx0Zm9yKGxldCBpPTAsIG1heD10cGwuY2hpbGRyZW4ubGVuZ3RoOyBpPG1heDsgaSsrKXtcclxuXHRcdFx0cmVuZGVyQ3R4KGVsLCB0cGwuY2hpbGRyZW5baV0sIGN0eCwgbGV2ZWwrMSlcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZW5kZXJCbG9jayhwYXJlbnRFbCwgdHBsLCBjdHgsIGxldmVsKXtcclxuXHR2YXIgYmxvY2tGbiA9IHJlbmRlckN0eC5ibG9ja3NbdHBsLnRhZ107XHJcblx0aWYoIShibG9ja0ZuICYmIGJsb2NrRm4uY2FsbCkpe1xyXG5cdFx0YmxvY2tGbiA9IGJsb2NrQ29tcG9uZW50O1xyXG5cdFx0dHBsLmF0dHJzLl9uYW1lID0gKCkgPT4gdHBsLnRhZztcclxuXHR9XHJcblxyXG5cdHZhciBzdGFtcCA9XHRjcmVhdGVTdGFtcChwYXJlbnRFbCwgdHBsLnRhZyk7XHJcblx0aWYobGV2ZWw9PTApIGN0eC5yb290Tm9kZXMucHVzaChzdGFtcFsxXSk7XHJcblxyXG5cdHZhciBjdHgwID0gY3R4LmNyZWF0ZUNoaWxkKCk7XHJcblxyXG5cdHZhciBrdiA9IGNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblx0XHRibG9ja0ZuKHN0YW1wLCB0cGwsIGN0eDAsIGxldmVsKTtcclxuXHR9LCB0aGlzKTtcclxuXHRrdigpO1xyXG5cdGlmKGt2LmdldERlcGVuZGVuY2llc0NvdW50KCk+MCl7XHJcblx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChrdik7XHJcblx0fSBlbHNlIHtcclxuXHRcdGt2LmRpc3Bvc2UoKTtcclxuXHR9XHJcbn07XHJcblxyXG5yZW5kZXJDdHguYmxvY2tzID0ge1xyXG59O1xyXG5cclxucmVuZGVyQ3R4LmJpbmRpbmdIYW5kbGVycyA9IHtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEN0eChtb2RlbCwgcGFyZW50LCByb290LCBjb21wb25lbnQpe1xyXG5cdHRoaXMubW9kZWwgPSBtb2RlbDtcclxuXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHR0aGlzLnJvb3QgPSByb290O1xyXG5cdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG5cdHRoaXMucm9vdE5vZGVzID0gW107XHJcblx0dGhpcy5zdWJzY3JpYmVycyA9IFtdO1xyXG59XHJcbkN0eC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XHJcblx0Zm9yKGxldCBpPTAsIG1heD10aGlzLnN1YnNjcmliZXJzLmxlbmd0aDsgaTxtYXg7IGkrKykge1xyXG5cdFx0Y29uc3QgZSA9IHRoaXMuc3Vic2NyaWJlcnNbaV07XHJcblx0XHRpZihlLmRpc3Bvc2UpIGUuZGlzcG9zZSgpO1x0XHJcblx0fSBcclxuXHR0aGlzLnN1YnNjcmliZXJzID0gW107XHJcblx0Zm9yKGxldCBpPTAsIG1heD10aGlzLnJvb3ROb2Rlcy5sZW5ndGg7IGk8bWF4OyBpKyspIHtcclxuXHRcdGNvbnN0IG4gPSB0aGlzLnJvb3ROb2Rlc1tpXTtcclxuXHRcdGlmKG4ucGFyZW50Tm9kZSkgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xyXG5cdH0gXHJcblx0dGhpcy5yb290Tm9kZXMgPSBbXTtcclxufVxyXG5DdHgucHJvdG90eXBlLmNyZWF0ZUNoaWxkID0gZnVuY3Rpb24obW9kZWwpe1xyXG5cdGNvbnN0IGN0eDAgPSBuZXcgQ3R4KG1vZGVsIHx8IHRoaXMubW9kZWwsIHRoaXMucGFyZW50LCB0aGlzLnJvb3QsIHRoaXMuY29tcG9uZW50KTtcclxuXHR0aGlzLnN1YnNjcmliZXJzLnB1c2goY3R4MCk7XHJcblx0cmV0dXJuIGN0eDA7XHJcbn1cclxuQ3R4LnByb3RvdHlwZS5leHByID0gZnVuY3Rpb24oZil7XHJcblx0cmV0dXJuIGYodGhpcy5tb2RlbCwgdGhpcyk7XHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcblx0cmVuZGVyQ3R4LCByZW5kZXJFbGVtZW50LCByZW5kZXJCbG9jayxcclxuXHRDdHgsXHJcblx0aW5zZXJ0Tm9kZSwgY3JlYXRlU3RhbXBcclxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9yZW5kZXJDdHguanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!***********************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/tko/tko.utils.js ***!
  \***********************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n//\n// Array utilities\n//\n/* eslint no-cond-assign: 0 */\n\nfunction arrayForEach(array, action) {\n    for (var i = 0, j = array.length; i < j; i++) {\n        action(array[i], i);\n    }\n}\n\nfunction arrayIndexOf(array, item) {\n    // IE9\n    if (typeof Array.prototype.indexOf == \"function\") return Array.prototype.indexOf.call(array, item);\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (array[i] === item) return i;\n    }return -1;\n}\n\nfunction arrayFirst(array, predicate, predicateOwner) {\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (predicate.call(predicateOwner, array[i], i)) return array[i];\n    }return null;\n}\n\nfunction arrayRemoveItem(array, itemToRemove) {\n    var index = arrayIndexOf(array, itemToRemove);\n    if (index > 0) {\n        array.splice(index, 1);\n    } else if (index === 0) {\n        array.shift();\n    }\n}\n\nfunction arrayGetDistinctValues(array) {\n    array = array || [];\n    var result = [];\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (arrayIndexOf(result, array[i]) < 0) result.push(array[i]);\n    }\n    return result;\n}\n\nfunction arrayMap(array, mapping) {\n    array = array || [];\n    var result = [];\n    for (var i = 0, j = array.length; i < j; i++) {\n        result.push(mapping(array[i], i));\n    }return result;\n}\n\nfunction arrayFilter(array, predicate) {\n    array = array || [];\n    var result = [];\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (predicate(array[i], i)) result.push(array[i]);\n    }return result;\n}\n\nfunction arrayPushAll(array, valuesToPush) {\n    if (valuesToPush instanceof Array) array.push.apply(array, valuesToPush);else for (var i = 0, j = valuesToPush.length; i < j; i++) {\n        array.push(valuesToPush[i]);\n    }return array;\n}\n\nfunction addOrRemoveItem(array, value, included) {\n    var existingEntryIndex = arrayIndexOf(typeof array.peek === 'function' ? array.peek() : array, value);\n    if (existingEntryIndex < 0) {\n        if (included) array.push(value);\n    } else {\n        if (!included) array.splice(existingEntryIndex, 1);\n    }\n}\n\nfunction makeArray(arrayLikeObject) {\n    var result = [];\n    for (var i = 0, j = arrayLikeObject.length; i < j; i++) {\n        result.push(arrayLikeObject[i]);\n    }\n    return result;\n}\n\nfunction range(min, max) {\n    min = typeof min === 'function' ? min() : min;\n    max = typeof max === 'function' ? max() : max;\n    var result = [];\n    for (var i = min; i <= max; i++) {\n        result.push(i);\n    }return result;\n}\n\n// Go through the items that have been added and deleted and try to find matches between them.\nfunction findMovesInArrayComparison(left, right, limitFailedCompares) {\n    if (left.length && right.length) {\n        var failedCompares, l, r, leftItem, rightItem;\n        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {\n            for (r = 0; rightItem = right[r]; ++r) {\n                if (leftItem['value'] === rightItem['value']) {\n                    leftItem['moved'] = rightItem['index'];\n                    rightItem['moved'] = leftItem['index'];\n                    right.splice(r, 1); // This item is marked as moved; so remove it from right list\n                    failedCompares = r = 0; // Reset failed compares count because we're checking for consecutive failures\n                    break;\n                }\n            }\n            failedCompares += r;\n        }\n    }\n}\n\nvar statusNotInOld = 'added';\nvar statusNotInNew = 'deleted';\n\n// Simple calculation based on Levenshtein distance.\nfunction compareArrays(oldArray, newArray, options) {\n    // For backward compatibility, if the third arg is actually a bool, interpret\n    // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.\n    options = typeof options === 'boolean' ? { 'dontLimitMoves': options } : options || {};\n    oldArray = oldArray || [];\n    newArray = newArray || [];\n\n    if (oldArray.length < newArray.length) return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);else return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);\n}\n\nfunction compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {\n    var myMin = Math.min,\n        myMax = Math.max,\n        editDistanceMatrix = [],\n        smlIndex,\n        smlIndexMax = smlArray.length,\n        bigIndex,\n        bigIndexMax = bigArray.length,\n        compareRange = bigIndexMax - smlIndexMax || 1,\n        maxDistance = smlIndexMax + bigIndexMax + 1,\n        thisRow,\n        lastRow,\n        bigIndexMaxForRow,\n        bigIndexMinForRow;\n\n    for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {\n        lastRow = thisRow;\n        editDistanceMatrix.push(thisRow = []);\n        bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);\n        bigIndexMinForRow = myMax(0, smlIndex - 1);\n        for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {\n            if (!bigIndex) thisRow[bigIndex] = smlIndex + 1;else if (!smlIndex) // Top row - transform empty array into new array via additions\n                thisRow[bigIndex] = bigIndex + 1;else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1]) thisRow[bigIndex] = lastRow[bigIndex - 1]; // copy value (no edit)\n            else {\n                    var northDistance = lastRow[bigIndex] || maxDistance; // not in big (deletion)\n                    var westDistance = thisRow[bigIndex - 1] || maxDistance; // not in small (addition)\n                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;\n                }\n        }\n    }\n\n    var editScript = [],\n        meMinusOne,\n        notInSml = [],\n        notInBig = [];\n    for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {\n        meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;\n        if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex - 1]) {\n            notInSml.push(editScript[editScript.length] = { // added\n                'status': statusNotInSml,\n                'value': bigArray[--bigIndex],\n                'index': bigIndex });\n        } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {\n            notInBig.push(editScript[editScript.length] = { // deleted\n                'status': statusNotInBig,\n                'value': smlArray[--smlIndex],\n                'index': smlIndex });\n        } else {\n            --bigIndex;\n            --smlIndex;\n            if (!options['sparse']) {\n                editScript.push({\n                    'status': \"retained\",\n                    'value': bigArray[bigIndex] });\n            }\n        }\n    }\n\n    // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of\n    // smlIndexMax keeps the time complexity of this algorithm linear.\n    findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);\n\n    return editScript.reverse();\n}\n\n//\n// This becomes ko.options\n// --\n//\n// This is the root 'options', which must be extended by others.\n\nvar _global;\n\ntry {\n    _global = window;\n} catch (e) {\n    _global = global;\n}\n\nvar options = {\n    deferUpdates: false,\n\n    protoProperty: '__ko_proto__',\n\n    // Global variables that can be accessed from bindings.\n    bindingGlobals: _global,\n\n    Promise: _global && _global.Promise,\n\n    taskScheduler: null,\n\n    debug: false,\n\n    global: _global,\n    document: _global.document,\n\n    // Filters for bindings\n    //   data-bind=\"expression | filter_1 | filter_2\"\n    filters: {},\n\n    onError: function onError(e) {\n        throw e;\n    },\n\n    set: function set(name, value) {\n        options[name] = value;\n    }\n};\n\nObject.defineProperty(options, '$', {\n    get: function get() {\n        return options.jQuery;\n    }\n});\n\n//\n// Error handling\n// ---\n//\n// The default onError handler is to re-throw.\nfunction catchFunctionErrors(delegate) {\n    return options.onError ? function () {\n        try {\n            return delegate.apply(this, arguments);\n        } catch (e) {\n            options.onError(e);\n        }\n    } : delegate;\n}\n\nfunction deferError(error) {\n    safeSetTimeout(function () {\n        options.onError(error);\n    }, 0);\n}\n\nfunction safeSetTimeout(handler, timeout) {\n    return setTimeout(catchFunctionErrors(handler), timeout);\n}\n\n//\n// Asynchronous functionality\n// ---\nfunction throttle(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        if (!timeoutInstance) {\n            timeoutInstance = safeSetTimeout(function () {\n                timeoutInstance = undefined;\n                callback();\n            }, timeout);\n        }\n    };\n}\n\nfunction debounce(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        clearTimeout(timeoutInstance);\n        timeoutInstance = safeSetTimeout(callback, timeout);\n    };\n}\n\n//\n// Object functions\n//\n\nfunction extend(target, source) {\n    if (source) {\n        for (var prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n}\n\nfunction objectForEach(obj, action) {\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            action(prop, obj[prop]);\n        }\n    }\n}\n\nfunction objectMap(source, mapping) {\n    if (!source) return source;\n    var target = {};\n    for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n            target[prop] = mapping(source[prop], prop, source);\n        }\n    }\n    return target;\n}\n\nfunction getObjectOwnProperty(obj, propName) {\n    return obj.hasOwnProperty(propName) ? obj[propName] : undefined;\n}\n\nfunction clonePlainObjectDeep(obj, seen) {\n    if (!seen) {\n        seen = [];\n    }\n\n    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj.constructor !== Object || seen.indexOf(obj) !== -1) {\n        return obj;\n    }\n\n    // Anything that makes it below is a plain object that has not yet\n    // been seen/cloned.\n    seen.push(obj);\n\n    var result = {};\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            result[prop] = clonePlainObjectDeep(obj[prop], seen);\n        }\n    }\n    return result;\n}\n\n//\n// Prototype Functions\n//\nvar protoProperty = options.protoProperty;\n\nvar canSetPrototype = { __proto__: [] } instanceof Array;\n\nfunction setPrototypeOf(obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n}\n\nvar setPrototypeOfOrExtend = canSetPrototype ? setPrototypeOf : extend;\n\nfunction hasPrototype(instance, prototype) {\n    if (instance === null || instance === undefined || instance[protoProperty] === undefined) return false;\n    if (instance[protoProperty] === prototype) return true;\n    return hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n}\n\n//\n// String (and JSON)\n//\n\n\nfunction stringTrim(string) {\n    return string === null || string === undefined ? '' : string.trim ? string.trim() : string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n}\n\nfunction stringStartsWith(string, startsWith) {\n    string = string || \"\";\n    if (startsWith.length > string.length) return false;\n    return string.substring(0, startsWith.length) === startsWith;\n}\n\nfunction parseJson(jsonString) {\n    if (typeof jsonString == \"string\") {\n        jsonString = stringTrim(jsonString);\n        if (jsonString) {\n            if (JSON && JSON.parse) // Use native parsing where available\n                return JSON.parse(jsonString);\n            return new Function(\"return \" + jsonString)(); // Fallback on less safe parsing for older browsers\n        }\n    }\n    return null;\n}\n\nfunction stringifyJson(data, replacer, space) {\n    // replacer and space are optional\n    if (!JSON || !JSON.stringify) throw new Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\n    return JSON.stringify(typeof data === 'function' ? data() : data, replacer, space);\n}\n\n//\n// ES6 Symbols\n//\n\nvar useSymbols = typeof Symbol === 'function';\n\nfunction createSymbolOrString(identifier) {\n    return useSymbols ? Symbol(identifier) : identifier;\n}\n\n//\n//  Tasks Micro-scheduler\n//  ===\n//\n/* eslint no-cond-assign: 0 */\nvar taskQueue = [];\nvar taskQueueLength = 0;\nvar nextHandle = 1;\nvar nextIndexToProcess = 0;\nvar w = options.global;\n\nif (w && w.MutationObserver && !(w.navigator && w.navigator.standalone)) {\n    // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+, node\n    // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT\n    options.taskScheduler = function (callback) {\n        var div = w.document.createElement(\"div\");\n        new MutationObserver(callback).observe(div, { attributes: true });\n        return function () {\n            div.classList.toggle(\"foo\");\n        };\n    }(scheduledProcess);\n} else if (w && w.document && \"onreadystatechange\" in w.document.createElement(\"script\")) {\n    // IE 6-10\n    // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT\n    options.taskScheduler = function (callback) {\n        var script = document.createElement(\"script\");\n        script.onreadystatechange = function () {\n            script.onreadystatechange = null;\n            document.documentElement.removeChild(script);\n            script = null;\n            callback();\n        };\n        document.documentElement.appendChild(script);\n    };\n} else {\n    options.taskScheduler = function (callback) {\n        setTimeout(callback, 0);\n    };\n}\n\nfunction processTasks() {\n    if (taskQueueLength) {\n        // Each mark represents the end of a logical group of tasks and the number of these groups is\n        // limited to prevent unchecked recursion.\n        var mark = taskQueueLength,\n            countMarks = 0;\n\n        // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue\n        for (var task; nextIndexToProcess < taskQueueLength;) {\n            if (task = taskQueue[nextIndexToProcess++]) {\n                if (nextIndexToProcess > mark) {\n                    if (++countMarks >= 5000) {\n                        nextIndexToProcess = taskQueueLength; // skip all tasks remaining in the queue since any of them could be causing the recursion\n                        deferError(Error(\"'Too much recursion' after processing \" + countMarks + \" task groups.\"));\n                        break;\n                    }\n                    mark = taskQueueLength;\n                }\n                try {\n                    task();\n                } catch (ex) {\n                    deferError(ex);\n                }\n            }\n        }\n    }\n}\n\nfunction scheduledProcess() {\n    processTasks();\n\n    // Reset the queue\n    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n}\n\nfunction scheduleTaskProcessing() {\n    options.taskScheduler(scheduledProcess);\n}\n\nfunction schedule(func) {\n    if (!taskQueueLength) {\n        scheduleTaskProcessing();\n    }\n\n    taskQueue[taskQueueLength++] = func;\n    return nextHandle++;\n}\n\nfunction cancel(handle) {\n    var index = handle - (nextHandle - taskQueueLength);\n    if (index >= nextIndexToProcess && index < taskQueueLength) {\n        taskQueue[index] = null;\n    }\n}\n\n// For testing only: reset the queue and return the previous queue length\nfunction resetForTesting() {\n    var length = taskQueueLength - nextIndexToProcess;\n    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n    return length;\n}\n\nvar tasks = Object.freeze({\n    schedule: schedule,\n    cancel: cancel,\n    resetForTesting: resetForTesting,\n    runEarly: processTasks\n});\n\nexports.tasks = tasks;\nexports.options = options;\nexports.arrayForEach = arrayForEach;\nexports.arrayIndexOf = arrayIndexOf;\nexports.arrayFirst = arrayFirst;\nexports.arrayRemoveItem = arrayRemoveItem;\nexports.arrayGetDistinctValues = arrayGetDistinctValues;\nexports.arrayMap = arrayMap;\nexports.arrayFilter = arrayFilter;\nexports.arrayPushAll = arrayPushAll;\nexports.addOrRemoveItem = addOrRemoveItem;\nexports.makeArray = makeArray;\nexports.range = range;\nexports.findMovesInArrayComparison = findMovesInArrayComparison;\nexports.compareArrays = compareArrays;\nexports.throttle = throttle;\nexports.debounce = debounce;\nexports.catchFunctionErrors = catchFunctionErrors;\nexports.deferError = deferError;\nexports.safeSetTimeout = safeSetTimeout;\nexports.extend = extend;\nexports.objectForEach = objectForEach;\nexports.objectMap = objectMap;\nexports.getObjectOwnProperty = getObjectOwnProperty;\nexports.clonePlainObjectDeep = clonePlainObjectDeep;\nexports.canSetPrototype = canSetPrototype;\nexports.setPrototypeOf = setPrototypeOf;\nexports.setPrototypeOfOrExtend = setPrototypeOfOrExtend;\nexports.hasPrototype = hasPrototype;\nexports.stringTrim = stringTrim;\nexports.stringStartsWith = stringStartsWith;\nexports.parseJson = parseJson;\nexports.stringifyJson = stringifyJson;\nexports.useSymbols = useSymbols;\nexports.createSymbolOrString = createSymbolOrString;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ 9)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28udXRpbHMuanM/ODRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gQXJyYXkgdXRpbGl0aWVzXG4vL1xuLyogZXNsaW50IG5vLWNvbmQtYXNzaWduOiAwICovXG5cbmZ1bmN0aW9uIGFycmF5Rm9yRWFjaChhcnJheSwgYWN0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgIGFjdGlvbihhcnJheVtpXSwgaSk7XG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgaXRlbSkge1xuICAgIC8vIElFOVxuICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gYXJyYXlGaXJzdChhcnJheSwgcHJlZGljYXRlLCBwcmVkaWNhdGVPd25lcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwocHJlZGljYXRlT3duZXIsIGFycmF5W2ldLCBpKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXJyYXlSZW1vdmVJdGVtKGFycmF5LCBpdGVtVG9SZW1vdmUpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW1Ub1JlbW92ZSk7XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBhcnJheS5zaGlmdCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlHZXREaXN0aW5jdFZhbHVlcyhhcnJheSkge1xuICAgIGFycmF5ID0gYXJyYXkgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheUluZGV4T2YocmVzdWx0LCBhcnJheVtpXSkgPCAwKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgbWFwcGluZykge1xuICAgIGFycmF5ID0gYXJyYXkgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaChtYXBwaW5nKGFycmF5W2ldLCBpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIGFycmF5ID0gYXJyYXkgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldLCBpKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhcnJheVB1c2hBbGwoYXJyYXksIHZhbHVlc1RvUHVzaCkge1xuICAgIGlmICh2YWx1ZXNUb1B1c2ggaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgYXJyYXkucHVzaC5hcHBseShhcnJheSwgdmFsdWVzVG9QdXNoKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdmFsdWVzVG9QdXNoLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWVzVG9QdXNoW2ldKTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGFkZE9yUmVtb3ZlSXRlbShhcnJheSwgdmFsdWUsIGluY2x1ZGVkKSB7XG4gICAgdmFyIGV4aXN0aW5nRW50cnlJbmRleCA9IGFycmF5SW5kZXhPZih0eXBlb2YgYXJyYXkucGVlayA9PT0gJ2Z1bmN0aW9uJyA/IGFycmF5LnBlZWsoKSA6IGFycmF5LCB2YWx1ZSk7XG4gICAgaWYgKGV4aXN0aW5nRW50cnlJbmRleCA8IDApIHtcbiAgICAgICAgaWYgKGluY2x1ZGVkKVxuICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlZClcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShleGlzdGluZ0VudHJ5SW5kZXgsIDEpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBtYWtlQXJyYXkoYXJyYXlMaWtlT2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXlMaWtlT2JqZWN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChhcnJheUxpa2VPYmplY3RbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4KSB7XG4gICAgbWluID0gdHlwZW9mIG1pbiA9PT0gJ2Z1bmN0aW9uJyA/IG1pbigpIDogbWluO1xuICAgIG1heCA9IHR5cGVvZiBtYXggPT09ICdmdW5jdGlvbicgPyBtYXgoKSA6IG1heDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR28gdGhyb3VnaCB0aGUgaXRlbXMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgYW5kIGRlbGV0ZWQgYW5kIHRyeSB0byBmaW5kIG1hdGNoZXMgYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24obGVmdCwgcmlnaHQsIGxpbWl0RmFpbGVkQ29tcGFyZXMpIHtcbiAgICBpZiAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmYWlsZWRDb21wYXJlcywgbCwgciwgbGVmdEl0ZW0sIHJpZ2h0SXRlbTtcbiAgICAgICAgZm9yIChmYWlsZWRDb21wYXJlcyA9IGwgPSAwOyAoIWxpbWl0RmFpbGVkQ29tcGFyZXMgfHwgZmFpbGVkQ29tcGFyZXMgPCBsaW1pdEZhaWxlZENvbXBhcmVzKSAmJiAobGVmdEl0ZW0gPSBsZWZ0W2xdKTsgKytsKSB7XG4gICAgICAgICAgICBmb3IgKHIgPSAwOyByaWdodEl0ZW0gPSByaWdodFtyXTsgKytyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRJdGVtWyd2YWx1ZSddID09PSByaWdodEl0ZW1bJ3ZhbHVlJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEl0ZW1bJ21vdmVkJ10gPSByaWdodEl0ZW1bJ2luZGV4J107XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0SXRlbVsnbW92ZWQnXSA9IGxlZnRJdGVtWydpbmRleCddO1xuICAgICAgICAgICAgICAgICAgICByaWdodC5zcGxpY2UociwgMSk7ICAgICAgICAgLy8gVGhpcyBpdGVtIGlzIG1hcmtlZCBhcyBtb3ZlZDsgc28gcmVtb3ZlIGl0IGZyb20gcmlnaHQgbGlzdFxuICAgICAgICAgICAgICAgICAgICBmYWlsZWRDb21wYXJlcyA9IHIgPSAwOyAgICAgLy8gUmVzZXQgZmFpbGVkIGNvbXBhcmVzIGNvdW50IGJlY2F1c2Ugd2UncmUgY2hlY2tpbmcgZm9yIGNvbnNlY3V0aXZlIGZhaWx1cmVzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhaWxlZENvbXBhcmVzICs9IHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG52YXIgc3RhdHVzTm90SW5PbGQgPSAnYWRkZWQnO1xudmFyIHN0YXR1c05vdEluTmV3ID0gJ2RlbGV0ZWQnO1xuXG4gICAgLy8gU2ltcGxlIGNhbGN1bGF0aW9uIGJhc2VkIG9uIExldmVuc2h0ZWluIGRpc3RhbmNlLlxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhvbGRBcnJheSwgbmV3QXJyYXksIG9wdGlvbnMpIHtcbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaWYgdGhlIHRoaXJkIGFyZyBpcyBhY3R1YWxseSBhIGJvb2wsIGludGVycHJldFxuICAgIC8vIGl0IGFzIHRoZSBvbGQgcGFyYW1ldGVyICdkb250TGltaXRNb3ZlcycuIE5ld2VyIGNvZGUgc2hvdWxkIHVzZSB7IGRvbnRMaW1pdE1vdmVzOiB0cnVlIH0uXG4gICAgb3B0aW9ucyA9ICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSA/IHsgJ2RvbnRMaW1pdE1vdmVzJzogb3B0aW9ucyB9IDogKG9wdGlvbnMgfHwge30pO1xuICAgIG9sZEFycmF5ID0gb2xkQXJyYXkgfHwgW107XG4gICAgbmV3QXJyYXkgPSBuZXdBcnJheSB8fCBbXTtcblxuICAgIGlmIChvbGRBcnJheS5sZW5ndGggPCBuZXdBcnJheS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb21wYXJlU21hbGxBcnJheVRvQmlnQXJyYXkob2xkQXJyYXksIG5ld0FycmF5LCBzdGF0dXNOb3RJbk9sZCwgc3RhdHVzTm90SW5OZXcsIG9wdGlvbnMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShuZXdBcnJheSwgb2xkQXJyYXksIHN0YXR1c05vdEluTmV3LCBzdGF0dXNOb3RJbk9sZCwgb3B0aW9ucyk7XG59XG5cblxuZnVuY3Rpb24gY29tcGFyZVNtYWxsQXJyYXlUb0JpZ0FycmF5KHNtbEFycmF5LCBiaWdBcnJheSwgc3RhdHVzTm90SW5TbWwsIHN0YXR1c05vdEluQmlnLCBvcHRpb25zKSB7XG4gICAgdmFyIG15TWluID0gTWF0aC5taW4sXG4gICAgICAgIG15TWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGVkaXREaXN0YW5jZU1hdHJpeCA9IFtdLFxuICAgICAgICBzbWxJbmRleCwgc21sSW5kZXhNYXggPSBzbWxBcnJheS5sZW5ndGgsXG4gICAgICAgIGJpZ0luZGV4LCBiaWdJbmRleE1heCA9IGJpZ0FycmF5Lmxlbmd0aCxcbiAgICAgICAgY29tcGFyZVJhbmdlID0gKGJpZ0luZGV4TWF4IC0gc21sSW5kZXhNYXgpIHx8IDEsXG4gICAgICAgIG1heERpc3RhbmNlID0gc21sSW5kZXhNYXggKyBiaWdJbmRleE1heCArIDEsXG4gICAgICAgIHRoaXNSb3csIGxhc3RSb3csXG4gICAgICAgIGJpZ0luZGV4TWF4Rm9yUm93LCBiaWdJbmRleE1pbkZvclJvdztcblxuICAgIGZvciAoc21sSW5kZXggPSAwOyBzbWxJbmRleCA8PSBzbWxJbmRleE1heDsgc21sSW5kZXgrKykge1xuICAgICAgICBsYXN0Um93ID0gdGhpc1JvdztcbiAgICAgICAgZWRpdERpc3RhbmNlTWF0cml4LnB1c2godGhpc1JvdyA9IFtdKTtcbiAgICAgICAgYmlnSW5kZXhNYXhGb3JSb3cgPSBteU1pbihiaWdJbmRleE1heCwgc21sSW5kZXggKyBjb21wYXJlUmFuZ2UpO1xuICAgICAgICBiaWdJbmRleE1pbkZvclJvdyA9IG15TWF4KDAsIHNtbEluZGV4IC0gMSk7XG4gICAgICAgIGZvciAoYmlnSW5kZXggPSBiaWdJbmRleE1pbkZvclJvdzsgYmlnSW5kZXggPD0gYmlnSW5kZXhNYXhGb3JSb3c7IGJpZ0luZGV4KyspIHtcbiAgICAgICAgICAgIGlmICghYmlnSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBzbWxJbmRleCArIDE7XG4gICAgICAgICAgICBlbHNlIGlmICghc21sSW5kZXgpICAvLyBUb3Agcm93IC0gdHJhbnNmb3JtIGVtcHR5IGFycmF5IGludG8gbmV3IGFycmF5IHZpYSBhZGRpdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzUm93W2JpZ0luZGV4XSA9IGJpZ0luZGV4ICsgMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNtbEFycmF5W3NtbEluZGV4IC0gMV0gPT09IGJpZ0FycmF5W2JpZ0luZGV4IC0gMV0pXG4gICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBsYXN0Um93W2JpZ0luZGV4IC0gMV07ICAgICAgICAgICAgICAgICAgLy8gY29weSB2YWx1ZSAobm8gZWRpdClcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub3J0aERpc3RhbmNlID0gbGFzdFJvd1tiaWdJbmRleF0gfHwgbWF4RGlzdGFuY2U7ICAgICAgIC8vIG5vdCBpbiBiaWcgKGRlbGV0aW9uKVxuICAgICAgICAgICAgICAgIHZhciB3ZXN0RGlzdGFuY2UgPSB0aGlzUm93W2JpZ0luZGV4IC0gMV0gfHwgbWF4RGlzdGFuY2U7ICAgIC8vIG5vdCBpbiBzbWFsbCAoYWRkaXRpb24pXG4gICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBteU1pbihub3J0aERpc3RhbmNlLCB3ZXN0RGlzdGFuY2UpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0U2NyaXB0ID0gW10sIG1lTWludXNPbmUsIG5vdEluU21sID0gW10sIG5vdEluQmlnID0gW107XG4gICAgZm9yIChzbWxJbmRleCA9IHNtbEluZGV4TWF4LCBiaWdJbmRleCA9IGJpZ0luZGV4TWF4OyBzbWxJbmRleCB8fCBiaWdJbmRleDspIHtcbiAgICAgICAgbWVNaW51c09uZSA9IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleF1bYmlnSW5kZXhdIC0gMTtcbiAgICAgICAgaWYgKGJpZ0luZGV4ICYmIG1lTWludXNPbmUgPT09IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleF1bYmlnSW5kZXgtMV0pIHtcbiAgICAgICAgICAgIG5vdEluU21sLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBhZGRlZFxuICAgICAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXNOb3RJblNtbCxcbiAgICAgICAgICAgICAgICAndmFsdWUnOiBiaWdBcnJheVstLWJpZ0luZGV4XSxcbiAgICAgICAgICAgICAgICAnaW5kZXgnOiBiaWdJbmRleCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzbWxJbmRleCAmJiBtZU1pbnVzT25lID09PSBlZGl0RGlzdGFuY2VNYXRyaXhbc21sSW5kZXggLSAxXVtiaWdJbmRleF0pIHtcbiAgICAgICAgICAgIG5vdEluQmlnLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBkZWxldGVkXG4gICAgICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1c05vdEluQmlnLFxuICAgICAgICAgICAgICAgICd2YWx1ZSc6IHNtbEFycmF5Wy0tc21sSW5kZXhdLFxuICAgICAgICAgICAgICAgICdpbmRleCc6IHNtbEluZGV4IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLS1iaWdJbmRleDtcbiAgICAgICAgICAgIC0tc21sSW5kZXg7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNbJ3NwYXJzZSddKSB7XG4gICAgICAgICAgICAgICAgZWRpdFNjcmlwdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IFwicmV0YWluZWRcIixcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogYmlnQXJyYXlbYmlnSW5kZXhdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGEgbGltaXQgb24gdGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBub24tbWF0Y2hpbmcgY29tcGFyaXNvbnM7IGhhdmluZyBpdCBhIG11bHRpcGxlIG9mXG4gICAgLy8gc21sSW5kZXhNYXgga2VlcHMgdGhlIHRpbWUgY29tcGxleGl0eSBvZiB0aGlzIGFsZ29yaXRobSBsaW5lYXIuXG4gICAgZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24obm90SW5CaWcsIG5vdEluU21sLCAhb3B0aW9uc1snZG9udExpbWl0TW92ZXMnXSAmJiBzbWxJbmRleE1heCAqIDEwKTtcblxuICAgIHJldHVybiBlZGl0U2NyaXB0LnJldmVyc2UoKTtcbn1cblxuLy9cbi8vIFRoaXMgYmVjb21lcyBrby5vcHRpb25zXG4vLyAtLVxuLy9cbi8vIFRoaXMgaXMgdGhlIHJvb3QgJ29wdGlvbnMnLCB3aGljaCBtdXN0IGJlIGV4dGVuZGVkIGJ5IG90aGVycy5cblxudmFyIF9nbG9iYWw7XG5cbnRyeSB7IF9nbG9iYWwgPSB3aW5kb3c7IH0gY2F0Y2ggKGUpIHsgX2dsb2JhbCA9IGdsb2JhbDsgfVxuXG52YXIgb3B0aW9ucyA9IHtcbiAgZGVmZXJVcGRhdGVzOiBmYWxzZSxcblxuICBwcm90b1Byb3BlcnR5OiAnX19rb19wcm90b19fJyxcblxuICAgIC8vIEdsb2JhbCB2YXJpYWJsZXMgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbSBiaW5kaW5ncy5cbiAgYmluZGluZ0dsb2JhbHM6IF9nbG9iYWwsXG5cbiAgUHJvbWlzZTogX2dsb2JhbCAmJiBfZ2xvYmFsLlByb21pc2UsXG5cbiAgdGFza1NjaGVkdWxlcjogbnVsbCxcblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBkb2N1bWVudDogX2dsb2JhbC5kb2N1bWVudCxcblxuICAgIC8vIEZpbHRlcnMgZm9yIGJpbmRpbmdzXG4gICAgLy8gICBkYXRhLWJpbmQ9XCJleHByZXNzaW9uIHwgZmlsdGVyXzEgfCBmaWx0ZXJfMlwiXG4gIGZpbHRlcnM6IHt9LFxuXG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChlKSB7IHRocm93IGUgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMsICckJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wdGlvbnMualF1ZXJ5IH1cbn0pO1xuXG4vL1xuLy8gRXJyb3IgaGFuZGxpbmdcbi8vIC0tLVxuLy9cbi8vIFRoZSBkZWZhdWx0IG9uRXJyb3IgaGFuZGxlciBpcyB0byByZS10aHJvdy5cbmZ1bmN0aW9uIGNhdGNoRnVuY3Rpb25FcnJvcnMoZGVsZWdhdGUpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5vbkVycm9yID8gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0gOiBkZWxlZ2F0ZTtcbn1cblxuZnVuY3Rpb24gZGVmZXJFcnJvcihlcnJvcikge1xuICAgIHNhZmVTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgb3B0aW9ucy5vbkVycm9yKGVycm9yKTsgfSwgMCk7XG59XG5cblxuZnVuY3Rpb24gc2FmZVNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhdGNoRnVuY3Rpb25FcnJvcnMoaGFuZGxlciksIHRpbWVvdXQpO1xufVxuXG4vL1xuLy8gQXN5bmNocm9ub3VzIGZ1bmN0aW9uYWxpdHlcbi8vIC0tLVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dEluc3RhbmNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGltZW91dEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aW1lb3V0SW5zdGFuY2UgPSBzYWZlU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXRJbnN0YW5jZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEluc3RhbmNlKTtcbiAgICAgICAgdGltZW91dEluc3RhbmNlID0gc2FmZVNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgIH07XG59XG5cbi8vXG4vLyBPYmplY3QgZnVuY3Rpb25zXG4vL1xuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvcih2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RGb3JFYWNoKG9iaiwgYWN0aW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgYWN0aW9uKHByb3AsIG9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gb2JqZWN0TWFwKHNvdXJjZSwgbWFwcGluZykge1xuICAgIGlmICghc291cmNlKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBtYXBwaW5nKHNvdXJjZVtwcm9wXSwgcHJvcCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIGdldE9iamVjdE93blByb3BlcnR5KG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IG9ialtwcm9wTmFtZV0gOiB1bmRlZmluZWQ7XG59XG5cblxuZnVuY3Rpb24gY2xvbmVQbGFpbk9iamVjdERlZXAob2JqLCBzZWVuKSB7XG4gICAgaWYgKCFzZWVuKSB7IHNlZW4gPSBbXTsgfVxuXG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCdcbiAgICAgICAgfHwgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3RcbiAgICAgICAgfHwgc2Vlbi5pbmRleE9mKG9iaikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgdGhhdCBtYWtlcyBpdCBiZWxvdyBpcyBhIHBsYWluIG9iamVjdCB0aGF0IGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiBzZWVuL2Nsb25lZC5cbiAgICBzZWVuLnB1c2gob2JqKTtcblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBjbG9uZVBsYWluT2JqZWN0RGVlcChvYmpbcHJvcF0sIHNlZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vXG4vLyBQcm90b3R5cGUgRnVuY3Rpb25zXG4vL1xudmFyIHByb3RvUHJvcGVydHkgPSBvcHRpb25zLnByb3RvUHJvcGVydHk7XG5cbnZhciBjYW5TZXRQcm90b3R5cGUgPSAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSk7XG5cbmZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKG9iaiwgcHJvdG8pIHtcbiAgICBvYmouX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIG9iajtcbn1cblxudmFyIHNldFByb3RvdHlwZU9mT3JFeHRlbmQgPSBjYW5TZXRQcm90b3R5cGUgPyBzZXRQcm90b3R5cGVPZiA6IGV4dGVuZDtcblxuZnVuY3Rpb24gaGFzUHJvdG90eXBlKGluc3RhbmNlLCBwcm90b3R5cGUpIHtcbiAgICBpZiAoKGluc3RhbmNlID09PSBudWxsKSB8fCAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkgfHwgKGluc3RhbmNlW3Byb3RvUHJvcGVydHldID09PSB1bmRlZmluZWQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGluc3RhbmNlW3Byb3RvUHJvcGVydHldID09PSBwcm90b3R5cGUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBoYXNQcm90b3R5cGUoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0sIHByb3RvdHlwZSk7IC8vIFdhbGsgdGhlIHByb3RvdHlwZSBjaGFpblxufVxuXG4vL1xuLy8gU3RyaW5nIChhbmQgSlNPTilcbi8vXG5cblxuZnVuY3Rpb24gc3RyaW5nVHJpbSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcnIDpcbiAgICAgICAgc3RyaW5nLnRyaW0gP1xuICAgICAgICAgICAgc3RyaW5nLnRyaW0oKSA6XG4gICAgICAgICAgICBzdHJpbmcudG9TdHJpbmcoKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csICcnKTtcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTdGFydHNXaXRoIChzdHJpbmcsIHN0YXJ0c1dpdGgpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcgfHwgXCJcIjtcbiAgICBpZiAoc3RhcnRzV2l0aC5sZW5ndGggPiBzdHJpbmcubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgc3RhcnRzV2l0aC5sZW5ndGgpID09PSBzdGFydHNXaXRoO1xufVxuXG5cbmZ1bmN0aW9uIHBhcnNlSnNvbiAoanNvblN0cmluZykge1xuICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGpzb25TdHJpbmcgPSBzdHJpbmdUcmltKGpzb25TdHJpbmcpO1xuICAgICAgICBpZiAoanNvblN0cmluZykge1xuICAgICAgICAgICAgaWYgKEpTT04gJiYgSlNPTi5wYXJzZSkgLy8gVXNlIG5hdGl2ZSBwYXJzaW5nIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBqc29uU3RyaW5nKSkoKTsgLy8gRmFsbGJhY2sgb24gbGVzcyBzYWZlIHBhcnNpbmcgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5SnNvbiAoZGF0YSwgcmVwbGFjZXIsIHNwYWNlKSB7ICAgLy8gcmVwbGFjZXIgYW5kIHNwYWNlIGFyZSBvcHRpb25hbFxuICAgIGlmICghSlNPTiB8fCAhSlNPTi5zdHJpbmdpZnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIEpTT04uc3RyaW5naWZ5KCkuIFNvbWUgYnJvd3NlcnMgKGUuZy4sIElFIDwgOCkgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseSwgYnV0IHlvdSBjYW4gb3ZlcmNvbWUgdGhpcyBieSBhZGRpbmcgYSBzY3JpcHQgcmVmZXJlbmNlIHRvIGpzb24yLmpzLCBkb3dubG9hZGFibGUgZnJvbSBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IGRhdGEoKSA6IGRhdGEsIHJlcGxhY2VyLCBzcGFjZSk7XG59XG5cbi8vXG4vLyBFUzYgU3ltYm9sc1xuLy9cblxudmFyIHVzZVN5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBjcmVhdGVTeW1ib2xPclN0cmluZyhpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHVzZVN5bWJvbHMgPyBTeW1ib2woaWRlbnRpZmllcikgOiBpZGVudGlmaWVyO1xufVxuXG5cbi8vXG4vLyAgVGFza3MgTWljcm8tc2NoZWR1bGVyXG4vLyAgPT09XG4vL1xuLyogZXNsaW50IG5vLWNvbmQtYXNzaWduOiAwICovXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGFza1F1ZXVlTGVuZ3RoID0gMDtcbnZhciBuZXh0SGFuZGxlID0gMTtcbnZhciBuZXh0SW5kZXhUb1Byb2Nlc3MgPSAwO1xudmFyIHcgPSBvcHRpb25zLmdsb2JhbDtcblxuaWYgKHcgJiYgdy5NdXRhdGlvbk9ic2VydmVyICYmICEody5uYXZpZ2F0b3IgJiYgdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICAvLyBDaHJvbWUgMjcrLCBGaXJlZm94IDE0KywgSUUgMTErLCBPcGVyYSAxNSssIFNhZmFyaSA2LjErLCBub2RlXG4gICAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkICogQ29weXJpZ2h0IChjKSAyMDE0IFBldGthIEFudG9ub3YgKiBMaWNlbnNlOiBNSVRcbiAgICBvcHRpb25zLnRhc2tTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkaXYgPSB3LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKS5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7IH07XG4gICAgfSkoc2NoZWR1bGVkUHJvY2Vzcyk7XG59IGVsc2UgaWYgKHcgJiYgdy5kb2N1bWVudCAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIHcuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgIC8vIElFIDYtMTBcbiAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ZdXp1SlMvc2V0SW1tZWRpYXRlICogQ29weXJpZ2h0IChjKSAyMDEyIEJhcm5lc2FuZG5vYmxlLmNvbSwgbGxjLCBEb25hdm9uIFdlc3QsIGFuZCBEb21lbmljIERlbmljb2xhICogTGljZW5zZTogTUlUXG4gICAgb3B0aW9ucy50YXNrU2NoZWR1bGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBvcHRpb25zLnRhc2tTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Rhc2tzKCkge1xuICAgIGlmICh0YXNrUXVldWVMZW5ndGgpIHtcbiAgICAgICAgLy8gRWFjaCBtYXJrIHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhIGxvZ2ljYWwgZ3JvdXAgb2YgdGFza3MgYW5kIHRoZSBudW1iZXIgb2YgdGhlc2UgZ3JvdXBzIGlzXG4gICAgICAgIC8vIGxpbWl0ZWQgdG8gcHJldmVudCB1bmNoZWNrZWQgcmVjdXJzaW9uLlxuICAgICAgICB2YXIgbWFyayA9IHRhc2tRdWV1ZUxlbmd0aCwgY291bnRNYXJrcyA9IDA7XG5cbiAgICAgICAgLy8gbmV4dEluZGV4VG9Qcm9jZXNzIGtlZXBzIHRyYWNrIG9mIHdoZXJlIHdlIGFyZSBpbiB0aGUgcXVldWU7IHByb2Nlc3NUYXNrcyBjYW4gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IHdpdGhvdXQgaXNzdWVcbiAgICAgICAgZm9yICh2YXIgdGFzazsgbmV4dEluZGV4VG9Qcm9jZXNzIDwgdGFza1F1ZXVlTGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGlmICh0YXNrID0gdGFza1F1ZXVlW25leHRJbmRleFRvUHJvY2VzcysrXSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5kZXhUb1Byb2Nlc3MgPiBtYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50TWFya3MgPj0gNTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEluZGV4VG9Qcm9jZXNzID0gdGFza1F1ZXVlTGVuZ3RoOyAgIC8vIHNraXAgYWxsIHRhc2tzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUgc2luY2UgYW55IG9mIHRoZW0gY291bGQgYmUgY2F1c2luZyB0aGUgcmVjdXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlckVycm9yKEVycm9yKFwiJ1RvbyBtdWNoIHJlY3Vyc2lvbicgYWZ0ZXIgcHJvY2Vzc2luZyBcIiArIGNvdW50TWFya3MgKyBcIiB0YXNrIGdyb3Vwcy5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFyayA9IHRhc2tRdWV1ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyRXJyb3IoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVkUHJvY2VzcygpIHtcbiAgICBwcm9jZXNzVGFza3MoKTtcblxuICAgIC8vIFJlc2V0IHRoZSBxdWV1ZVxuICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aCA9IHRhc2tRdWV1ZS5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVRhc2tQcm9jZXNzaW5nKCkge1xuICAgIG9wdGlvbnMudGFza1NjaGVkdWxlcihzY2hlZHVsZWRQcm9jZXNzKTtcbn1cblxuXG5mdW5jdGlvbiBzY2hlZHVsZShmdW5jKSB7XG4gICAgaWYgKCF0YXNrUXVldWVMZW5ndGgpIHtcbiAgICAgICAgc2NoZWR1bGVUYXNrUHJvY2Vzc2luZygpO1xuICAgIH1cblxuICAgIHRhc2tRdWV1ZVt0YXNrUXVldWVMZW5ndGgrK10gPSBmdW5jO1xuICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbChoYW5kbGUpIHtcbiAgICB2YXIgaW5kZXggPSBoYW5kbGUgLSAobmV4dEhhbmRsZSAtIHRhc2tRdWV1ZUxlbmd0aCk7XG4gICAgaWYgKGluZGV4ID49IG5leHRJbmRleFRvUHJvY2VzcyAmJiBpbmRleCA8IHRhc2tRdWV1ZUxlbmd0aCkge1xuICAgICAgICB0YXNrUXVldWVbaW5kZXhdID0gbnVsbDtcbiAgICB9XG59XG5cbi8vIEZvciB0ZXN0aW5nIG9ubHk6IHJlc2V0IHRoZSBxdWV1ZSBhbmQgcmV0dXJuIHRoZSBwcmV2aW91cyBxdWV1ZSBsZW5ndGhcbmZ1bmN0aW9uIHJlc2V0Rm9yVGVzdGluZygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGFza1F1ZXVlTGVuZ3RoIC0gbmV4dEluZGV4VG9Qcm9jZXNzO1xuICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aCA9IHRhc2tRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5cblxuXG5cbnZhciB0YXNrcyA9IE9iamVjdC5mcmVlemUoe1xuXHRzY2hlZHVsZTogc2NoZWR1bGUsXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRyZXNldEZvclRlc3Rpbmc6IHJlc2V0Rm9yVGVzdGluZyxcblx0cnVuRWFybHk6IHByb2Nlc3NUYXNrc1xufSk7XG5cbmV4cG9ydCB7IHRhc2tzLCBvcHRpb25zLCBhcnJheUZvckVhY2gsIGFycmF5SW5kZXhPZiwgYXJyYXlGaXJzdCwgYXJyYXlSZW1vdmVJdGVtLCBhcnJheUdldERpc3RpbmN0VmFsdWVzLCBhcnJheU1hcCwgYXJyYXlGaWx0ZXIsIGFycmF5UHVzaEFsbCwgYWRkT3JSZW1vdmVJdGVtLCBtYWtlQXJyYXksIHJhbmdlLCBmaW5kTW92ZXNJbkFycmF5Q29tcGFyaXNvbiwgY29tcGFyZUFycmF5cywgdGhyb3R0bGUsIGRlYm91bmNlLCBjYXRjaEZ1bmN0aW9uRXJyb3JzLCBkZWZlckVycm9yLCBzYWZlU2V0VGltZW91dCwgZXh0ZW5kLCBvYmplY3RGb3JFYWNoLCBvYmplY3RNYXAsIGdldE9iamVjdE93blByb3BlcnR5LCBjbG9uZVBsYWluT2JqZWN0RGVlcCwgY2FuU2V0UHJvdG90eXBlLCBzZXRQcm90b3R5cGVPZiwgc2V0UHJvdG90eXBlT2ZPckV4dGVuZCwgaGFzUHJvdG90eXBlLCBzdHJpbmdUcmltLCBzdHJpbmdTdGFydHNXaXRoLCBwYXJzZUpzb24sIHN0cmluZ2lmeUpzb24sIHVzZVN5bWJvbHMsIGNyZWF0ZVN5bWJvbE9yU3RyaW5nIH07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28udXRpbHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekJBO0FBQ0E7QUEyQkE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!**************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/tko/tko.computed.js ***!
  \**************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.throttleExtender = exports.pureComputed = exports.isPureComputed = exports.isComputed = exports.computed = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _tkoUtils = __webpack_require__(/*! ./tko.utils.js */ 2);\n\nvar _tkoObservable = __webpack_require__(/*! ./tko.observable.js */ 0);\n\n//\n// Computed Observable Values\n//\n// (before tko, `computed` was also known as `dependentObservable`)\n//\nvar computedState = (0, _tkoUtils.createSymbolOrString)('_state');\n\nfunction computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options$$1) {\n  if ((typeof evaluatorFunctionOrOptions === 'undefined' ? 'undefined' : _typeof(evaluatorFunctionOrOptions)) === 'object') {\n    // Single-parameter syntax - everything is on this \"options\" param\n    options$$1 = evaluatorFunctionOrOptions;\n  } else {\n    // Multi-parameter syntax - construct the options according to the params passed\n    options$$1 = options$$1 || {};\n    if (evaluatorFunctionOrOptions) {\n      options$$1.read = evaluatorFunctionOrOptions;\n    }\n  }\n  if (typeof options$$1.read !== 'function') {\n    throw Error('Pass a function that returns the value of the computed');\n  }\n\n  var writeFunction = options$$1.write;\n  var state = {\n    latestValue: undefined,\n    isStale: true,\n    isBeingEvaluated: false,\n    suppressDisposalUntilDisposeWhenReturnsFalse: false,\n    isDisposed: false,\n    pure: false,\n    isSleeping: false,\n    readFunction: options$$1.read,\n    evaluatorFunctionTarget: evaluatorFunctionTarget || options$$1.owner,\n    disposeWhen: options$$1.disposeWhen || options$$1.disposeWhen,\n    dependencyTracking: {},\n    dependenciesCount: 0,\n    evaluationTimeoutInstance: null\n  };\n\n  function computedObservable() {\n    if (arguments.length > 0) {\n      if (typeof writeFunction === 'function') {\n        // Writing a value\n        writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n      } else {\n        throw new Error(\"Cannot write a value to a computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n      }\n      return this; // Permits chained assignments\n    } else {\n      // Reading the value\n      _tkoObservable.dependencyDetection.registerDependency(computedObservable);\n      if (state.isStale || state.isSleeping && computedObservable.haveDependenciesChanged()) {\n        computedObservable.evaluateImmediate();\n      }\n      return state.latestValue;\n    }\n  }\n\n  computedObservable[computedState] = state;\n  computedObservable.hasWriteFunction = typeof writeFunction === 'function';\n\n  // Inherit from 'subscribable'\n  if (!_tkoUtils.canSetPrototype) {\n    // 'subscribable' won't be on the prototype chain unless we put it there directly\n    (0, _tkoUtils.extend)(computedObservable, _tkoObservable.subscribable.fn);\n  }\n  _tkoObservable.subscribable.fn.init(computedObservable);\n\n  // Inherit from 'computed'\n  (0, _tkoUtils.setPrototypeOfOrExtend)(computedObservable, computed.fn);\n\n  if (options$$1.pure) {\n    state.pure = true;\n    state.isSleeping = true; // Starts off sleeping; will awake on the first subscription\n    (0, _tkoUtils.extend)(computedObservable, pureComputedOverrides);\n  } else if (options$$1.deferEvaluation) {\n    (0, _tkoUtils.extend)(computedObservable, deferEvaluationOverrides);\n  }\n\n  if (_tkoUtils.options.deferUpdates) {\n    _tkoObservable.extenders.deferred(computedObservable, true);\n  }\n\n  if (_tkoUtils.options.debug) {\n    // #1731 - Aid debugging by exposing the computed's options\n    computedObservable._options = options$$1;\n  }\n\n  // Evaluate, unless sleeping or deferEvaluation is true\n  if (!state.isSleeping && !options$$1.deferEvaluation) {\n    computedObservable.evaluateImmediate();\n  }\n\n  return computedObservable;\n}\n\n// Utility function that disposes a given dependencyTracking entry\nfunction computedDisposeDependencyCallback(id, entryToDispose) {\n  if (entryToDispose !== null && entryToDispose.dispose) {\n    entryToDispose.dispose();\n  }\n}\n\n// This function gets called each time a dependency is detected while evaluating a computed.\n// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\nfunction computedBeginDependencyDetectionCallback(subscribable$$1, id) {\n  var computedObservable = this.computedObservable,\n      state = computedObservable[computedState];\n  if (!state.isDisposed) {\n    if (this.disposalCount && this.disposalCandidates[id]) {\n      // Don't want to dispose this subscription, as it's still being used\n      computedObservable.addDependencyTracking(id, subscribable$$1, this.disposalCandidates[id]);\n      this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n      --this.disposalCount;\n    } else if (!state.dependencyTracking[id]) {\n      // Brand new subscription - add it\n      computedObservable.addDependencyTracking(id, subscribable$$1, state.isSleeping ? { _target: subscribable$$1 } : computedObservable.subscribeToDependency(subscribable$$1));\n    }\n  }\n}\n\ncomputed.fn = {\n  equalityComparer: _tkoObservable.valuesArePrimitiveAndEqual,\n  getDependenciesCount: function getDependenciesCount() {\n    return this[computedState].dependenciesCount;\n  },\n  addDependencyTracking: function addDependencyTracking(id, target, trackingObj) {\n    if (this[computedState].pure && target === this) {\n      throw Error(\"A 'pure' computed must not be called recursively\");\n    }\n\n    this[computedState].dependencyTracking[id] = trackingObj;\n    trackingObj._order = this[computedState].dependenciesCount++;\n    trackingObj._version = target.getVersion();\n  },\n  haveDependenciesChanged: function haveDependenciesChanged() {\n    var id,\n        dependency,\n        dependencyTracking = this[computedState].dependencyTracking;\n    for (id in dependencyTracking) {\n      if (dependencyTracking.hasOwnProperty(id)) {\n        dependency = dependencyTracking[id];\n        if (dependency._target.hasChanged(dependency._version)) {\n          return true;\n        }\n      }\n    }\n  },\n  markDirty: function markDirty() {\n    // Process \"dirty\" events if we can handle delayed notifications\n    if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n      this._evalDelayed();\n    }\n  },\n  isActive: function isActive() {\n    return this[computedState].isStale || this[computedState].dependenciesCount > 0;\n  },\n  respondToChange: function respondToChange() {\n    // Ignore \"change\" events if we've already scheduled a delayed notification\n    if (!this._notificationIsPending) {\n      this.evaluatePossiblyAsync();\n    }\n  },\n  subscribeToDependency: function subscribeToDependency(target) {\n    return target.subscribe(this.evaluatePossiblyAsync, this);\n  },\n  evaluatePossiblyAsync: function evaluatePossiblyAsync() {\n    var computedObservable = this,\n        throttleEvaluationTimeout = computedObservable.throttleEvaluation;\n    if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n      clearTimeout(this[computedState].evaluationTimeoutInstance);\n      this[computedState].evaluationTimeoutInstance = (0, _tkoUtils.safeSetTimeout)(function () {\n        computedObservable.evaluateImmediate(true /* notifyChange */);\n      }, throttleEvaluationTimeout);\n    } else if (computedObservable._evalDelayed) {\n      computedObservable._evalDelayed();\n    } else {\n      computedObservable.evaluateImmediate(true /* notifyChange */);\n    }\n  },\n  evaluateImmediate: function evaluateImmediate(notifyChange) {\n    var computedObservable = this,\n        state = computedObservable[computedState],\n        disposeWhen = state.disposeWhen;\n\n    if (state.isBeingEvaluated) {\n      // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n      // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n      // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n      // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n      return;\n    }\n\n    // Do not evaluate (and possibly capture new dependencies) if disposed\n    if (state.isDisposed) {\n      return;\n    }\n\n    // It just did return false, so we can stop suppressing now\n    state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n\n    state.isBeingEvaluated = true;\n    try {\n      this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n    } finally {\n      state.isBeingEvaluated = false;\n    }\n\n    if (!state.dependenciesCount) {\n      computedObservable.dispose();\n    }\n  },\n  evaluateImmediate_CallReadWithDependencyDetection: function evaluateImmediate_CallReadWithDependencyDetection(notifyChange) {\n    // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n    // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n    // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n    var computedObservable = this,\n        state = computedObservable[computedState];\n\n    // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n    // Then, during evaluation, we cross off any that are in fact still being used.\n    var isInitial = state.pure ? undefined : !state.dependenciesCount,\n        // If we're evaluating when there are no previous dependencies, it must be the first time\n    dependencyDetectionContext = {\n      computedObservable: computedObservable,\n      disposalCandidates: state.dependencyTracking,\n      disposalCount: state.dependenciesCount\n    };\n\n    _tkoObservable.dependencyDetection.begin({\n      callbackTarget: dependencyDetectionContext,\n      callback: computedBeginDependencyDetectionCallback,\n      computed: computedObservable,\n      isInitial: isInitial\n    });\n\n    state.dependencyTracking = {};\n    state.dependenciesCount = 0;\n\n    var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n    if (computedObservable.isDifferent(state.latestValue, newValue)) {\n      if (!state.isSleeping) {\n        computedObservable.notifySubscribers(state.latestValue, 'beforeChange');\n      }\n\n      state.latestValue = newValue;\n\n      if (state.isSleeping) {\n        computedObservable.updateVersion();\n      } else if (notifyChange) {\n        computedObservable.notifySubscribers(state.latestValue);\n      }\n    }\n\n    if (isInitial) {\n      computedObservable.notifySubscribers(state.latestValue, 'awake');\n    }\n  },\n  evaluateImmediate_CallReadThenEndDependencyDetection: function evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext) {\n    // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n    // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n    // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n    // overhead of computed evaluation (on V8 at least).\n\n    try {\n      var readFunction = state.readFunction;\n      return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();\n    } finally {\n      _tkoObservable.dependencyDetection.end();\n\n      // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n      if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n        (0, _tkoUtils.objectForEach)(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n      }\n\n      state.isStale = false;\n    }\n  },\n  peek: function peek() {\n    // Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when \"deferEvaluation\" is set.\n    var state = this[computedState];\n    if (state.isStale && !state.dependenciesCount || state.isSleeping && this.haveDependenciesChanged()) {\n      this.evaluateImmediate();\n    }\n    return state.latestValue;\n  },\n  limit: function limit(limitFunction) {\n    // Override the limit function with one that delays evaluation as well\n    _tkoObservable.subscribable.fn.limit.call(this, limitFunction);\n    this._evalDelayed = function () {\n      this._limitBeforeChange(this[computedState].latestValue);\n\n      this[computedState].isStale = true; // Mark as dirty\n\n      // Pass the observable to the \"limit\" code, which will access it when\n      // it's time to do the notification.\n      this._limitChange(this);\n    };\n  },\n  dispose: function dispose() {\n    var state = this[computedState];\n    if (!state.isSleeping && state.dependencyTracking) {\n      (0, _tkoUtils.objectForEach)(state.dependencyTracking, function (id, dependency) {\n        if (dependency.dispose) {\n          dependency.dispose();\n        }\n      });\n    }\n    state.dependencyTracking = null;\n    state.dependenciesCount = 0;\n    state.isDisposed = true;\n    state.isStale = false;\n    state.isSleeping = false;\n    state.readFunction = null;\n    if (_tkoUtils.options.debug) {\n      this._options = null;\n    }\n  }\n};\n\nvar pureComputedOverrides = {\n  beforeSubscriptionAdd: function beforeSubscriptionAdd(event) {\n    // If asleep, wake up the computed by subscribing to any dependencies.\n    var computedObservable = this,\n        state = computedObservable[computedState];\n    if (!state.isDisposed && state.isSleeping && event == 'change') {\n      state.isSleeping = false;\n      if (state.isStale || computedObservable.haveDependenciesChanged()) {\n        state.dependencyTracking = null;\n        state.dependenciesCount = 0;\n        state.isStale = true;\n        computedObservable.evaluateImmediate();\n      } else {\n        // First put the dependencies in order\n        var dependeciesOrder = [];\n        (0, _tkoUtils.objectForEach)(state.dependencyTracking, function (id, dependency) {\n          dependeciesOrder[dependency._order] = id;\n        });\n        // Next, subscribe to each one\n        (0, _tkoUtils.arrayForEach)(dependeciesOrder, function (id, order) {\n          var dependency = state.dependencyTracking[id],\n              subscription = computedObservable.subscribeToDependency(dependency._target);\n          subscription._order = order;\n          subscription._version = dependency._version;\n          state.dependencyTracking[id] = subscription;\n        });\n      }\n      if (!state.isDisposed) {\n        // test since evaluating could trigger disposal\n        computedObservable.notifySubscribers(state.latestValue, 'awake');\n      }\n    }\n  },\n  afterSubscriptionRemove: function afterSubscriptionRemove(event) {\n    var state = this[computedState];\n    if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {\n      (0, _tkoUtils.objectForEach)(state.dependencyTracking, function (id, dependency) {\n        if (dependency.dispose) {\n          state.dependencyTracking[id] = {\n            _target: dependency._target,\n            _order: dependency._order,\n            _version: dependency._version\n          };\n          dependency.dispose();\n        }\n      });\n      state.isSleeping = true;\n      this.notifySubscribers(undefined, 'asleep');\n    }\n  },\n  getVersion: function getVersion() {\n    // Because a pure computed is not automatically updated while it is sleeping, we can't\n    // simply return the version number. Instead, we check if any of the dependencies have\n    // changed and conditionally re-evaluate the computed observable.\n    var state = this[computedState];\n    if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n      this.evaluateImmediate();\n    }\n    return _tkoObservable.subscribable.fn.getVersion.call(this);\n  }\n};\n\nvar deferEvaluationOverrides = {\n  beforeSubscriptionAdd: function beforeSubscriptionAdd(event) {\n    // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n    if (event == 'change' || event == 'beforeChange') {\n      this.peek();\n    }\n  }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.computed constructor\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(computed.fn, _tkoObservable.subscribable.fn);\n}\n\n// Set the proto chain values for ko.hasPrototype\nvar protoProp = _tkoObservable.observable.protoProperty;\ncomputed[protoProp] = _tkoObservable.observable;\ncomputed.fn[protoProp] = computed;\n\nfunction isComputed(instance) {\n  return (0, _tkoUtils.hasPrototype)(instance, computed);\n}\n\nfunction isPureComputed(instance) {\n  return (0, _tkoUtils.hasPrototype)(instance, computed) && instance[computedState] && instance[computedState].pure;\n}\n\nfunction pureComputed(evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n  if (typeof evaluatorFunctionOrOptions === 'function') {\n    return computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, { 'pure': true });\n  } else {\n    evaluatorFunctionOrOptions = (0, _tkoUtils.extend)({}, evaluatorFunctionOrOptions); // make a copy of the parameter object\n    evaluatorFunctionOrOptions.pure = true;\n    return computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);\n  }\n}\n\nfunction throttleExtender(target, timeout) {\n  // Throttling means two things:\n\n  // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n  //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n  target.throttleEvaluation = timeout;\n\n  // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n  //     so the target cannot change value synchronously or faster than a certain rate\n  var writeTimeoutInstance = null;\n  return computed({\n    read: target,\n    write: function write(value) {\n      clearTimeout(writeTimeoutInstance);\n      writeTimeoutInstance = setTimeout(function () {\n        target(value);\n      }, timeout);\n    }\n  });\n}\n\n_tkoObservable.extenders.throttle = throttleExtender;\n\n//\n// tko.computed - Exports\n//\n// knockout -> tko changes:\n//      Deprecates `dependentObservable` (use `computed`)\n//\n\nexports.computed = computed;\nexports.isComputed = isComputed;\nexports.isPureComputed = isPureComputed;\nexports.pureComputed = pureComputed;\nexports.throttleExtender = throttleExtender;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28uY29tcHV0ZWQuanM/NTJjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcnJheUZvckVhY2gsIGNhblNldFByb3RvdHlwZSwgY3JlYXRlU3ltYm9sT3JTdHJpbmcsIGV4dGVuZCwgaGFzUHJvdG90eXBlLCBvYmplY3RGb3JFYWNoLCBvcHRpb25zLCBzYWZlU2V0VGltZW91dCwgc2V0UHJvdG90eXBlT2YsIHNldFByb3RvdHlwZU9mT3JFeHRlbmQgfSBmcm9tICcuL3Rrby51dGlscy5qcyc7XG5pbXBvcnQgeyBkZXBlbmRlbmN5RGV0ZWN0aW9uLCBleHRlbmRlcnMsIG9ic2VydmFibGUsIHN1YnNjcmliYWJsZSwgdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwgfSBmcm9tICcuL3Rrby5vYnNlcnZhYmxlLmpzJztcblxuLy9cbi8vIENvbXB1dGVkIE9ic2VydmFibGUgVmFsdWVzXG4vL1xuLy8gKGJlZm9yZSB0a28sIGBjb21wdXRlZGAgd2FzIGFsc28ga25vd24gYXMgYGRlcGVuZGVudE9ic2VydmFibGVgKVxuLy9cbnZhciBjb21wdXRlZFN0YXRlID0gY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19zdGF0ZScpO1xuXG5mdW5jdGlvbiBjb21wdXRlZCAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBvcHRpb25zJCQxKSB7XG4gIGlmICh0eXBlb2YgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFNpbmdsZS1wYXJhbWV0ZXIgc3ludGF4IC0gZXZlcnl0aGluZyBpcyBvbiB0aGlzIFwib3B0aW9uc1wiIHBhcmFtXG4gICAgb3B0aW9ucyQkMSA9IGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgICAgICAvLyBNdWx0aS1wYXJhbWV0ZXIgc3ludGF4IC0gY29uc3RydWN0IHRoZSBvcHRpb25zIGFjY29yZGluZyB0byB0aGUgcGFyYW1zIHBhc3NlZFxuICAgIG9wdGlvbnMkJDEgPSBvcHRpb25zJCQxIHx8IHt9O1xuICAgIGlmIChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucykge1xuICAgICAgb3B0aW9ucyQkMS5yZWFkID0gZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnM7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyQkMS5yZWFkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1Bhc3MgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjb21wdXRlZCcpXG4gIH1cblxuICB2YXIgd3JpdGVGdW5jdGlvbiA9IG9wdGlvbnMkJDEud3JpdGU7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBsYXRlc3RWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGlzU3RhbGU6IHRydWUsXG4gICAgaXNCZWluZ0V2YWx1YXRlZDogZmFsc2UsXG4gICAgc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2U6IGZhbHNlLFxuICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgIHB1cmU6IGZhbHNlLFxuICAgIGlzU2xlZXBpbmc6IGZhbHNlLFxuICAgIHJlYWRGdW5jdGlvbjogb3B0aW9ucyQkMS5yZWFkLFxuICAgIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0OiBldmFsdWF0b3JGdW5jdGlvblRhcmdldCB8fCBvcHRpb25zJCQxLm93bmVyLFxuICAgIGRpc3Bvc2VXaGVuOiBvcHRpb25zJCQxLmRpc3Bvc2VXaGVuIHx8IG9wdGlvbnMkJDEuZGlzcG9zZVdoZW4sXG4gICAgZGVwZW5kZW5jeVRyYWNraW5nOiB7fSxcbiAgICBkZXBlbmRlbmNpZXNDb3VudDogMCxcbiAgICBldmFsdWF0aW9uVGltZW91dEluc3RhbmNlOiBudWxsXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcHV0ZWRPYnNlcnZhYmxlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygd3JpdGVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIFdyaXRpbmcgYSB2YWx1ZVxuICAgICAgICB3cml0ZUZ1bmN0aW9uLmFwcGx5KHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIGEgdmFsdWUgdG8gYSBjb21wdXRlZCB1bmxlc3MgeW91IHNwZWNpZnkgYSAnd3JpdGUnIG9wdGlvbi4gSWYgeW91IHdpc2ggdG8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSwgZG9uJ3QgcGFzcyBhbnkgcGFyYW1ldGVycy5cIilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzIC8vIFBlcm1pdHMgY2hhaW5lZCBhc3NpZ25tZW50c1xuICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWFkaW5nIHRoZSB2YWx1ZVxuICAgICAgZGVwZW5kZW5jeURldGVjdGlvbi5yZWdpc3RlckRlcGVuZGVuY3koY29tcHV0ZWRPYnNlcnZhYmxlKTtcbiAgICAgIGlmIChzdGF0ZS5pc1N0YWxlIHx8IChzdGF0ZS5pc1NsZWVwaW5nICYmIGNvbXB1dGVkT2JzZXJ2YWJsZS5oYXZlRGVwZW5kZW5jaWVzQ2hhbmdlZCgpKSkge1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZS5sYXRlc3RWYWx1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbXB1dGVkT2JzZXJ2YWJsZVtjb21wdXRlZFN0YXRlXSA9IHN0YXRlO1xuICBjb21wdXRlZE9ic2VydmFibGUuaGFzV3JpdGVGdW5jdGlvbiA9IHR5cGVvZiB3cml0ZUZ1bmN0aW9uID09PSAnZnVuY3Rpb24nO1xuXG4gICAgLy8gSW5oZXJpdCBmcm9tICdzdWJzY3JpYmFibGUnXG4gIGlmICghY2FuU2V0UHJvdG90eXBlKSB7XG4gICAgICAgIC8vICdzdWJzY3JpYmFibGUnIHdvbid0IGJlIG9uIHRoZSBwcm90b3R5cGUgY2hhaW4gdW5sZXNzIHdlIHB1dCBpdCB0aGVyZSBkaXJlY3RseVxuICAgIGV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIHN1YnNjcmliYWJsZS5mbik7XG4gIH1cbiAgc3Vic2NyaWJhYmxlLmZuLmluaXQoY29tcHV0ZWRPYnNlcnZhYmxlKTtcblxuICAgIC8vIEluaGVyaXQgZnJvbSAnY29tcHV0ZWQnXG4gIHNldFByb3RvdHlwZU9mT3JFeHRlbmQoY29tcHV0ZWRPYnNlcnZhYmxlLCBjb21wdXRlZC5mbik7XG5cbiAgaWYgKG9wdGlvbnMkJDEucHVyZSkge1xuICAgIHN0YXRlLnB1cmUgPSB0cnVlO1xuICAgIHN0YXRlLmlzU2xlZXBpbmcgPSB0cnVlOyAgICAgLy8gU3RhcnRzIG9mZiBzbGVlcGluZzsgd2lsbCBhd2FrZSBvbiB0aGUgZmlyc3Qgc3Vic2NyaXB0aW9uXG4gICAgZXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwgcHVyZUNvbXB1dGVkT3ZlcnJpZGVzKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zJCQxLmRlZmVyRXZhbHVhdGlvbikge1xuICAgIGV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIGRlZmVyRXZhbHVhdGlvbk92ZXJyaWRlcyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5kZWZlclVwZGF0ZXMpIHtcbiAgICBleHRlbmRlcnMuZGVmZXJyZWQoY29tcHV0ZWRPYnNlcnZhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIC8vICMxNzMxIC0gQWlkIGRlYnVnZ2luZyBieSBleHBvc2luZyB0aGUgY29tcHV0ZWQncyBvcHRpb25zXG4gICAgY29tcHV0ZWRPYnNlcnZhYmxlLl9vcHRpb25zID0gb3B0aW9ucyQkMTtcbiAgfVxuXG4gIC8vIEV2YWx1YXRlLCB1bmxlc3Mgc2xlZXBpbmcgb3IgZGVmZXJFdmFsdWF0aW9uIGlzIHRydWVcbiAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nICYmICFvcHRpb25zJCQxLmRlZmVyRXZhbHVhdGlvbikge1xuICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSgpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXB1dGVkT2JzZXJ2YWJsZVxufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgZGlzcG9zZXMgYSBnaXZlbiBkZXBlbmRlbmN5VHJhY2tpbmcgZW50cnlcbmZ1bmN0aW9uIGNvbXB1dGVkRGlzcG9zZURlcGVuZGVuY3lDYWxsYmFjayAoaWQsIGVudHJ5VG9EaXNwb3NlKSB7XG4gIGlmIChlbnRyeVRvRGlzcG9zZSAhPT0gbnVsbCAmJiBlbnRyeVRvRGlzcG9zZS5kaXNwb3NlKSB7XG4gICAgZW50cnlUb0Rpc3Bvc2UuZGlzcG9zZSgpO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZWFjaCB0aW1lIGEgZGVwZW5kZW5jeSBpcyBkZXRlY3RlZCB3aGlsZSBldmFsdWF0aW5nIGEgY29tcHV0ZWQuXG4vLyBJdCdzIGZhY3RvcmVkIG91dCBhcyBhIHNoYXJlZCBmdW5jdGlvbiB0byBhdm9pZCBjcmVhdGluZyB1bm5lY2Vzc2FyeSBmdW5jdGlvbiBpbnN0YW5jZXMgZHVyaW5nIGV2YWx1YXRpb24uXG5mdW5jdGlvbiBjb21wdXRlZEJlZ2luRGVwZW5kZW5jeURldGVjdGlvbkNhbGxiYWNrIChzdWJzY3JpYmFibGUkJDEsIGlkKSB7XG4gIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLmNvbXB1dGVkT2JzZXJ2YWJsZSxcbiAgICBzdGF0ZSA9IGNvbXB1dGVkT2JzZXJ2YWJsZVtjb21wdXRlZFN0YXRlXTtcbiAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkKSB7XG4gICAgaWYgKHRoaXMuZGlzcG9zYWxDb3VudCAmJiB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0pIHtcbiAgICAgICAgICAgIC8vIERvbid0IHdhbnQgdG8gZGlzcG9zZSB0aGlzIHN1YnNjcmlwdGlvbiwgYXMgaXQncyBzdGlsbCBiZWluZyB1c2VkXG4gICAgICBjb21wdXRlZE9ic2VydmFibGUuYWRkRGVwZW5kZW5jeVRyYWNraW5nKGlkLCBzdWJzY3JpYmFibGUkJDEsIHRoaXMuZGlzcG9zYWxDYW5kaWRhdGVzW2lkXSk7XG4gICAgICB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0gPSBudWxsOyAvLyBObyBuZWVkIHRvIGFjdHVhbGx5IGRlbGV0ZSB0aGUgcHJvcGVydHkgLSBkaXNwb3NhbENhbmRpZGF0ZXMgaXMgYSB0cmFuc2llbnQgb2JqZWN0IGFueXdheVxuICAgICAgLS10aGlzLmRpc3Bvc2FsQ291bnQ7XG4gICAgfSBlbHNlIGlmICghc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nW2lkXSkge1xuICAgICAgICAgICAgLy8gQnJhbmQgbmV3IHN1YnNjcmlwdGlvbiAtIGFkZCBpdFxuICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmFkZERlcGVuZGVuY3lUcmFja2luZyhpZCwgc3Vic2NyaWJhYmxlJCQxLCBzdGF0ZS5pc1NsZWVwaW5nID8geyBfdGFyZ2V0OiBzdWJzY3JpYmFibGUkJDEgfSA6IGNvbXB1dGVkT2JzZXJ2YWJsZS5zdWJzY3JpYmVUb0RlcGVuZGVuY3koc3Vic2NyaWJhYmxlJCQxKSk7XG4gICAgfVxuICB9XG59XG5cbmNvbXB1dGVkLmZuID0ge1xuICBlcXVhbGl0eUNvbXBhcmVyOiB2YWx1ZXNBcmVQcmltaXRpdmVBbmRFcXVhbCxcbiAgZ2V0RGVwZW5kZW5jaWVzQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tjb21wdXRlZFN0YXRlXS5kZXBlbmRlbmNpZXNDb3VudFxuICB9LFxuICBhZGREZXBlbmRlbmN5VHJhY2tpbmc6IGZ1bmN0aW9uIChpZCwgdGFyZ2V0LCB0cmFja2luZ09iaikge1xuICAgIGlmICh0aGlzW2NvbXB1dGVkU3RhdGVdLnB1cmUgJiYgdGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkEgJ3B1cmUnIGNvbXB1dGVkIG11c3Qgbm90IGJlIGNhbGxlZCByZWN1cnNpdmVseVwiKVxuICAgIH1cblxuICAgIHRoaXNbY29tcHV0ZWRTdGF0ZV0uZGVwZW5kZW5jeVRyYWNraW5nW2lkXSA9IHRyYWNraW5nT2JqO1xuICAgIHRyYWNraW5nT2JqLl9vcmRlciA9IHRoaXNbY29tcHV0ZWRTdGF0ZV0uZGVwZW5kZW5jaWVzQ291bnQrKztcbiAgICB0cmFja2luZ09iai5fdmVyc2lvbiA9IHRhcmdldC5nZXRWZXJzaW9uKCk7XG4gIH0sXG4gIGhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkLCBkZXBlbmRlbmN5LCBkZXBlbmRlbmN5VHJhY2tpbmcgPSB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY3lUcmFja2luZztcbiAgICBmb3IgKGlkIGluIGRlcGVuZGVuY3lUcmFja2luZykge1xuICAgICAgaWYgKGRlcGVuZGVuY3lUcmFja2luZy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gICAgICAgIGlmIChkZXBlbmRlbmN5Ll90YXJnZXQuaGFzQ2hhbmdlZChkZXBlbmRlbmN5Ll92ZXJzaW9uKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hcmtEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcm9jZXNzIFwiZGlydHlcIiBldmVudHMgaWYgd2UgY2FuIGhhbmRsZSBkZWxheWVkIG5vdGlmaWNhdGlvbnNcbiAgICBpZiAodGhpcy5fZXZhbERlbGF5ZWQgJiYgIXRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgdGhpcy5fZXZhbERlbGF5ZWQoKTtcbiAgICB9XG4gIH0sXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNTdGFsZSB8fCB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50ID4gMFxuICB9LFxuICByZXNwb25kVG9DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWdub3JlIFwiY2hhbmdlXCIgZXZlbnRzIGlmIHdlJ3ZlIGFscmVhZHkgc2NoZWR1bGVkIGEgZGVsYXllZCBub3RpZmljYXRpb25cbiAgICBpZiAoIXRoaXMuX25vdGlmaWNhdGlvbklzUGVuZGluZykge1xuICAgICAgdGhpcy5ldmFsdWF0ZVBvc3NpYmx5QXN5bmMoKTtcbiAgICB9XG4gIH0sXG4gIHN1YnNjcmliZVRvRGVwZW5kZW5jeTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3Vic2NyaWJlKHRoaXMuZXZhbHVhdGVQb3NzaWJseUFzeW5jLCB0aGlzKVxuICB9LFxuICBldmFsdWF0ZVBvc3NpYmx5QXN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQgPSBjb21wdXRlZE9ic2VydmFibGUudGhyb3R0bGVFdmFsdWF0aW9uO1xuICAgIGlmICh0aHJvdHRsZUV2YWx1YXRpb25UaW1lb3V0ICYmIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQgPj0gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXNbY29tcHV0ZWRTdGF0ZV0uZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZSk7XG4gICAgICB0aGlzW2NvbXB1dGVkU3RhdGVdLmV2YWx1YXRpb25UaW1lb3V0SW5zdGFuY2UgPSBzYWZlU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSh0cnVlIC8qIG5vdGlmeUNoYW5nZSAqLyk7XG4gICAgICB9LCB0aHJvdHRsZUV2YWx1YXRpb25UaW1lb3V0KTtcbiAgICB9IGVsc2UgaWYgKGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQpIHtcbiAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5fZXZhbERlbGF5ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKHRydWUgLyogbm90aWZ5Q2hhbmdlICovKTtcbiAgICB9XG4gIH0sXG4gIGV2YWx1YXRlSW1tZWRpYXRlOiBmdW5jdGlvbiAobm90aWZ5Q2hhbmdlKSB7XG4gICAgdmFyIGNvbXB1dGVkT2JzZXJ2YWJsZSA9IHRoaXMsXG4gICAgICBzdGF0ZSA9IGNvbXB1dGVkT2JzZXJ2YWJsZVtjb21wdXRlZFN0YXRlXSxcbiAgICAgIGRpc3Bvc2VXaGVuID0gc3RhdGUuZGlzcG9zZVdoZW47XG5cbiAgICBpZiAoc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV2YWx1YXRpb24gb2YgYSBrby5jb21wdXRlZCBjYXVzZXMgc2lkZSBlZmZlY3RzLCBpdCdzIHBvc3NpYmxlIHRoYXQgaXQgd2lsbCB0cmlnZ2VyIGl0cyBvd24gcmUtZXZhbHVhdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGRlc2lyYWJsZSAoaXQncyBoYXJkIGZvciBhIGRldmVsb3BlciB0byByZWFsaXNlIGEgY2hhaW4gb2YgZGVwZW5kZW5jaWVzIG1pZ2h0IGNhdXNlIHRoaXMsIGFuZCB0aGV5IGFsbW9zdFxuICAgICAgICAgICAgLy8gY2VydGFpbmx5IGRpZG4ndCBpbnRlbmQgaW5maW5pdGUgcmUtZXZhbHVhdGlvbnMpLiBTbywgZm9yIHByZWRpY3RhYmlsaXR5LCB3ZSBzaW1wbHkgcHJldmVudCBrby5jb21wdXRlZHMgZnJvbSBjYXVzaW5nXG4gICAgICAgICAgICAvLyB0aGVpciBvd24gcmUtZXZhbHVhdGlvbi4gRnVydGhlciBkaXNjdXNzaW9uIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9TdGV2ZVNhbmRlcnNvbi9rbm9ja291dC9wdWxsLzM4N1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgICAgIC8vIERvIG5vdCBldmFsdWF0ZSAoYW5kIHBvc3NpYmx5IGNhcHR1cmUgbmV3IGRlcGVuZGVuY2llcykgaWYgZGlzcG9zZWRcbiAgICBpZiAoc3RhdGUuaXNEaXNwb3NlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSXQganVzdCBkaWQgcmV0dXJuIGZhbHNlLCBzbyB3ZSBjYW4gc3RvcCBzdXBwcmVzc2luZyBub3dcbiAgICBzdGF0ZS5zdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZSA9IGZhbHNlO1xuXG4gICAgc3RhdGUuaXNCZWluZ0V2YWx1YXRlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvbihub3RpZnlDaGFuZ2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzdGF0ZS5pc0JlaW5nRXZhbHVhdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCkge1xuICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sXG4gIGV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkV2l0aERlcGVuZGVuY3lEZXRlY3Rpb246IGZ1bmN0aW9uIChub3RpZnlDaGFuZ2UpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyByZWFsbHkganVzdCBwYXJ0IG9mIHRoZSBldmFsdWF0ZUltbWVkaWF0ZSBsb2dpYy4gWW91IHdvdWxkIG5ldmVyIGNhbGwgaXQgZnJvbSBhbnl3aGVyZSBlbHNlLlxuICAgICAgICAvLyBGYWN0b3JpbmcgaXQgb3V0IGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvbiBtZWFucyBpdCBjYW4gYmUgaW5kZXBlbmRlbnQgb2YgdGhlIHRyeS9jYXRjaCBibG9jayBpbiBldmFsdWF0ZUltbWVkaWF0ZSxcbiAgICAgICAgLy8gd2hpY2ggY29udHJpYnV0ZXMgdG8gc2F2aW5nIGFib3V0IDQwJSBvZmYgdGhlIENQVSBvdmVyaGVhZCBvZiBjb21wdXRlZCBldmFsdWF0aW9uIChvbiBWOCBhdCBsZWFzdCkuXG5cbiAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdO1xuXG4gICAgICAgIC8vIEluaXRpYWxseSwgd2UgYXNzdW1lIHRoYXQgbm9uZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyBhcmUgc3RpbGwgYmVpbmcgdXNlZCAoaS5lLiwgYWxsIGFyZSBjYW5kaWRhdGVzIGZvciBkaXNwb3NhbCkuXG4gICAgICAgIC8vIFRoZW4sIGR1cmluZyBldmFsdWF0aW9uLCB3ZSBjcm9zcyBvZmYgYW55IHRoYXQgYXJlIGluIGZhY3Qgc3RpbGwgYmVpbmcgdXNlZC5cbiAgICB2YXIgaXNJbml0aWFsID0gc3RhdGUucHVyZSA/IHVuZGVmaW5lZCA6ICFzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCwgICAvLyBJZiB3ZSdyZSBldmFsdWF0aW5nIHdoZW4gdGhlcmUgYXJlIG5vIHByZXZpb3VzIGRlcGVuZGVuY2llcywgaXQgbXVzdCBiZSB0aGUgZmlyc3QgdGltZVxuICAgICAgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZTogY29tcHV0ZWRPYnNlcnZhYmxlLFxuICAgICAgICBkaXNwb3NhbENhbmRpZGF0ZXM6IHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyxcbiAgICAgICAgZGlzcG9zYWxDb3VudDogc3RhdGUuZGVwZW5kZW5jaWVzQ291bnRcbiAgICAgIH07XG5cbiAgICBkZXBlbmRlbmN5RGV0ZWN0aW9uLmJlZ2luKHtcbiAgICAgIGNhbGxiYWNrVGFyZ2V0OiBkZXBlbmRlbmN5RGV0ZWN0aW9uQ29udGV4dCxcbiAgICAgIGNhbGxiYWNrOiBjb21wdXRlZEJlZ2luRGVwZW5kZW5jeURldGVjdGlvbkNhbGxiYWNrLFxuICAgICAgY29tcHV0ZWQ6IGNvbXB1dGVkT2JzZXJ2YWJsZSxcbiAgICAgIGlzSW5pdGlhbDogaXNJbml0aWFsXG4gICAgfSk7XG5cbiAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSB7fTtcbiAgICBzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCA9IDA7XG5cbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkVGhlbkVuZERlcGVuZGVuY3lEZXRlY3Rpb24oc3RhdGUsIGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0KTtcblxuICAgIGlmIChjb21wdXRlZE9ic2VydmFibGUuaXNEaWZmZXJlbnQoc3RhdGUubGF0ZXN0VmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ub3RpZnlTdWJzY3JpYmVycyhzdGF0ZS5sYXRlc3RWYWx1ZSwgJ2JlZm9yZUNoYW5nZScpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5sYXRlc3RWYWx1ZSA9IG5ld1ZhbHVlO1xuXG4gICAgICBpZiAoc3RhdGUuaXNTbGVlcGluZykge1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUudXBkYXRlVmVyc2lvbigpO1xuICAgICAgfSBlbHNlIGlmIChub3RpZnlDaGFuZ2UpIHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHN0YXRlLmxhdGVzdFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNJbml0aWFsKSB7XG4gICAgICBjb21wdXRlZE9ic2VydmFibGUubm90aWZ5U3Vic2NyaWJlcnMoc3RhdGUubGF0ZXN0VmFsdWUsICdhd2FrZScpO1xuICAgIH1cbiAgfSxcbiAgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRUaGVuRW5kRGVwZW5kZW5jeURldGVjdGlvbjogZnVuY3Rpb24gKHN0YXRlLCBkZXBlbmRlbmN5RGV0ZWN0aW9uQ29udGV4dCkge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlYWxseSBwYXJ0IG9mIHRoZSBldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFdpdGhEZXBlbmRlbmN5RGV0ZWN0aW9uIGxvZ2ljLlxuICAgICAgICAvLyBZb3UnZCBuZXZlciBjYWxsIGl0IGZyb20gYW55d2hlcmUgZWxzZS4gRmFjdG9yaW5nIGl0IG91dCBtZWFucyB0aGF0IGV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkV2l0aERlcGVuZGVuY3lEZXRlY3Rpb25cbiAgICAgICAgLy8gY2FuIGJlIGluZGVwZW5kZW50IG9mIHRyeS9maW5hbGx5IGJsb2Nrcywgd2hpY2ggY29udHJpYnV0ZXMgdG8gc2F2aW5nIGFib3V0IDQwJSBvZmYgdGhlIENQVVxuICAgICAgICAvLyBvdmVyaGVhZCBvZiBjb21wdXRlZCBldmFsdWF0aW9uIChvbiBWOCBhdCBsZWFzdCkuXG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlYWRGdW5jdGlvbiA9IHN0YXRlLnJlYWRGdW5jdGlvbjtcbiAgICAgIHJldHVybiBzdGF0ZS5ldmFsdWF0b3JGdW5jdGlvblRhcmdldCA/IHJlYWRGdW5jdGlvbi5jYWxsKHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0KSA6IHJlYWRGdW5jdGlvbigpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlcGVuZGVuY3lEZXRlY3Rpb24uZW5kKCk7XG5cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIHN1YnNjcmlwdGlvbiBubyBsb25nZXIgYmVpbmcgdXNlZCwgcmVtb3ZlIGl0IGZyb20gdGhlIGFjdGl2ZSBzdWJzY3JpcHRpb25zIGxpc3QgYW5kIGRpc3Bvc2UgaXRcbiAgICAgIGlmIChkZXBlbmRlbmN5RGV0ZWN0aW9uQ29udGV4dC5kaXNwb3NhbENvdW50ICYmICFzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgIG9iamVjdEZvckVhY2goZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQuZGlzcG9zYWxDYW5kaWRhdGVzLCBjb21wdXRlZERpc3Bvc2VEZXBlbmRlbmN5Q2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5pc1N0YWxlID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICBwZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBlZWsgd29uJ3QgcmUtZXZhbHVhdGUsIGV4Y2VwdCB3aGlsZSB0aGUgY29tcHV0ZWQgaXMgc2xlZXBpbmcgb3IgdG8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlIHdoZW4gXCJkZWZlckV2YWx1YXRpb25cIiBpcyBzZXQuXG4gICAgdmFyIHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICBpZiAoKHN0YXRlLmlzU3RhbGUgJiYgIXN0YXRlLmRlcGVuZGVuY2llc0NvdW50KSB8fCAoc3RhdGUuaXNTbGVlcGluZyAmJiB0aGlzLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpKSB7XG4gICAgICB0aGlzLmV2YWx1YXRlSW1tZWRpYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXRlc3RWYWx1ZVxuICB9LFxuICBsaW1pdDogZnVuY3Rpb24gKGxpbWl0RnVuY3Rpb24pIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGxpbWl0IGZ1bmN0aW9uIHdpdGggb25lIHRoYXQgZGVsYXlzIGV2YWx1YXRpb24gYXMgd2VsbFxuICAgIHN1YnNjcmliYWJsZS5mbi5saW1pdC5jYWxsKHRoaXMsIGxpbWl0RnVuY3Rpb24pO1xuICAgIHRoaXMuX2V2YWxEZWxheWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbGltaXRCZWZvcmVDaGFuZ2UodGhpc1tjb21wdXRlZFN0YXRlXS5sYXRlc3RWYWx1ZSk7XG5cbiAgICAgIHRoaXNbY29tcHV0ZWRTdGF0ZV0uaXNTdGFsZSA9IHRydWU7IC8vIE1hcmsgYXMgZGlydHlcblxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgb2JzZXJ2YWJsZSB0byB0aGUgXCJsaW1pdFwiIGNvZGUsIHdoaWNoIHdpbGwgYWNjZXNzIGl0IHdoZW5cbiAgICAgICAgICAgIC8vIGl0J3MgdGltZSB0byBkbyB0aGUgbm90aWZpY2F0aW9uLlxuICAgICAgdGhpcy5fbGltaXRDaGFuZ2UodGhpcyk7XG4gICAgfTtcbiAgfSxcbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgaWYgKCFzdGF0ZS5pc1NsZWVwaW5nICYmIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZykge1xuICAgICAgb2JqZWN0Rm9yRWFjaChzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsIGZ1bmN0aW9uIChpZCwgZGVwZW5kZW5jeSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeS5kaXNwb3NlKSB7XG4gICAgICAgICAgZGVwZW5kZW5jeS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSBudWxsO1xuICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICBzdGF0ZS5pc1N0YWxlID0gZmFsc2U7XG4gICAgc3RhdGUuaXNTbGVlcGluZyA9IGZhbHNlO1xuICAgIHN0YXRlLnJlYWRGdW5jdGlvbiA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHB1cmVDb21wdXRlZE92ZXJyaWRlcyA9IHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uQWRkOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgYXNsZWVwLCB3YWtlIHVwIHRoZSBjb21wdXRlZCBieSBzdWJzY3JpYmluZyB0byBhbnkgZGVwZW5kZW5jaWVzLlxuICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV07XG4gICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkICYmIHN0YXRlLmlzU2xlZXBpbmcgJiYgZXZlbnQgPT0gJ2NoYW5nZScpIHtcbiAgICAgIHN0YXRlLmlzU2xlZXBpbmcgPSBmYWxzZTtcbiAgICAgIGlmIChzdGF0ZS5pc1N0YWxlIHx8IGNvbXB1dGVkT2JzZXJ2YWJsZS5oYXZlRGVwZW5kZW5jaWVzQ2hhbmdlZCgpKSB7XG4gICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyA9IG51bGw7XG4gICAgICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcbiAgICAgICAgc3RhdGUuaXNTdGFsZSA9IHRydWU7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ldmFsdWF0ZUltbWVkaWF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBwdXQgdGhlIGRlcGVuZGVuY2llcyBpbiBvcmRlclxuICAgICAgICB2YXIgZGVwZW5kZWNpZXNPcmRlciA9IFtdO1xuICAgICAgICBvYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgZGVwZW5kZWNpZXNPcmRlcltkZXBlbmRlbmN5Ll9vcmRlcl0gPSBpZDtcbiAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTmV4dCwgc3Vic2NyaWJlIHRvIGVhY2ggb25lXG4gICAgICAgIGFycmF5Rm9yRWFjaChkZXBlbmRlY2llc09yZGVyLCBmdW5jdGlvbiAoaWQsIG9yZGVyKSB7XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY29tcHV0ZWRPYnNlcnZhYmxlLnN1YnNjcmliZVRvRGVwZW5kZW5jeShkZXBlbmRlbmN5Ll90YXJnZXQpO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi5fb3JkZXIgPSBvcmRlcjtcbiAgICAgICAgICBzdWJzY3JpcHRpb24uX3ZlcnNpb24gPSBkZXBlbmRlbmN5Ll92ZXJzaW9uO1xuICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkKSB7ICAgICAvLyB0ZXN0IHNpbmNlIGV2YWx1YXRpbmcgY291bGQgdHJpZ2dlciBkaXNwb3NhbFxuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUubm90aWZ5U3Vic2NyaWJlcnMoc3RhdGUubGF0ZXN0VmFsdWUsICdhd2FrZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXNbY29tcHV0ZWRTdGF0ZV07XG4gICAgaWYgKCFzdGF0ZS5pc0Rpc3Bvc2VkICYmIGV2ZW50ID09ICdjaGFuZ2UnICYmICF0aGlzLmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudCgnY2hhbmdlJykpIHtcbiAgICAgIG9iamVjdEZvckVhY2goc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nLCBmdW5jdGlvbiAoaWQsIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kuZGlzcG9zZSkge1xuICAgICAgICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSB7XG4gICAgICAgICAgICBfdGFyZ2V0OiBkZXBlbmRlbmN5Ll90YXJnZXQsXG4gICAgICAgICAgICBfb3JkZXI6IGRlcGVuZGVuY3kuX29yZGVyLFxuICAgICAgICAgICAgX3ZlcnNpb246IGRlcGVuZGVuY3kuX3ZlcnNpb25cbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlcGVuZGVuY3kuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLmlzU2xlZXBpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh1bmRlZmluZWQsICdhc2xlZXAnKTtcbiAgICB9XG4gIH0sXG4gIGdldFZlcnNpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQmVjYXVzZSBhIHB1cmUgY29tcHV0ZWQgaXMgbm90IGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGlsZSBpdCBpcyBzbGVlcGluZywgd2UgY2FuJ3RcbiAgICAgICAgLy8gc2ltcGx5IHJldHVybiB0aGUgdmVyc2lvbiBudW1iZXIuIEluc3RlYWQsIHdlIGNoZWNrIGlmIGFueSBvZiB0aGUgZGVwZW5kZW5jaWVzIGhhdmVcbiAgICAgICAgLy8gY2hhbmdlZCBhbmQgY29uZGl0aW9uYWxseSByZS1ldmFsdWF0ZSB0aGUgY29tcHV0ZWQgb2JzZXJ2YWJsZS5cbiAgICB2YXIgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgIGlmIChzdGF0ZS5pc1NsZWVwaW5nICYmIChzdGF0ZS5pc1N0YWxlIHx8IHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmliYWJsZS5mbi5nZXRWZXJzaW9uLmNhbGwodGhpcylcbiAgfVxufTtcblxudmFyIGRlZmVyRXZhbHVhdGlvbk92ZXJyaWRlcyA9IHtcbiAgYmVmb3JlU3Vic2NyaXB0aW9uQWRkOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGZvcmNlIGEgY29tcHV0ZWQgd2l0aCBkZWZlckV2YWx1YXRpb24gdG8gZXZhbHVhdGUgd2hlbiB0aGUgZmlyc3Qgc3Vic2NyaXB0aW9uIGlzIHJlZ2lzdGVyZWQuXG4gICAgaWYgKGV2ZW50ID09ICdjaGFuZ2UnIHx8IGV2ZW50ID09ICdiZWZvcmVDaGFuZ2UnKSB7XG4gICAgICB0aGlzLnBlZWsoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIE5vdGUgdGhhdCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHRoZVxuLy8gaW5oZXJpdGFuY2UgY2hhaW4gaXMgY3JlYXRlZCBtYW51YWxseSBpbiB0aGUga28uY29tcHV0ZWQgY29uc3RydWN0b3JcbmlmIChjYW5TZXRQcm90b3R5cGUpIHtcbiAgc2V0UHJvdG90eXBlT2YoY29tcHV0ZWQuZm4sIHN1YnNjcmliYWJsZS5mbik7XG59XG5cbi8vIFNldCB0aGUgcHJvdG8gY2hhaW4gdmFsdWVzIGZvciBrby5oYXNQcm90b3R5cGVcbnZhciBwcm90b1Byb3AgPSBvYnNlcnZhYmxlLnByb3RvUHJvcGVydHk7XG5jb21wdXRlZFtwcm90b1Byb3BdID0gb2JzZXJ2YWJsZTtcbmNvbXB1dGVkLmZuW3Byb3RvUHJvcF0gPSBjb21wdXRlZDtcblxuZnVuY3Rpb24gaXNDb21wdXRlZCAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGhhc1Byb3RvdHlwZShpbnN0YW5jZSwgY29tcHV0ZWQpXG59XG5cbmZ1bmN0aW9uIGlzUHVyZUNvbXB1dGVkIChpbnN0YW5jZSkge1xuICByZXR1cm4gaGFzUHJvdG90eXBlKGluc3RhbmNlLCBjb21wdXRlZClcbiAgICAgICAgJiYgaW5zdGFuY2VbY29tcHV0ZWRTdGF0ZV0gJiYgaW5zdGFuY2VbY29tcHV0ZWRTdGF0ZV0ucHVyZVxufVxuXG5mdW5jdGlvbiBwdXJlQ29tcHV0ZWQgKGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLCBldmFsdWF0b3JGdW5jdGlvblRhcmdldCkge1xuICBpZiAodHlwZW9mIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLCBldmFsdWF0b3JGdW5jdGlvblRhcmdldCwgeydwdXJlJzogdHJ1ZX0pXG4gIH0gZWxzZSB7XG4gICAgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMgPSBleHRlbmQoe30sIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zKTsgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgcGFyYW1ldGVyIG9iamVjdFxuICAgIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLnB1cmUgPSB0cnVlO1xuICAgIHJldHVybiBjb21wdXRlZChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucywgZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3R0bGVFeHRlbmRlcih0YXJnZXQsIHRpbWVvdXQpIHtcbiAgICAvLyBUaHJvdHRsaW5nIG1lYW5zIHR3byB0aGluZ3M6XG5cbiAgICAvLyAoMSkgRm9yIGRlcGVuZGVudCBvYnNlcnZhYmxlcywgd2UgdGhyb3R0bGUgKmV2YWx1YXRpb25zKiBzbyB0aGF0LCBubyBtYXR0ZXIgaG93IGZhc3QgaXRzIGRlcGVuZGVuY2llc1xuICAgIC8vICAgICBub3RpZnkgdXBkYXRlcywgdGhlIHRhcmdldCBkb2Vzbid0IHJlLWV2YWx1YXRlIChhbmQgaGVuY2UgZG9lc24ndCBub3RpZnkpIGZhc3RlciB0aGFuIGEgY2VydGFpbiByYXRlXG4gICAgdGFyZ2V0LnRocm90dGxlRXZhbHVhdGlvbiA9IHRpbWVvdXQ7XG5cbiAgICAvLyAoMikgRm9yIHdyaXRhYmxlIHRhcmdldHMgKG9ic2VydmFibGVzLCBvciB3cml0YWJsZSBkZXBlbmRlbnQgb2JzZXJ2YWJsZXMpLCB3ZSB0aHJvdHRsZSAqd3JpdGVzKlxuICAgIC8vICAgICBzbyB0aGUgdGFyZ2V0IGNhbm5vdCBjaGFuZ2UgdmFsdWUgc3luY2hyb25vdXNseSBvciBmYXN0ZXIgdGhhbiBhIGNlcnRhaW4gcmF0ZVxuICAgIHZhciB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IG51bGw7XG4gICAgcmV0dXJuIGNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogdGFyZ2V0LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3cml0ZVRpbWVvdXRJbnN0YW5jZSk7XG4gICAgICAgICAgICB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuZXh0ZW5kZXJzLnRocm90dGxlID0gdGhyb3R0bGVFeHRlbmRlcjtcblxuLy9cbi8vIHRrby5jb21wdXRlZCAtIEV4cG9ydHNcbi8vXG4vLyBrbm9ja291dCAtPiB0a28gY2hhbmdlczpcbi8vICAgICAgRGVwcmVjYXRlcyBgZGVwZW5kZW50T2JzZXJ2YWJsZWAgKHVzZSBgY29tcHV0ZWRgKVxuLy9cblxuZXhwb3J0IHsgY29tcHV0ZWQsIGlzQ29tcHV0ZWQsIGlzUHVyZUNvbXB1dGVkLCBwdXJlQ29tcHV0ZWQsIHRocm90dGxlRXh0ZW5kZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28uY29tcHV0ZWQuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5NQTtBQUNBO0FBcU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFEQTtBQUNBO0FBNERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!*************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/ko6.js ***!
  \*************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.renderCtx = exports.componentLoaders = exports.registerComponent = exports.isPureComputed = exports.pureComputed = exports.computed = exports.observableArray = exports.observable = exports.templateParser = exports.main = undefined;\n\nvar _tkoObservable = __webpack_require__(/*! ./tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ./tko/tko.computed.js */ 3);\n\nvar _renderCtx = __webpack_require__(/*! ./renderCtx.js */ 1);\n\nvar _templateParser = __webpack_require__(/*! ./templateParser.js */ 6);\n\nvar _blockComponent = __webpack_require__(/*! ./blocks/blockComponent.js */ 5);\n\nvar _blockForeach = __webpack_require__(/*! ./blocks/blockForeach.js */ 13);\n\nvar _blockForeach2 = _interopRequireDefault(_blockForeach);\n\nvar _blockIf = __webpack_require__(/*! ./blocks/blockIf.js */ 14);\n\nvar _blockIf2 = _interopRequireDefault(_blockIf);\n\nvar _blockHtml = __webpack_require__(/*! ./blocks/blockHtml.js */ 15);\n\nvar _blockHtml2 = _interopRequireDefault(_blockHtml);\n\nvar _blockTemplate = __webpack_require__(/*! ./blocks/blockTemplate.js */ 16);\n\nvar _blockTemplate2 = _interopRequireDefault(_blockTemplate);\n\nvar _click = __webpack_require__(/*! ./bindings/click.js */ 17);\n\nvar _click2 = _interopRequireDefault(_click);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_renderCtx.renderCtx.blocks['Component'] = _blockComponent.blockComponent;\n_renderCtx.renderCtx.blocks['Foreach'] = _blockForeach2.default;\n_renderCtx.renderCtx.blocks['If'] = _blockIf2.default;\n_renderCtx.renderCtx.blocks['Html'] = _blockHtml2.default;\n_renderCtx.renderCtx.blocks['Template'] = _blockTemplate2.default;\n\n_renderCtx.renderCtx.bindingHandlers['click'] = _click2.default;\n\nfunction main(parent, cname, params) {\n\n\tvar ctx2 = new _renderCtx.Ctx(null);\n\t(0, _blockComponent.registerComponent)(cname, null, function (modelFn, view) {\n\n\t\tvar model = params || {};\n\t\tif (modelFn) {\n\t\t\tmodel = new modelFn(model);\n\t\t}\n\t\tctx2.model = model;\n\t\tctx2.root = model;\n\t\tctx2.component = model;\n\t\t(0, _renderCtx.renderCtx)(parent, view, ctx2, 0);\n\t});\n\treturn ctx2;\n};\n\nexports.main = main;\nexports.templateParser = _templateParser.templateParser;\nexports.observable = _tkoObservable.observable;\nexports.observableArray = _tkoObservable.observableArray;\nexports.computed = _tkoComputed.computed;\nexports.pureComputed = _tkoComputed.pureComputed;\nexports.isPureComputed = _tkoComputed.isPureComputed;\nexports.registerComponent = _blockComponent.registerComponent;\nexports.componentLoaders = _blockComponent.componentLoaders;\nexports.renderCtx = _renderCtx.renderCtx;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2tvNi5qcz84YmM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9ic2VydmFibGUsIG9ic2VydmFibGVBcnJheSB9IGZyb20gJy4vdGtvL3Rrby5vYnNlcnZhYmxlLmpzJztcclxuaW1wb3J0IHsgY29tcHV0ZWQsIGlzUHVyZUNvbXB1dGVkLCBwdXJlQ29tcHV0ZWQgfSAgZnJvbSAnLi90a28vdGtvLmNvbXB1dGVkLmpzJztcclxuaW1wb3J0IHsgcmVuZGVyQ3R4LCBDdHggfSAgZnJvbSAnLi9yZW5kZXJDdHguanMnO1xyXG5pbXBvcnQgeyB0ZW1wbGF0ZVBhcnNlciB9ICBmcm9tICcuL3RlbXBsYXRlUGFyc2VyLmpzJztcclxuXHJcbmltcG9ydCB7IGJsb2NrQ29tcG9uZW50LCByZWdpc3RlckNvbXBvbmVudCwgY29tcG9uZW50TG9hZGVycyB9ICBmcm9tICcuL2Jsb2Nrcy9ibG9ja0NvbXBvbmVudC5qcyc7XHJcbmltcG9ydCBibG9ja0ZvcmVhY2ggIGZyb20gJy4vYmxvY2tzL2Jsb2NrRm9yZWFjaC5qcyc7XHJcbmltcG9ydCBibG9ja0lmICBmcm9tICcuL2Jsb2Nrcy9ibG9ja0lmLmpzJztcclxuaW1wb3J0IGJsb2NrSHRtbCAgZnJvbSAnLi9ibG9ja3MvYmxvY2tIdG1sLmpzJztcclxuaW1wb3J0IGJsb2NrVGVtcGxhdGUgIGZyb20gJy4vYmxvY2tzL2Jsb2NrVGVtcGxhdGUuanMnO1xyXG5cclxuaW1wb3J0IGNsaWNrSGFuZGxlciAgZnJvbSAnLi9iaW5kaW5ncy9jbGljay5qcyc7XHJcblxyXG5yZW5kZXJDdHguYmxvY2tzWydDb21wb25lbnQnXSA9IGJsb2NrQ29tcG9uZW50O1xyXG5yZW5kZXJDdHguYmxvY2tzWydGb3JlYWNoJ10gPSBibG9ja0ZvcmVhY2g7XHJcbnJlbmRlckN0eC5ibG9ja3NbJ0lmJ10gPSBibG9ja0lmO1xyXG5yZW5kZXJDdHguYmxvY2tzWydIdG1sJ10gPSBibG9ja0h0bWw7XHJcbnJlbmRlckN0eC5ibG9ja3NbJ1RlbXBsYXRlJ10gPSBibG9ja1RlbXBsYXRlO1xyXG5cclxucmVuZGVyQ3R4LmJpbmRpbmdIYW5kbGVyc1snY2xpY2snXSA9IGNsaWNrSGFuZGxlcjtcclxuXHJcbmZ1bmN0aW9uIG1haW4ocGFyZW50LCBjbmFtZSwgcGFyYW1zKXtcclxuXHJcblx0dmFyIGN0eDIgPSBuZXcgQ3R4KG51bGwpO1xyXG5cdHJlZ2lzdGVyQ29tcG9uZW50KGNuYW1lLCBudWxsLCBmdW5jdGlvbihtb2RlbEZuLCB2aWV3KXtcclxuXHJcblx0XHRsZXQgbW9kZWwgPSBwYXJhbXMgfHwge307XHJcblx0XHRpZihtb2RlbEZuKXtcclxuXHRcdFx0bW9kZWwgPSBuZXcgbW9kZWxGbihtb2RlbCk7XHJcblx0XHR9XHJcblx0XHRjdHgyLm1vZGVsID0gbW9kZWw7XHJcblx0XHRjdHgyLnJvb3QgPSBtb2RlbDtcclxuXHRcdGN0eDIuY29tcG9uZW50ID0gbW9kZWw7XHJcblx0XHRyZW5kZXJDdHgocGFyZW50LCB2aWV3LCBjdHgyLCAwKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gY3R4MjtcclxufTtcclxuXHJcbmV4cG9ydCB7XHJcblx0bWFpbixcclxuXHR0ZW1wbGF0ZVBhcnNlcixcclxuXHRvYnNlcnZhYmxlLFx0b2JzZXJ2YWJsZUFycmF5LFxyXG5cdGNvbXB1dGVkLCBwdXJlQ29tcHV0ZWQsIGlzUHVyZUNvbXB1dGVkLFxyXG5cdHJlZ2lzdGVyQ29tcG9uZW50LCBjb21wb25lbnRMb2FkZXJzLFxyXG5cdHJlbmRlckN0eFxyXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2tvNi5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!*******************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockComponent.js ***!
  \*******************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.componentLoaders = undefined;\nexports.blockComponent = blockComponent;\nexports.registerComponent = registerComponent;\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 3);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 1);\n\nvar _templateParser = __webpack_require__(/*! ../templateParser.js */ 6);\n\nfunction blockComponent(stamp, tpl, ctx0, level) {\n\n\tif (tpl.children && tpl.children.length > 0 && tpl.attrs && tpl.attrs['_name']) {\n\n\t\tvar _name = tpl.attrs['_name'];\n\t\tvar val2 = (0, _tkoObservable.unwrap)(ctx0.expr(_name));\n\n\t\tif (val2 == ctx0.cname) return;\n\t\tctx0.cname = val2;\n\n\t\tctx0.dispose();\n\n\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\n\t\t\tvar callback = function callback(modelFn, view) {\n\t\t\t\tvar model = {};\n\t\t\t\tfor (var name in tpl.attrs) {\n\t\t\t\t\tif (tpl.attrs.hasOwnProperty(name)) model[name] = ctx0.expr(tpl.attrs[name]);\n\t\t\t\t}if (modelFn) {\n\t\t\t\t\tmodel = new modelFn(model);\n\t\t\t\t}\n\t\t\t\tctx0.model = model;\n\t\t\t\tctx0.compoent = model;\n\t\t\t\tctx0.subscribers.push(model);\n\t\t\t\t(0, _renderCtx.renderCtx)(stamp, view, ctx0, 0);\n\t\t\t};\n\n\t\t\t_renderCtx.renderCtx.registerComponent(val2, null, callback);\n\t\t});\n\t}\n}\n\nvar componentLoaders = exports.componentLoaders = [];\n\nfunction registerComponent(name, def0, callback) {\n\n\tvar def = registerComponent.componentMap[name];\n\tconsole.log('registerComponent ' + name, def0, def);\n\n\t//undefined component, undefined definition, create empty definition\n\tif (!def && !def0) {\n\t\tdef0 = { name: name, empty: true };\n\t}\n\n\t//merge definition\n\tif (def && def0) {\n\t\tfor (var _name2 in def0) {\n\t\t\tif (def0.hasOwnProperty(_name2)) def[_name2] = def0[_name2];\n\t\t}if (def.asynchModel && def.model) delete def.asynchModel;\n\t\tif (def.asynchTemplate && def.template) delete def.asynchTemplate;\n\t}\n\n\t//create new definition\n\tif (!def && def0) {\n\t\tdef = def0;\n\t\tdef.name = name;\n\t\tregisterComponent.componentMap[name] = def;\n\t}\n\n\t//error, no continue\n\tif (def.error) {\n\t\tconsole.log('registerComponent ' + name + ' exists error ' + def.error);\n\t\treturn;\n\t}\n\n\t//definition was changed - run all loaders\n\tif (def0) {\n\t\tfor (var i = 0, max = componentLoaders.length; i < max; i++) {\n\t\t\tcomponentLoaders[i](def);\n\t\t}\n\t}\n\n\t//check if is running loading model or template\n\tif (def.asynchModel || def.asynchTemplate) {\n\t\tif (callback) {\n\t\t\tconsole.log('registerComponent ' + name + ' loading', def.asynchModel, def.asynchTemplate);\n\t\t\tif (!def.waitingCallbacks) def.waitingCallbacks = [];\n\t\t\tdef.waitingCallbacks.push(callback);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (def.template) {\n\n\t\t//compile template\n\t\tif (typeof def.template == 'string') {\n\t\t\tdef.template = (0, _templateParser.templateParser)(def.template);\n\t\t}\n\n\t\t//render waiting callbacks\n\t\tif (def.waitingCallbacks) {\n\t\t\tfor (var _i = 0, _max = def.waitingCallbacks.length; _i < _max; _i++) {\n\t\t\t\tdef.waitingCallbacks[_i](def.model, def.template);\n\t\t\t}delete def.waitingCallbacks;\n\t\t}\n\n\t\t//render callback\n\t\tif (callback) callback(def.model, def.template);\n\t\treturn;\n\t}\n\n\t//no loading, no template, create error\n\tdef.error = 'undefined template';\n\tconsole.log('registerComponent ' + name + ' error ' + def.error);\n}\nregisterComponent.componentMap = {};\n\nfunction templateAjaxLoader(def) {\n\t//no template, no loading, and defined templateUrl\n\tif (!def.template && !def.asynchTemplate && def.templateUrl) {\n\n\t\t//make note but template is loading with templateAjaxLoader\n\t\tdef.asynchTemplate = 'templateAjaxLoader ' + def.templateUrl;\n\n\t\t//send ajax GET request\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open('GET', def.templateUrl);\n\t\txhr.onload = function () {\n\t\t\tvar def2 = xhr.status == 200 ? { template: xhr.responseText } : { error: 'templateAjaxLoader state=' + xhr.state };\n\t\t\tregisterComponent(def.name, def2);\n\t\t};\n\t\txhr.send();\n\t}\n}\ncomponentLoaders.push(templateAjaxLoader);\n\nfunction jsloader(def) {\n\tif (!def.model && !def.asynchModel && def.jsmodule) {\n\n\t\tdef.asynchModel = \"jsloader \" + def.jsmodule;\n\t\tvar script = document.createElement('script');\n\t\tscript.src = def.jsmodule;\n\t\tscript.type = \"text/javascript\";\n\t\tdocument.head.appendChild(script);\n\t}\n}\ncomponentLoaders.push(jsloader);\n\nfunction es6loader(def) {\n\tif (!def.model && !def.asynchModel && def.es6module) {\n\n\t\tdef.asynchModel = \"es6loader \" + def.es6module;\n\t\tvar script = document.createElement('script');\n\t\tscript.src = def.es6module;\n\t\tscript.type = \"module\";\n\t\tdocument.head.appendChild(script);\n\t}\n}\ncomponentLoaders.push(es6loader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2Jsb2Nrcy9ibG9ja0NvbXBvbmVudC5qcz9mMjRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVud3JhcCwgZGVwZW5kZW5jeURldGVjdGlvbiB9ICBmcm9tICcuLi90a28vdGtvLm9ic2VydmFibGUuanMnO1xyXG5pbXBvcnQgeyBjb21wdXRlZCB9ICBmcm9tICcuLi90a28vdGtvLmNvbXB1dGVkLmpzJztcclxuaW1wb3J0IHsgcmVuZGVyQ3R4IH0gIGZyb20gJy4uL3JlbmRlckN0eC5qcyc7XHJcbmltcG9ydCB7IHRlbXBsYXRlUGFyc2VyIH0gIGZyb20gJy4uL3RlbXBsYXRlUGFyc2VyLmpzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBibG9ja0NvbXBvbmVudChzdGFtcCwgdHBsLCBjdHgwLCBsZXZlbCl7XHJcblxyXG5cdGlmKHRwbC5jaGlsZHJlbiAmJiB0cGwuY2hpbGRyZW4ubGVuZ3RoPjAgJiYgdHBsLmF0dHJzICYmIHRwbC5hdHRyc1snX25hbWUnXSl7XHJcblx0XHRcclxuXHRcdHZhciBfbmFtZSA9IHRwbC5hdHRyc1snX25hbWUnXTtcclxuXHRcdHZhciB2YWwyID0gdW53cmFwKGN0eDAuZXhwcihfbmFtZSkpO1xyXG5cclxuXHRcdGlmKHZhbDI9PWN0eDAuY25hbWUpIHJldHVybjtcclxuXHRcdGN0eDAuY25hbWUgPSB2YWwyO1xyXG5cclxuXHRcdGN0eDAuZGlzcG9zZSgpO1xyXG5cclxuXHRcdGRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IGZ1bmN0aW9uKG1vZGVsRm4sIHZpZXcpIHtcclxuXHRcdFx0XHRsZXQgbW9kZWwgPSB7fTtcclxuXHRcdFx0XHRmb3IgKGxldCBuYW1lIGluIHRwbC5hdHRycykgaWYgKHRwbC5hdHRycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgbW9kZWxbbmFtZV0gPSBjdHgwLmV4cHIodHBsLmF0dHJzW25hbWVdKTtcclxuXHRcdFx0XHRpZihtb2RlbEZuKXtcclxuXHRcdFx0XHRcdG1vZGVsID0gbmV3IG1vZGVsRm4obW9kZWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjdHgwLm1vZGVsID0gbW9kZWw7XHJcblx0XHRcdFx0Y3R4MC5jb21wb2VudCA9IG1vZGVsO1xyXG5cdFx0XHRcdGN0eDAuc3Vic2NyaWJlcnMucHVzaChtb2RlbCk7XHJcblx0XHRcdFx0cmVuZGVyQ3R4KHN0YW1wLCB2aWV3LCBjdHgwLCAwKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJlbmRlckN0eC5yZWdpc3RlckNvbXBvbmVudCh2YWwyLCBudWxsLCBjYWxsYmFjayk7XHJcblxyXG5cdFx0fSk7XHJcblxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgdmFyIGNvbXBvbmVudExvYWRlcnMgPSBbXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudChuYW1lLCBkZWYwLCBjYWxsYmFjayl7XHJcblxyXG5cdGxldCBkZWYgPSByZWdpc3RlckNvbXBvbmVudC5jb21wb25lbnRNYXBbbmFtZV07XHJcblx0Y29uc29sZS5sb2coJ3JlZ2lzdGVyQ29tcG9uZW50ICcgKyBuYW1lLCBkZWYwLCBkZWYpO1xyXG5cdFxyXG5cdC8vdW5kZWZpbmVkIGNvbXBvbmVudCwgdW5kZWZpbmVkIGRlZmluaXRpb24sIGNyZWF0ZSBlbXB0eSBkZWZpbml0aW9uXHJcblx0aWYoIWRlZiAmJiAhZGVmMCl7XHJcblx0XHRkZWYwID0geyBuYW1lOm5hbWUsIGVtcHR5OnRydWUgfTtcclxuXHR9XHJcblxyXG5cdC8vbWVyZ2UgZGVmaW5pdGlvblxyXG5cdGlmKGRlZiAmJiBkZWYwKXtcclxuXHRcdGZvciAobGV0IG5hbWUgaW4gZGVmMCkgaWYgKGRlZjAuaGFzT3duUHJvcGVydHkobmFtZSkpIGRlZltuYW1lXSA9IGRlZjBbbmFtZV07XHJcblx0XHRpZihkZWYuYXN5bmNoTW9kZWwgJiYgZGVmLm1vZGVsKSBkZWxldGUgZGVmLmFzeW5jaE1vZGVsO1xyXG5cdFx0aWYoZGVmLmFzeW5jaFRlbXBsYXRlICYmIGRlZi50ZW1wbGF0ZSkgZGVsZXRlIGRlZi5hc3luY2hUZW1wbGF0ZTtcclxuXHR9XHJcblxyXG5cdC8vY3JlYXRlIG5ldyBkZWZpbml0aW9uXHJcblx0aWYoIWRlZiAmJiBkZWYwKXtcclxuXHRcdGRlZiA9IGRlZjA7XHJcblx0XHRkZWYubmFtZSA9IG5hbWU7XHJcblx0XHRyZWdpc3RlckNvbXBvbmVudC5jb21wb25lbnRNYXBbbmFtZV0gPSBkZWY7XHJcblx0fVxyXG5cclxuXHQvL2Vycm9yLCBubyBjb250aW51ZVxyXG5cdGlmKGRlZi5lcnJvcil7XHJcblx0XHRjb25zb2xlLmxvZygncmVnaXN0ZXJDb21wb25lbnQgJyArIG5hbWUgKyAnIGV4aXN0cyBlcnJvciAnICsgZGVmLmVycm9yKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vZGVmaW5pdGlvbiB3YXMgY2hhbmdlZCAtIHJ1biBhbGwgbG9hZGVyc1xyXG5cdGlmKGRlZjApe1xyXG5cdFx0Zm9yKGxldCBpPTAsIG1heD1jb21wb25lbnRMb2FkZXJzLmxlbmd0aDsgaTxtYXg7IGkrKykgY29tcG9uZW50TG9hZGVyc1tpXShkZWYpO1xyXG5cdH1cclxuXHJcblx0Ly9jaGVjayBpZiBpcyBydW5uaW5nIGxvYWRpbmcgbW9kZWwgb3IgdGVtcGxhdGVcclxuXHRpZihkZWYuYXN5bmNoTW9kZWwgfHwgZGVmLmFzeW5jaFRlbXBsYXRlKSB7XHJcblx0XHRpZihjYWxsYmFjayl7XHJcblx0XHRcdGNvbnNvbGUubG9nKCdyZWdpc3RlckNvbXBvbmVudCAnICsgbmFtZSsnIGxvYWRpbmcnLCBkZWYuYXN5bmNoTW9kZWwsIGRlZi5hc3luY2hUZW1wbGF0ZSk7XHJcblx0XHRcdGlmKCFkZWYud2FpdGluZ0NhbGxiYWNrcykgZGVmLndhaXRpbmdDYWxsYmFja3MgPSBbXTtcclxuXHRcdFx0ZGVmLndhaXRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZihkZWYudGVtcGxhdGUpe1xyXG5cdFx0XHJcblx0XHQvL2NvbXBpbGUgdGVtcGxhdGVcclxuXHRcdGlmKHR5cGVvZiBkZWYudGVtcGxhdGUgPT0gJ3N0cmluZycpe1xyXG5cdFx0XHRkZWYudGVtcGxhdGUgPSB0ZW1wbGF0ZVBhcnNlcihkZWYudGVtcGxhdGUpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvL3JlbmRlciB3YWl0aW5nIGNhbGxiYWNrc1xyXG5cdFx0aWYoZGVmLndhaXRpbmdDYWxsYmFja3MpIHtcclxuXHRcdFx0Zm9yKGxldCBpPTAsIG1heD1kZWYud2FpdGluZ0NhbGxiYWNrcy5sZW5ndGg7IGk8bWF4OyBpKyspIGRlZi53YWl0aW5nQ2FsbGJhY2tzW2ldKGRlZi5tb2RlbCwgZGVmLnRlbXBsYXRlKTtcclxuXHRcdFx0ZGVsZXRlIGRlZi53YWl0aW5nQ2FsbGJhY2tzO1xyXG5cdFx0fSBcclxuXHJcblx0XHQvL3JlbmRlciBjYWxsYmFja1xyXG5cdFx0aWYoY2FsbGJhY2spIGNhbGxiYWNrKGRlZi5tb2RlbCwgZGVmLnRlbXBsYXRlKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vbm8gbG9hZGluZywgbm8gdGVtcGxhdGUsIGNyZWF0ZSBlcnJvclxyXG5cdGRlZi5lcnJvciA9ICd1bmRlZmluZWQgdGVtcGxhdGUnO1xyXG5cdGNvbnNvbGUubG9nKCdyZWdpc3RlckNvbXBvbmVudCAnICsgbmFtZSArICcgZXJyb3IgJyArIGRlZi5lcnJvcik7XHJcbn1cclxucmVnaXN0ZXJDb21wb25lbnQuY29tcG9uZW50TWFwID0ge307XHJcblxyXG5mdW5jdGlvbiB0ZW1wbGF0ZUFqYXhMb2FkZXIoZGVmKXtcclxuXHQvL25vIHRlbXBsYXRlLCBubyBsb2FkaW5nLCBhbmQgZGVmaW5lZCB0ZW1wbGF0ZVVybFxyXG5cdGlmKCFkZWYudGVtcGxhdGUgJiYgIWRlZi5hc3luY2hUZW1wbGF0ZSAmJiBkZWYudGVtcGxhdGVVcmwpe1xyXG5cclxuXHRcdC8vbWFrZSBub3RlIGJ1dCB0ZW1wbGF0ZSBpcyBsb2FkaW5nIHdpdGggdGVtcGxhdGVBamF4TG9hZGVyXHJcblx0XHRkZWYuYXN5bmNoVGVtcGxhdGUgPSAndGVtcGxhdGVBamF4TG9hZGVyICcgKyBkZWYudGVtcGxhdGVVcmw7XHJcblxyXG5cdFx0Ly9zZW5kIGFqYXggR0VUIHJlcXVlc3RcclxuXHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRcdHhoci5vcGVuKCdHRVQnLCBkZWYudGVtcGxhdGVVcmwpO1xyXG5cdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRcdGxldCBkZWYyID0gKHhoci5zdGF0dXM9PTIwMCkgPyB7IHRlbXBsYXRlIDogeGhyLnJlc3BvbnNlVGV4dCB9IDogeyBlcnJvciA6ICd0ZW1wbGF0ZUFqYXhMb2FkZXIgc3RhdGU9JyArIHhoci5zdGF0ZSB9O1xyXG5cdFx0XHRyZWdpc3RlckNvbXBvbmVudChkZWYubmFtZSwgZGVmMik7XHJcblx0XHR9O1xyXG5cdFx0eGhyLnNlbmQoKTtcclxuXHR9XHJcbn1cclxuY29tcG9uZW50TG9hZGVycy5wdXNoKHRlbXBsYXRlQWpheExvYWRlcik7XHJcblxyXG5mdW5jdGlvbiBqc2xvYWRlcihkZWYpe1xyXG5cdGlmICghZGVmLm1vZGVsICYmICFkZWYuYXN5bmNoTW9kZWwgJiYgZGVmLmpzbW9kdWxlKSB7XHJcblxyXG5cdFx0ZGVmLmFzeW5jaE1vZGVsID0gXCJqc2xvYWRlciBcIitkZWYuanNtb2R1bGU7XHJcblx0XHRjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuXHRcdHNjcmlwdC5zcmMgPSBkZWYuanNtb2R1bGU7XHJcblx0XHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcblx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcblx0fVxyXG59XHJcbmNvbXBvbmVudExvYWRlcnMucHVzaChqc2xvYWRlcik7XHJcblxyXG5mdW5jdGlvbiBlczZsb2FkZXIoZGVmKXtcclxuXHRpZiAoIWRlZi5tb2RlbCAmJiAhZGVmLmFzeW5jaE1vZGVsICYmIGRlZi5lczZtb2R1bGUpIHtcclxuXHJcblx0XHRkZWYuYXN5bmNoTW9kZWwgPSBcImVzNmxvYWRlciBcIitkZWYuZXM2bW9kdWxlO1xyXG5cdFx0Y29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcblx0XHRzY3JpcHQuc3JjID0gZGVmLmVzNm1vZHVsZTtcclxuXHRcdHNjcmlwdC50eXBlID0gXCJtb2R1bGVcIjtcclxuXHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuXHR9XHJcbn1cclxuY29tcG9uZW50TG9hZGVycy5wdXNoKGVzNmxvYWRlcik7XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tDb21wb25lbnQuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUtBO0FBcUNBO0FBQ0E7QUEzQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/templateParser.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDefaults = undefined;\nexports.templateParser = templateParser;\n\nvar _lexer = __webpack_require__(/*! ./himalaya/lexer.js */ 10);\n\nvar _lexer2 = _interopRequireDefault(_lexer);\n\nvar _parser = __webpack_require__(/*! ./himalaya/parser.js */ 11);\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _tags = __webpack_require__(/*! ./himalaya/tags.js */ 12);\n\nvar _compat = __webpack_require__(/*! ./himalaya/compat.js */ 7);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar parseDefaults = exports.parseDefaults = {\n  voidTags: _tags.voidTags,\n  closingTags: _tags.closingTags,\n  childlessTags: _tags.childlessTags,\n  closingTagAncestorBreakers: _tags.closingTagAncestorBreakers\n};\n\nfunction templateParser(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  var startTime = performance.now();\n\n  var tokens = (0, _lexer2.default)(str, options);\n  var nodes = (0, _parser2.default)(tokens, options);\n  var map = format(nodes, options);\n\n  var finishTime = performance.now();\n  console.log('parserko6', finishTime - startTime);\n  return map;\n}\n\nfunction format(nodes) {\n  var arr = [];\n  nodes.forEach(function (node) {\n    var type = node.type;\n    if (type === 'element') {\n      var tag = node.tagName;\n      var attrs = formatAttributes(node.attributes);\n      var children = format(node.children);\n\n      var obj = { tag: tag };\n      if (attrs && Object.keys(attrs).length > 0) {\n        obj.attrs = attrs;\n      }\n      if (children && children.length > 0) {\n        obj.children = children;\n      }\n      arr.push(obj);\n    }\n    if (!isEmptyOrSpaces(node.content)) {\n      arr.push(parseJsExression(node.content));\n    }\n  });\n  return arr;\n}\n\nfunction formatAttributes(attributes) {\n  var attrs = {};\n  attributes.forEach(function (attribute) {\n    var parts = splitHead(attribute.trim(), '=');\n    var key = parts[0];\n    var value = typeof parts[1] === 'string' ? unquote(parts[1]) : null;\n    attrs[key] = parseJsExression(value);\n  });\n  return attrs;\n}\n\nfunction splitHead(str, sep) {\n  var idx = str.indexOf(sep);\n  if (idx === -1) return [str];\n  return [str.slice(0, idx), str.slice(idx + sep.length)];\n}\n\nfunction unquote(str) {\n  var car = str.charAt(0);\n  var end = str.length - 1;\n  var isQuoteStart = car === '\"' || car === \"'\";\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end);\n  }\n  return str;\n}\n\nfunction parseJsExression(s) {\n  if (s && (0, _compat.startsWith)(s, '{') && (0, _compat.endsWith)(s, '}')) {\n    s = s.slice(1, s.length - 1);\n    return new Function('m', 'ctx', 'return ' + s);\n  }\n  return s;\n}\n\nfunction isEmptyOrSpaces(str) {\n  return !str || !str.match || str.match(/^\\s*$/) !== null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3RlbXBsYXRlUGFyc2VyLmpzPzlmMGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxleGVyIGZyb20gJy4vaGltYWxheWEvbGV4ZXIuanMnXHJcbmltcG9ydCBwYXJzZXIgZnJvbSAnLi9oaW1hbGF5YS9wYXJzZXIuanMnXHJcbmltcG9ydCB7XHJcbiAgdm9pZFRhZ3MsXHJcbiAgY2xvc2luZ1RhZ3MsXHJcbiAgY2hpbGRsZXNzVGFncyxcclxuICBjbG9zaW5nVGFnQW5jZXN0b3JCcmVha2Vyc1xyXG59IGZyb20gJy4vaGltYWxheWEvdGFncy5qcydcclxuXHJcbmltcG9ydCB7XHJcbiAgc3RhcnRzV2l0aCxcclxuICBlbmRzV2l0aFxyXG59IGZyb20gJy4vaGltYWxheWEvY29tcGF0LmpzJ1xyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZURlZmF1bHRzID0ge1xyXG4gIHZvaWRUYWdzLFxyXG4gIGNsb3NpbmdUYWdzLFxyXG4gIGNoaWxkbGVzc1RhZ3MsXHJcbiAgY2xvc2luZ1RhZ0FuY2VzdG9yQnJlYWtlcnNcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlUGFyc2VyIChzdHIsIG9wdGlvbnMgPSBwYXJzZURlZmF1bHRzKSB7XHJcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG4gIGNvbnN0IHRva2VucyA9IGxleGVyKHN0ciwgb3B0aW9ucylcclxuICBjb25zdCBub2RlcyA9IHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpXHJcbiAgY29uc3QgbWFwID0gZm9ybWF0KG5vZGVzLCBvcHRpb25zKVxyXG5cclxuICBjb25zdCBmaW5pc2hUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgY29uc29sZS5sb2coJ3BhcnNlcmtvNicsIChmaW5pc2hUaW1lLXN0YXJ0VGltZSkpO1xyXG4gIHJldHVybiBtYXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdCAobm9kZXMpIHtcclxuICB2YXIgYXJyID0gW107XHJcbiAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgIGNvbnN0IHR5cGUgPSBub2RlLnR5cGVcclxuICAgIGlmICh0eXBlID09PSAnZWxlbWVudCcpIHtcclxuICAgICAgY29uc3QgdGFnID0gbm9kZS50YWdOYW1lO1xyXG4gICAgICBjb25zdCBhdHRycyA9IGZvcm1hdEF0dHJpYnV0ZXMobm9kZS5hdHRyaWJ1dGVzKVxyXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGZvcm1hdChub2RlLmNoaWxkcmVuKVxyXG5cclxuICAgICAgY29uc3Qgb2JqID0ge3RhZ31cclxuICAgICAgaWYoYXR0cnMgJiYgT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aD4wKXtcclxuICAgICAgICBvYmouYXR0cnMgPSBhdHRycztcclxuICAgICAgfVxyXG4gICAgICBpZihjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg+MCl7XHJcbiAgICAgICAgb2JqLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgIH1cclxuICAgICAgYXJyLnB1c2gob2JqKVxyXG4gICAgfVxyXG4gICAgaWYoIWlzRW1wdHlPclNwYWNlcyhub2RlLmNvbnRlbnQpKXtcclxuICAgICAgYXJyLnB1c2gocGFyc2VKc0V4cmVzc2lvbihub2RlLmNvbnRlbnQpKVxyXG4gICAgfVxyXG4gIH0pXHJcbiAgcmV0dXJuIGFycjtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0QXR0cmlidXRlcyAoYXR0cmlidXRlcykge1xyXG4gIHZhciBhdHRycyA9IHt9XHJcbiAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IHNwbGl0SGVhZChhdHRyaWJ1dGUudHJpbSgpLCAnPScpXHJcbiAgICBjb25zdCBrZXkgPSBwYXJ0c1swXVxyXG4gICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgcGFydHNbMV0gPT09ICdzdHJpbmcnXHJcbiAgICAgID8gdW5xdW90ZShwYXJ0c1sxXSlcclxuICAgICAgOiBudWxsXHJcbiAgICBhdHRyc1trZXldID0gcGFyc2VKc0V4cmVzc2lvbih2YWx1ZSk7XHJcbiAgfSlcclxuICByZXR1cm4gYXR0cnNcclxufSBcclxuXHJcbmZ1bmN0aW9uIHNwbGl0SGVhZCAoc3RyLCBzZXApIHtcclxuICBjb25zdCBpZHggPSBzdHIuaW5kZXhPZihzZXApXHJcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBbc3RyXVxyXG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGlkeCksIHN0ci5zbGljZShpZHggKyBzZXAubGVuZ3RoKV1cclxufVxyXG5cclxuZnVuY3Rpb24gdW5xdW90ZSAoc3RyKSB7XHJcbiAgY29uc3QgY2FyID0gc3RyLmNoYXJBdCgwKVxyXG4gIGNvbnN0IGVuZCA9IHN0ci5sZW5ndGggLSAxXHJcbiAgY29uc3QgaXNRdW90ZVN0YXJ0ID0gY2FyID09PSAnXCInIHx8IGNhciA9PT0gXCInXCJcclxuICBpZiAoaXNRdW90ZVN0YXJ0ICYmIGNhciA9PT0gc3RyLmNoYXJBdChlbmQpKSB7XHJcbiAgICByZXR1cm4gc3RyLnNsaWNlKDEsIGVuZClcclxuICB9XHJcbiAgcmV0dXJuIHN0clxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUpzRXhyZXNzaW9uKHMpe1xyXG4gICAgICBpZihzICYmIHN0YXJ0c1dpdGgocywgJ3snKSAmJiBlbmRzV2l0aChzLCAnfScpKXtcclxuICAgICAgICBzID0gcy5zbGljZSgxLCBzLmxlbmd0aC0xKTtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdtJywgJ2N0eCcsICdyZXR1cm4gJytzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNFbXB0eU9yU3BhY2VzKHN0cil7XHJcbiAgICByZXR1cm4gIXN0ciB8fCAhc3RyLm1hdGNoIHx8IHN0ci5tYXRjaCgvXlxccyokLykgIT09IG51bGw7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy90ZW1wbGF0ZVBhcnNlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBc0JBO0FBQ0E7QUF2QkE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQU1BO0FBQ0E7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!*************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/compat.js ***!
  \*************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.stringIncludes = stringIncludes;\nexports.isRealNaN = isRealNaN;\nexports.arrayIncludes = arrayIncludes;\n/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\n\nfunction startsWith(str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString;\n}\n\nfunction endsWith(str, searchString, position) {\n  var index = (position || str.length) - searchString.length;\n  var lastIndex = str.lastIndexOf(searchString, index);\n  return lastIndex !== -1 && lastIndex === index;\n}\n\nfunction stringIncludes(str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1;\n}\n\nfunction isRealNaN(x) {\n  return typeof x === 'number' && isNaN(x);\n}\n\nfunction arrayIncludes(array, searchElement, position) {\n  var len = array.length;\n  if (len === 0) return false;\n\n  var lookupIndex = position | 0;\n  var isNaNElement = isRealNaN(searchElement);\n  var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;\n  while (searchIndex < len) {\n    var element = array[searchIndex++];\n    if (element === searchElement) return true;\n    if (isNaNElement && isRealNaN(element)) return true;\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2hpbWFsYXlhL2NvbXBhdC5qcz85Y2QzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZSBiYWJlbC1wb2x5ZmlsbCBpbiBvdXIgcHJvamVjdC5cbiAgICAtIExpYnJhcnkgYXV0aG9ycyBzaG91bGQgYmUgdXNpbmcgYmFiZWwtcnVudGltZSBmb3Igbm9uLWdsb2JhbCBwb2x5ZmlsbGluZ1xuICAgIC0gQWRkaW5nIGJhYmVsLXBvbHlmaWxsLy1ydW50aW1lIGluY3JlYXNlcyBidW5kbGUgc2l6ZSBzaWduaWZpY2FudGx5XG5cbiAgV2Ugd2lsbCBpbmNsdWRlIG91ciBwb2x5ZmlsbCBpbnN0YW5jZSBtZXRob2RzIGFzIHJlZ3VsYXIgZnVuY3Rpb25zLlxuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0c1dpdGggKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICByZXR1cm4gc3RyLnN1YnN0cihwb3NpdGlvbiB8fCAwLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aCAoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGluZGV4ID0gKHBvc2l0aW9uIHx8IHN0ci5sZW5ndGgpIC0gc2VhcmNoU3RyaW5nLmxlbmd0aFxuICBjb25zdCBsYXN0SW5kZXggPSBzdHIubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCBpbmRleClcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBpbmRleFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nSW5jbHVkZXMgKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiB8fCAwKSAhPT0gLTFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhbE5hTiAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzTmFOKHgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUluY2x1ZGVzIChhcnJheSwgc2VhcmNoRWxlbWVudCwgcG9zaXRpb24pIHtcbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGxvb2t1cEluZGV4ID0gcG9zaXRpb24gfCAwXG4gIGNvbnN0IGlzTmFORWxlbWVudCA9IGlzUmVhbE5hTihzZWFyY2hFbGVtZW50KVxuICBsZXQgc2VhcmNoSW5kZXggPSBsb29rdXBJbmRleCA+PSAwID8gbG9va3VwSW5kZXggOiBsZW4gKyBsb29rdXBJbmRleFxuICB3aGlsZSAoc2VhcmNoSW5kZXggPCBsZW4pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbc2VhcmNoSW5kZXgrK11cbiAgICBpZiAoZWxlbWVudCA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIHRydWVcbiAgICBpZiAoaXNOYU5FbGVtZW50ICYmIGlzUmVhbE5hTihlbGVtZW50KSkgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvaGltYWxheWEvY29tcGF0LmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQVFBO0FBSUE7QUFNQTtBQUlBO0FBSUE7QUExQkE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */,
/* 9 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/lexer.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = lexer;\nexports.lex = lex;\nexports.findTextEnd = findTextEnd;\nexports.lexText = lexText;\nexports.lexComment = lexComment;\nexports.lexTag = lexTag;\nexports.isWhitespaceChar = isWhitespaceChar;\nexports.lexTagName = lexTagName;\nexports.lexTagAttributes = lexTagAttributes;\nexports.lexSkipTag = lexSkipTag;\n\nvar _compat = __webpack_require__(/*! ./compat.js */ 7);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction lexer(str, options) {\n  var state = { str: str, options: options, cursor: 0, tokens: [] };\n  lex(state);\n  return state.tokens;\n}\n\nfunction lex(state) {\n  var str = state.str;\n\n  var len = str.length;\n  while (state.cursor < len) {\n    var start = state.cursor;\n    lexText(state);\n    if (state.cursor === start) {\n      var isComment = (0, _compat.startsWith)(str, '!--', state.cursor + 1);\n      if (isComment) {\n        lexComment(state);\n      } else {\n        var tagName = lexTag(state);\n        var safeTag = tagName.toLowerCase();\n        var childlessTags = state.options.childlessTags;\n\n        if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state);\n        }\n      }\n    }\n  }\n}\n\nvar alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n  while (true) {\n    var textEnd = str.indexOf('<', index);\n    if (textEnd === -1) {\n      return textEnd;\n    }\n    var char = str.charAt(textEnd + 1);\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd;\n    }\n    index = textEnd + 1;\n  }\n}\n\nfunction lexText(state) {\n  var type = 'text';\n  var str = state.str,\n      cursor = state.cursor;\n\n  var textEnd = findTextEnd(str, cursor);\n  if (textEnd === -1) {\n    // there is only text left\n    var _content = str.slice(cursor);\n    state.cursor = str.length;\n    state.tokens.push({ type: type, content: _content });\n    return;\n  }\n\n  if (textEnd === cursor) return;\n\n  var content = str.slice(cursor, textEnd);\n  state.cursor = textEnd;\n  state.tokens.push({ type: type, content: content });\n}\n\nfunction lexComment(state) {\n  state.cursor += 4; // \"<!--\".length\n  var str = state.str,\n      cursor = state.cursor;\n\n  var commentEnd = str.indexOf('-->', cursor);\n  var type = 'comment';\n  if (commentEnd === -1) {\n    // there is only the comment left\n    var _content2 = str.slice(cursor);\n    state.cursor = str.length;\n    state.tokens.push({ type: type, content: _content2 });\n    return;\n  }\n\n  var content = str.slice(cursor, commentEnd);\n  state.cursor = commentEnd + 3; // \"-->\".length\n  state.tokens.push({ type: type, content: content });\n}\n\nfunction lexTag(state) {\n  var str = state.str;\n\n  {\n    var secondChar = str.charAt(state.cursor + 1);\n    var close = secondChar === '/';\n    state.tokens.push({ type: 'tag-start', close: close });\n    state.cursor += close ? 2 : 1;\n  }\n  var tagName = lexTagName(state);\n  lexTagAttributes(state);\n  {\n    var firstChar = str.charAt(state.cursor);\n    var _close = firstChar === '/';\n    state.tokens.push({ type: 'tag-end', close: _close });\n    state.cursor += _close ? 2 : 1;\n  }\n  return tagName;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nvar whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n  return whitespace.test(char);\n}\n\nfunction lexTagName(state) {\n  var str = state.str,\n      cursor = state.cursor;\n\n  var len = str.length;\n  var start = cursor;\n  while (start < len) {\n    var char = str.charAt(start);\n    var isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n    if (isTagChar) break;\n    start++;\n  }\n\n  var end = start + 1;\n  while (end < len) {\n    var _char = str.charAt(end);\n    var _isTagChar = !(isWhitespaceChar(_char) || _char === '/' || _char === '>');\n    if (!_isTagChar) break;\n    end++;\n  }\n\n  state.cursor = end;\n  var tagName = str.slice(start, end);\n  state.tokens.push({ type: 'tag', content: tagName });\n  return tagName;\n}\n\nfunction lexTagAttributes(state) {\n  var str = state.str,\n      tokens = state.tokens;\n\n  var cursor = state.cursor;\n  var quote = null; // null, single-, or double-quote\n  var wordBegin = cursor; // index of word start\n  var words = []; // \"key\", \"key=value\", \"key='value'\", etc\n  var len = str.length;\n  while (cursor < len) {\n    var char = str.charAt(cursor);\n    if (quote) {\n      var isQuoteEnd = char === quote;\n      if (isQuoteEnd) {\n        quote = null;\n      }\n      cursor++;\n      continue;\n    }\n\n    var isTagEnd = char === '/' || char === '>';\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      break;\n    }\n\n    var isWordEnd = isWhitespaceChar(char);\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      wordBegin = cursor + 1;\n      cursor++;\n      continue;\n    }\n\n    var isQuoteStart = char === '\\'' || char === '\"';\n    if (isQuoteStart) {\n      quote = char;\n      cursor++;\n      continue;\n    }\n\n    cursor++;\n  }\n  state.cursor = cursor;\n\n  var wLen = words.length;\n  var type = 'attribute';\n  for (var i = 0; i < wLen; i++) {\n    var word = words[i];\n    var isNotPair = word.indexOf('=') === -1;\n    if (isNotPair) {\n      var secondWord = words[i + 1];\n      if (secondWord && (0, _compat.startsWith)(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          var newWord = word + secondWord;\n          tokens.push({ type: type, content: newWord });\n          i += 1;\n          continue;\n        }\n        var thirdWord = words[i + 2];\n        i += 1;\n        if (thirdWord) {\n          var _newWord = word + '=' + thirdWord;\n          tokens.push({ type: type, content: _newWord });\n          i += 1;\n          continue;\n        }\n      }\n    }\n    if ((0, _compat.endsWith)(word, '=')) {\n      var _secondWord = words[i + 1];\n      if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, '=')) {\n        var _newWord3 = word + _secondWord;\n        tokens.push({ type: type, content: _newWord3 });\n        i += 1;\n        continue;\n      }\n\n      var _newWord2 = word.slice(0, -1);\n      tokens.push({ type: type, content: _newWord2 });\n      continue;\n    }\n\n    tokens.push({ type: type, content: word });\n  }\n}\n\nfunction lexSkipTag(tagName, state) {\n  var str = state.str,\n      cursor = state.cursor,\n      tokens = state.tokens;\n\n  var len = str.length;\n  var index = cursor;\n  while (index < len) {\n    var nextTag = str.indexOf('</', index);\n    if (nextTag === -1) {\n      lexText(state);\n      break;\n    }\n\n    var tagState = { str: str, cursor: nextTag + 2, tokens: [] };\n    var name = lexTagName(tagState);\n    var safeTagName = tagName.toLowerCase();\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.cursor;\n      continue;\n    }\n\n    var content = str.slice(cursor, nextTag);\n    tokens.push({ type: 'text', content: content });\n    var openTag = { type: 'tag-start', close: true };\n    var closeTag = { type: 'tag-end', close: false };\n    lexTagAttributes(tagState);\n    tokens.push.apply(tokens, [openTag].concat(_toConsumableArray(tagState.tokens), [closeTag]));\n    state.cursor = tagState.cursor + 1;\n    break;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS9sZXhlci5qcz84NGM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHN0YXJ0c1dpdGgsXG4gIGVuZHNXaXRoLFxuICBzdHJpbmdJbmNsdWRlcyxcbiAgYXJyYXlJbmNsdWRlc1xufSBmcm9tICcuL2NvbXBhdC5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGV4ZXIgKHN0ciwgb3B0aW9ucykge1xuICBjb25zdCBzdGF0ZSA9IHtzdHIsIG9wdGlvbnMsIGN1cnNvcjogMCwgdG9rZW5zOiBbXX1cbiAgbGV4KHN0YXRlKVxuICByZXR1cm4gc3RhdGUudG9rZW5zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXggKHN0YXRlKSB7XG4gIGNvbnN0IHtzdHJ9ID0gc3RhdGVcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICB3aGlsZSAoc3RhdGUuY3Vyc29yIDwgbGVuKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGF0ZS5jdXJzb3JcbiAgICBsZXhUZXh0KHN0YXRlKVxuICAgIGlmIChzdGF0ZS5jdXJzb3IgPT09IHN0YXJ0KSB7XG4gICAgICBjb25zdCBpc0NvbW1lbnQgPSBzdGFydHNXaXRoKHN0ciwgJyEtLScsIHN0YXRlLmN1cnNvciArIDEpXG4gICAgICBpZiAoaXNDb21tZW50KSB7XG4gICAgICAgIGxleENvbW1lbnQoc3RhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gbGV4VGFnKHN0YXRlKVxuICAgICAgICBjb25zdCBzYWZlVGFnID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGNvbnN0IHtjaGlsZGxlc3NUYWdzfSA9IHN0YXRlLm9wdGlvbnNcbiAgICAgICAgaWYgKGFycmF5SW5jbHVkZXMoY2hpbGRsZXNzVGFncywgc2FmZVRhZykpIHtcbiAgICAgICAgICBsZXhTa2lwVGFnKHRhZ05hbWUsIHN0YXRlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGFscGhhbnVtZXJpYyA9IC9bQS1aYS16MC05XS9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVGV4dEVuZCAoc3RyLCBpbmRleCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHRleHRFbmQgPSBzdHIuaW5kZXhPZignPCcsIGluZGV4KVxuICAgIGlmICh0ZXh0RW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRleHRFbmRcbiAgICB9XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQodGV4dEVuZCArIDEpXG4gICAgaWYgKGNoYXIgPT09ICcvJyB8fCBjaGFyID09PSAnIScgfHwgYWxwaGFudW1lcmljLnRlc3QoY2hhcikpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5kXG4gICAgfVxuICAgIGluZGV4ID0gdGV4dEVuZCArIDFcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGV4dCAoc3RhdGUpIHtcbiAgY29uc3QgdHlwZSA9ICd0ZXh0J1xuICBjb25zdCB7c3RyLCBjdXJzb3J9ID0gc3RhdGVcbiAgY29uc3QgdGV4dEVuZCA9IGZpbmRUZXh0RW5kKHN0ciwgY3Vyc29yKVxuICBpZiAodGV4dEVuZCA9PT0gLTEpIHtcbiAgICAvLyB0aGVyZSBpcyBvbmx5IHRleHQgbGVmdFxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHIuc2xpY2UoY3Vyc29yKVxuICAgIHN0YXRlLmN1cnNvciA9IHN0ci5sZW5ndGhcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZSwgY29udGVudH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodGV4dEVuZCA9PT0gY3Vyc29yKSByZXR1cm5cblxuICBjb25zdCBjb250ZW50ID0gc3RyLnNsaWNlKGN1cnNvciwgdGV4dEVuZClcbiAgc3RhdGUuY3Vyc29yID0gdGV4dEVuZFxuICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZSwgY29udGVudH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXhDb21tZW50IChzdGF0ZSkge1xuICBzdGF0ZS5jdXJzb3IgKz0gNCAvLyBcIjwhLS1cIi5sZW5ndGhcbiAgY29uc3Qge3N0ciwgY3Vyc29yfSA9IHN0YXRlXG4gIGNvbnN0IGNvbW1lbnRFbmQgPSBzdHIuaW5kZXhPZignLS0+JywgY3Vyc29yKVxuICBjb25zdCB0eXBlID0gJ2NvbW1lbnQnXG4gIGlmIChjb21tZW50RW5kID09PSAtMSkge1xuICAgIC8vIHRoZXJlIGlzIG9ubHkgdGhlIGNvbW1lbnQgbGVmdFxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHIuc2xpY2UoY3Vyc29yKVxuICAgIHN0YXRlLmN1cnNvciA9IHN0ci5sZW5ndGhcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZSwgY29udGVudH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBjb250ZW50ID0gc3RyLnNsaWNlKGN1cnNvciwgY29tbWVudEVuZClcbiAgc3RhdGUuY3Vyc29yID0gY29tbWVudEVuZCArIDMgLy8gXCItLT5cIi5sZW5ndGhcbiAgc3RhdGUudG9rZW5zLnB1c2goe3R5cGUsIGNvbnRlbnR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGFnIChzdGF0ZSkge1xuICBjb25zdCB7c3RyfSA9IHN0YXRlXG4gIHtcbiAgICBjb25zdCBzZWNvbmRDaGFyID0gc3RyLmNoYXJBdChzdGF0ZS5jdXJzb3IgKyAxKVxuICAgIGNvbnN0IGNsb3NlID0gc2Vjb25kQ2hhciA9PT0gJy8nXG4gICAgc3RhdGUudG9rZW5zLnB1c2goe3R5cGU6ICd0YWctc3RhcnQnLCBjbG9zZX0pXG4gICAgc3RhdGUuY3Vyc29yICs9IGNsb3NlID8gMiA6IDFcbiAgfVxuICBjb25zdCB0YWdOYW1lID0gbGV4VGFnTmFtZShzdGF0ZSlcbiAgbGV4VGFnQXR0cmlidXRlcyhzdGF0ZSlcbiAge1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IHN0ci5jaGFyQXQoc3RhdGUuY3Vyc29yKVxuICAgIGNvbnN0IGNsb3NlID0gZmlyc3RDaGFyID09PSAnLydcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZTogJ3RhZy1lbmQnLCBjbG9zZX0pXG4gICAgc3RhdGUuY3Vyc29yICs9IGNsb3NlID8gMiA6IDFcbiAgfVxuICByZXR1cm4gdGFnTmFtZVxufVxuXG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zI3NwZWNpYWwtd2hpdGUtc3BhY2VcbmNvbnN0IHdoaXRlc3BhY2UgPSAvXFxzL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2hpdGVzcGFjZUNoYXIgKGNoYXIpIHtcbiAgcmV0dXJuIHdoaXRlc3BhY2UudGVzdChjaGFyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGFnTmFtZSAoc3RhdGUpIHtcbiAgY29uc3Qge3N0ciwgY3Vyc29yfSA9IHN0YXRlXG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgbGV0IHN0YXJ0ID0gY3Vyc29yXG4gIHdoaWxlIChzdGFydCA8IGxlbikge1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckF0KHN0YXJ0KVxuICAgIGNvbnN0IGlzVGFnQ2hhciA9ICEoaXNXaGl0ZXNwYWNlQ2hhcihjaGFyKSB8fCBjaGFyID09PSAnLycgfHwgY2hhciA9PT0gJz4nKVxuICAgIGlmIChpc1RhZ0NoYXIpIGJyZWFrXG4gICAgc3RhcnQrK1xuICB9XG5cbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMVxuICB3aGlsZSAoZW5kIDwgbGVuKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQoZW5kKVxuICAgIGNvbnN0IGlzVGFnQ2hhciA9ICEoaXNXaGl0ZXNwYWNlQ2hhcihjaGFyKSB8fCBjaGFyID09PSAnLycgfHwgY2hhciA9PT0gJz4nKVxuICAgIGlmICghaXNUYWdDaGFyKSBicmVha1xuICAgIGVuZCsrXG4gIH1cblxuICBzdGF0ZS5jdXJzb3IgPSBlbmRcbiAgY29uc3QgdGFnTmFtZSA9IHN0ci5zbGljZShzdGFydCwgZW5kKVxuICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZTogJ3RhZycsIGNvbnRlbnQ6IHRhZ05hbWV9KVxuICByZXR1cm4gdGFnTmFtZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGFnQXR0cmlidXRlcyAoc3RhdGUpIHtcbiAgY29uc3Qge3N0ciwgdG9rZW5zfSA9IHN0YXRlXG4gIGxldCBjdXJzb3IgPSBzdGF0ZS5jdXJzb3JcbiAgbGV0IHF1b3RlID0gbnVsbCAvLyBudWxsLCBzaW5nbGUtLCBvciBkb3VibGUtcXVvdGVcbiAgbGV0IHdvcmRCZWdpbiA9IGN1cnNvciAvLyBpbmRleCBvZiB3b3JkIHN0YXJ0XG4gIGNvbnN0IHdvcmRzID0gW10gLy8gXCJrZXlcIiwgXCJrZXk9dmFsdWVcIiwgXCJrZXk9J3ZhbHVlJ1wiLCBldGNcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQoY3Vyc29yKVxuICAgIGlmIChxdW90ZSkge1xuICAgICAgY29uc3QgaXNRdW90ZUVuZCA9IGNoYXIgPT09IHF1b3RlXG4gICAgICBpZiAoaXNRdW90ZUVuZCkge1xuICAgICAgICBxdW90ZSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGlzVGFnRW5kID0gY2hhciA9PT0gJy8nIHx8IGNoYXIgPT09ICc+J1xuICAgIGlmIChpc1RhZ0VuZCkge1xuICAgICAgaWYgKGN1cnNvciAhPT0gd29yZEJlZ2luKSB7XG4gICAgICAgIHdvcmRzLnB1c2goc3RyLnNsaWNlKHdvcmRCZWdpbiwgY3Vyc29yKSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgaXNXb3JkRW5kID0gaXNXaGl0ZXNwYWNlQ2hhcihjaGFyKVxuICAgIGlmIChpc1dvcmRFbmQpIHtcbiAgICAgIGlmIChjdXJzb3IgIT09IHdvcmRCZWdpbikge1xuICAgICAgICB3b3Jkcy5wdXNoKHN0ci5zbGljZSh3b3JkQmVnaW4sIGN1cnNvcikpXG4gICAgICB9XG4gICAgICB3b3JkQmVnaW4gPSBjdXJzb3IgKyAxXG4gICAgICBjdXJzb3IrK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBpc1F1b3RlU3RhcnQgPSBjaGFyID09PSAnXFwnJyB8fCBjaGFyID09PSAnXCInXG4gICAgaWYgKGlzUXVvdGVTdGFydCkge1xuICAgICAgcXVvdGUgPSBjaGFyXG4gICAgICBjdXJzb3IrK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjdXJzb3IrK1xuICB9XG4gIHN0YXRlLmN1cnNvciA9IGN1cnNvclxuXG4gIGNvbnN0IHdMZW4gPSB3b3Jkcy5sZW5ndGhcbiAgY29uc3QgdHlwZSA9ICdhdHRyaWJ1dGUnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd0xlbjsgaSsrKSB7XG4gICAgY29uc3Qgd29yZCA9IHdvcmRzW2ldXG4gICAgY29uc3QgaXNOb3RQYWlyID0gd29yZC5pbmRleE9mKCc9JykgPT09IC0xXG4gICAgaWYgKGlzTm90UGFpcikge1xuICAgICAgY29uc3Qgc2Vjb25kV29yZCA9IHdvcmRzW2kgKyAxXVxuICAgICAgaWYgKHNlY29uZFdvcmQgJiYgc3RhcnRzV2l0aChzZWNvbmRXb3JkLCAnPScpKSB7XG4gICAgICAgIGlmIChzZWNvbmRXb3JkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBuZXdXb3JkID0gd29yZCArIHNlY29uZFdvcmRcbiAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZSwgY29udGVudDogbmV3V29yZH0pXG4gICAgICAgICAgaSArPSAxXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlyZFdvcmQgPSB3b3Jkc1tpICsgMl1cbiAgICAgICAgaSArPSAxXG4gICAgICAgIGlmICh0aGlyZFdvcmQpIHtcbiAgICAgICAgICBjb25zdCBuZXdXb3JkID0gd29yZCArICc9JyArIHRoaXJkV29yZFxuICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlLCBjb250ZW50OiBuZXdXb3JkfSlcbiAgICAgICAgICBpICs9IDFcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRzV2l0aCh3b3JkLCAnPScpKSB7XG4gICAgICBjb25zdCBzZWNvbmRXb3JkID0gd29yZHNbaSArIDFdXG4gICAgICBpZiAoc2Vjb25kV29yZCAmJiAhc3RyaW5nSW5jbHVkZXMoc2Vjb25kV29yZCwgJz0nKSkge1xuICAgICAgICBjb25zdCBuZXdXb3JkID0gd29yZCArIHNlY29uZFdvcmRcbiAgICAgICAgdG9rZW5zLnB1c2goe3R5cGUsIGNvbnRlbnQ6IG5ld1dvcmR9KVxuICAgICAgICBpICs9IDFcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3V29yZCA9IHdvcmQuc2xpY2UoMCwgLTEpXG4gICAgICB0b2tlbnMucHVzaCh7dHlwZSwgY29udGVudDogbmV3V29yZH0pXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHt0eXBlLCBjb250ZW50OiB3b3JkfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4U2tpcFRhZyAodGFnTmFtZSwgc3RhdGUpIHtcbiAgY29uc3Qge3N0ciwgY3Vyc29yLCB0b2tlbnN9ID0gc3RhdGVcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICBsZXQgaW5kZXggPSBjdXJzb3JcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB7XG4gICAgY29uc3QgbmV4dFRhZyA9IHN0ci5pbmRleE9mKCc8LycsIGluZGV4KVxuICAgIGlmIChuZXh0VGFnID09PSAtMSkge1xuICAgICAgbGV4VGV4dChzdGF0ZSlcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgdGFnU3RhdGUgPSB7c3RyLCBjdXJzb3I6IG5leHRUYWcgKyAyLCB0b2tlbnM6IFtdfVxuICAgIGNvbnN0IG5hbWUgPSBsZXhUYWdOYW1lKHRhZ1N0YXRlKVxuICAgIGNvbnN0IHNhZmVUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHNhZmVUYWdOYW1lICE9PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGluZGV4ID0gdGFnU3RhdGUuY3Vyc29yXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHIuc2xpY2UoY3Vyc29yLCBuZXh0VGFnKVxuICAgIHRva2Vucy5wdXNoKHt0eXBlOiAndGV4dCcsIGNvbnRlbnR9KVxuICAgIGNvbnN0IG9wZW5UYWcgPSB7dHlwZTogJ3RhZy1zdGFydCcsIGNsb3NlOiB0cnVlfVxuICAgIGNvbnN0IGNsb3NlVGFnID0ge3R5cGU6ICd0YWctZW5kJywgY2xvc2U6IGZhbHNlfVxuICAgIGxleFRhZ0F0dHJpYnV0ZXModGFnU3RhdGUpXG4gICAgdG9rZW5zLnB1c2gob3BlblRhZywgLi4udGFnU3RhdGUudG9rZW5zLCBjbG9zZVRhZylcbiAgICBzdGF0ZS5jdXJzb3IgPSB0YWdTdGF0ZS5jdXJzb3IgKyAxXG4gICAgYnJlYWtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvaGltYWxheWEvbGV4ZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBT0E7QUFNQTtBQXVCQTtBQWNBO0FBbUJBO0FBa0JBO0FBcUJBO0FBSUE7QUF5QkE7QUF5RkE7QUFDQTtBQW5PQTtBQUNBOzs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!*************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/parser.js ***!
  \*************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.parse = parse;\nfunction parser(tokens, options) {\n  var root = { tagName: null, children: [] };\n  var state = { tokens: tokens, options: options, cursor: 0, stack: [root] };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n      if (parentTagName === tagName) {\n        break;\n      }\n      if (tagParents.indexOf(parentTagName) >= 0) {\n        return true;\n      }\n      currentIndex--;\n    }\n  }\n  return false;\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n    if (token.close) {\n      var item = void 0;\n      while (item = stack.pop()) {\n        if (tagName === item.tagName) break;\n      }\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n      break;\n    }\n\n    var isClosingTag = options.closingTags.indexOf(tagName) >= 0;\n    var shouldRewindToAutoClose = isClosingTag;\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    nodes.push({\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children\n    });\n\n    var hasChildren = !(attrToken.close || options.voidTags.indexOf(tagName) >= 0);\n    if (hasChildren) {\n      stack.push({ tagName: tagName, children: children });\n      var innerState = { tokens: tokens, options: options, cursor: cursor, stack: stack };\n      parse(innerState);\n      cursor = innerState.cursor;\n    }\n  }\n  state.cursor = cursor;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS9wYXJzZXIuanM/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlciAodG9rZW5zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJvb3QgPSB7dGFnTmFtZTogbnVsbCwgY2hpbGRyZW46IFtdfVxuICBjb25zdCBzdGF0ZSA9IHt0b2tlbnMsIG9wdGlvbnMsIGN1cnNvcjogMCwgc3RhY2s6IFtyb290XX1cbiAgcGFyc2Uoc3RhdGUpXG4gIHJldHVybiByb290LmNoaWxkcmVuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNUZXJtaW5hbFBhcmVudCAodGFnTmFtZSwgc3RhY2ssIHRlcm1pbmFscykge1xuICBjb25zdCB0YWdQYXJlbnRzID0gdGVybWluYWxzW3RhZ05hbWVdXG4gIGlmICh0YWdQYXJlbnRzKSB7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IHN0YWNrLmxlbmd0aCAtIDFcbiAgICB3aGlsZSAoY3VycmVudEluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBzdGFja1tjdXJyZW50SW5kZXhdLnRhZ05hbWVcbiAgICAgIGlmIChwYXJlbnRUYWdOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAodGFnUGFyZW50cy5pbmRleE9mKHBhcmVudFRhZ05hbWUpPj0wKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBjdXJyZW50SW5kZXgtLVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlIChzdGF0ZSkge1xuICBjb25zdCB7dG9rZW5zLCBvcHRpb25zfSA9IHN0YXRlXG4gIGxldCB7c3RhY2t9ID0gc3RhdGVcbiAgbGV0IG5vZGVzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY2hpbGRyZW5cbiAgY29uc3QgbGVuID0gdG9rZW5zLmxlbmd0aFxuICBsZXQge2N1cnNvcn0gPSBzdGF0ZVxuICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbY3Vyc29yXVxuICAgIGlmICh0b2tlbi50eXBlICE9PSAndGFnLXN0YXJ0Jykge1xuICAgICAgbm9kZXMucHVzaCh0b2tlbilcbiAgICAgIGN1cnNvcisrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IHRhZ1Rva2VuID0gdG9rZW5zWysrY3Vyc29yXVxuICAgIGN1cnNvcisrXG4gICAgY29uc3QgdGFnTmFtZSA9IHRhZ1Rva2VuLmNvbnRlbnQudG9Mb3dlckNhc2UoKVxuICAgIGlmICh0b2tlbi5jbG9zZSkge1xuICAgICAgbGV0IGl0ZW1cbiAgICAgIHdoaWxlICgoaXRlbSA9IHN0YWNrLnBvcCgpKSkge1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gaXRlbS50YWdOYW1lKSBicmVha1xuICAgICAgfVxuICAgICAgd2hpbGUgKGN1cnNvciA8IGxlbikge1xuICAgICAgICBjb25zdCBlbmRUb2tlbiA9IHRva2Vuc1tjdXJzb3JdXG4gICAgICAgIGlmIChlbmRUb2tlbi50eXBlICE9PSAndGFnLWVuZCcpIGJyZWFrXG4gICAgICAgIGN1cnNvcisrXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNvbnN0IGlzQ2xvc2luZ1RhZyA9IG9wdGlvbnMuY2xvc2luZ1RhZ3MuaW5kZXhPZih0YWdOYW1lKT49MFxuICAgIGxldCBzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSA9IGlzQ2xvc2luZ1RhZ1xuICAgIGlmIChzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSkge1xuICAgICAgY29uc3QgeyBjbG9zaW5nVGFnQW5jZXN0b3JCcmVha2VyczogdGVybWluYWxzIH0gPSBvcHRpb25zXG4gICAgICBzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSA9ICFoYXNUZXJtaW5hbFBhcmVudCh0YWdOYW1lLCBzdGFjaywgdGVybWluYWxzKVxuICAgIH1cblxuICAgIGlmIChzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSkge1xuICAgICAgLy8gcmV3aW5kIHRoZSBzdGFjayB0byBqdXN0IGFib3ZlIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHN0YWNrLmxlbmd0aCAtIDFcbiAgICAgIHdoaWxlIChjdXJyZW50SW5kZXggPiAwKSB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSBzdGFja1tjdXJyZW50SW5kZXhdLnRhZ05hbWUpIHtcbiAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIGN1cnJlbnRJbmRleClcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4IC0gMVxuICAgICAgICAgIG5vZGVzID0gc3RhY2tbcHJldmlvdXNJbmRleF0uY2hpbGRyZW5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleCAtIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYXR0cmlidXRlcyA9IFtdXG4gICAgbGV0IGF0dHJUb2tlblxuICAgIHdoaWxlIChjdXJzb3IgPCBsZW4pIHtcbiAgICAgIGF0dHJUb2tlbiA9IHRva2Vuc1tjdXJzb3JdXG4gICAgICBpZiAoYXR0clRva2VuLnR5cGUgPT09ICd0YWctZW5kJykgYnJlYWtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyVG9rZW4uY29udGVudClcbiAgICAgIGN1cnNvcisrXG4gICAgfVxuXG4gICAgY3Vyc29yKytcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICB0YWdOYW1lOiB0YWdUb2tlbi5jb250ZW50LFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcblxuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gIShhdHRyVG9rZW4uY2xvc2UgfHwgb3B0aW9ucy52b2lkVGFncy5pbmRleE9mKHRhZ05hbWUpPj0wKVxuICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgc3RhY2sucHVzaCh7dGFnTmFtZSwgY2hpbGRyZW59KVxuICAgICAgY29uc3QgaW5uZXJTdGF0ZSA9IHt0b2tlbnMsIG9wdGlvbnMsIGN1cnNvciwgc3RhY2t9XG4gICAgICBwYXJzZShpbm5lclN0YXRlKVxuICAgICAgY3Vyc29yID0gaW5uZXJTdGF0ZS5jdXJzb3JcbiAgICB9XG4gIH1cbiAgc3RhdGUuY3Vyc29yID0gY3Vyc29yXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS9wYXJzZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7QUFPQTtBQWtCQTtBQXpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!***********************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/tags.js ***!
  \***********************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Tags which contain arbitary non-parsed content\n  For example: <script> JavaScript should not be parsed\n*/\nvar childlessTags = exports.childlessTags = ['style', 'script', 'template'];\n\n/*\n  Tags which auto-close because they cannot be nested\n  For example: <p>Outer<p>Inner is <p>Outer</p><p>Inner</p>\n*/\nvar closingTags = exports.closingTags = ['html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option', 'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'];\n\n/*\n  Closing tags which have ancestor tags which\n  may exist within them which prevent the\n  closing tag from auto-closing.\n  For example: in <li><ul><li></ul></li>,\n  the top-level <li> should not auto-close.\n*/\nvar closingTagAncestorBreakers = exports.closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n\n  /*\n    Tags which do not need the closing tag\n    For example: <img> does not need </img>\n  */\n};var voidTags = exports.voidTags = ['!doctype', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS90YWdzLmpzP2U5MDkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGFncyB3aGljaCBjb250YWluIGFyYml0YXJ5IG5vbi1wYXJzZWQgY29udGVudFxuICBGb3IgZXhhbXBsZTogPHNjcmlwdD4gSmF2YVNjcmlwdCBzaG91bGQgbm90IGJlIHBhcnNlZFxuKi9cbmV4cG9ydCBjb25zdCBjaGlsZGxlc3NUYWdzID0gWydzdHlsZScsICdzY3JpcHQnLCAndGVtcGxhdGUnXVxuXG4vKlxuICBUYWdzIHdoaWNoIGF1dG8tY2xvc2UgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBuZXN0ZWRcbiAgRm9yIGV4YW1wbGU6IDxwPk91dGVyPHA+SW5uZXIgaXMgPHA+T3V0ZXI8L3A+PHA+SW5uZXI8L3A+XG4qL1xuZXhwb3J0IGNvbnN0IGNsb3NpbmdUYWdzID0gW1xuICAnaHRtbCcsICdoZWFkJywgJ2JvZHknLCAncCcsICdkdCcsICdkZCcsICdsaScsICdvcHRpb24nLFxuICAndGhlYWQnLCAndGgnLCAndGJvZHknLCAndHInLCAndGQnLCAndGZvb3QnLCAnY29sZ3JvdXAnXG5dXG5cbi8qXG4gIENsb3NpbmcgdGFncyB3aGljaCBoYXZlIGFuY2VzdG9yIHRhZ3Mgd2hpY2hcbiAgbWF5IGV4aXN0IHdpdGhpbiB0aGVtIHdoaWNoIHByZXZlbnQgdGhlXG4gIGNsb3NpbmcgdGFnIGZyb20gYXV0by1jbG9zaW5nLlxuICBGb3IgZXhhbXBsZTogaW4gPGxpPjx1bD48bGk+PC91bD48L2xpPixcbiAgdGhlIHRvcC1sZXZlbCA8bGk+IHNob3VsZCBub3QgYXV0by1jbG9zZS5cbiovXG5leHBvcnQgY29uc3QgY2xvc2luZ1RhZ0FuY2VzdG9yQnJlYWtlcnMgPSB7XG4gIGxpOiBbJ3VsJywgJ29sJywgJ21lbnUnXSxcbiAgZHQ6IFsnZGwnXSxcbiAgZGQ6IFsnZGwnXSxcbiAgdGJvZHk6IFsndGFibGUnXSxcbiAgdGhlYWQ6IFsndGFibGUnXSxcbiAgdGZvb3Q6IFsndGFibGUnXSxcbiAgdHI6IFsndGFibGUnXSxcbiAgdGQ6IFsndGFibGUnXVxufVxuXG4vKlxuICBUYWdzIHdoaWNoIGRvIG5vdCBuZWVkIHRoZSBjbG9zaW5nIHRhZ1xuICBGb3IgZXhhbXBsZTogPGltZz4gZG9lcyBub3QgbmVlZCA8L2ltZz5cbiovXG5leHBvcnQgY29uc3Qgdm9pZFRhZ3MgPSBbXG4gICchZG9jdHlwZScsICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2NvbW1hbmQnLFxuICAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsICdsaW5rJyxcbiAgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicidcbl1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2hpbWFsYXlhL3RhZ3MuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBWEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!*****************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockForeach.js ***!
  \*****************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockForeach;\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 3);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 1);\n\nfunction blockForeach(stamp, tpl, ctx0, level) {\n\tif (!(tpl && tpl.children && tpl.children.length > 0)) {\n\n\t\tconsole.log(\"empty foreach\", tpl);\n\t\treturn;\n\t}\n\tif (tpl.attrs && tpl.attrs['items'] && tpl.attrs['items'].call) {\n\n\t\tvar items = tpl.attrs['items'];\n\t\tvar val2 = ctx0.expr(items);\n\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\trenderItems(val2, stamp, tpl, ctx0);\n\t\t});\n\t}\n};\n\nfunction renderItems(items2, stamp, tpl, ctx0) {\n\n\tif (items2.length == 0) {\n\t\t//remove all\n\t\tconsole.log('removeAll');\n\t\tctx0.dispose();\n\t\treturn;\n\t}\n\n\tvar eqMin = arrEq(ctx0.subscribers, items2);\n\n\tif (eqMin == ctx0.subscribers.length) {\n\t\t//only Append\n\t\tconsole.log('onlyAppend', eqMin);\n\t\tfor (var i = eqMin, max = items2.length; i < max; i++) {\n\t\t\tappendItem(items2[i], stamp, tpl, ctx0);\n\t\t}return;\n\t}\n\tif (ctx0.subscribers.length > items2.length && eqMin == items2.length) {\n\t\t//only remove\n\t\tconsole.log('onlyRemove', eqMin, ctx0.subscribers.length, '<', items2.length);\n\t\tfor (var _i = ctx0.subscribers.length - 1; _i >= items2.length; _i--) {\n\t\t\tctx0.subscribers[_i].dispose();\n\t\t}ctx0.subscribers = ctx0.subscribers.slice(0, items2.length);\n\t\treturn;\n\t}\n\n\tif (Map && Map.call) {\n\t\t//merge contenxt in Map\n\t\tmergeItemsMap(items2, eqMin, tpl, ctx0, stamp[0], stamp[1]);\n\t\treturn;\n\t}\n\n\t//bad scenario, delete all old, add new\n\tctx0.dispose();\n\tfor (var _i2 = 0, _max = items2.length; _i2 < _max; _i2++) {\n\t\tappendItem(items2[_i2], stamp, tpl, ctx0);\n\t}\n};\n\nfunction arrEq(contexts, items2, start) {\n\tstart = start || 0;\n\tvar max = contexts.length < items2.length ? contexts.length : items2.length;\n\tfor (var i = 0; i < max; i++) {\n\t\tif (contexts[i].model != items2[i]) return i;\n\t}\n\treturn max;\n}\n\nfunction appendItem(m2, stamp, tpl, ctx0) {\n\tvar ctx2 = ctx0.createChild(m2);\n\t(0, _renderCtx.renderCtx)(stamp, tpl.children, ctx2, 0);\n\treturn ctx2;\n}\n\nfunction mergeItemsMap(items2, eqMin, tpl, ctx0, parent, stamp1) {\n\tvar oldMap = new Map();\n\tvar old = ctx0.subscribers;\n\t//index old\n\tfor (var i = eqMin; i < old.length; i++) {\n\t\tvar ctx2 = old[i];\n\t\tctx2._oldIndex = i;\n\t\tctx2._newIndex = -1;\n\t\toldMap.set(ctx2.model, ctx2);\n\t}\n\t//index new\n\tvar reusedCtx = [];\n\tfor (var _i3 = eqMin; _i3 < items2.length; _i3++) {\n\t\tvar _ctx = oldMap.get(items2[_i3]);\n\t\tif (_ctx) {\n\t\t\t_ctx._newIndex = _i3;\n\t\t\treusedCtx[_i3] = _ctx;\n\t\t}\n\t}\n\n\tctx0.subscribers = ctx0.subscribers.slice(0, eqMin);\n\tvar aktPosOld = nextOldPos(old, eqMin);\n\tfor (var _i4 = eqMin, max = items2.length; _i4 < max; _i4++) {\n\t\tvar m2 = items2[_i4];\n\t\tif (aktPosOld < old.length && old[aktPosOld].model === m2) {\n\t\t\t//the same models, all is ok\n\t\t\tctx0.subscribers.push(old[aktPosOld]);\n\t\t\told[aktPosOld] = null;\n\t\t\taktPosOld = nextOldPos(old, aktPosOld + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tvar beforeNode = aktPosOld < old.length ? old[aktPosOld].rootNodes[0] : stamp1;\n\t\tvar _ctx2 = reusedCtx[_i4];\n\t\tif (_ctx2) {\n\t\t\t//reuse\n\t\t\tfor (var i2 = 0, max2 = _ctx2.rootNodes.length; i2 < max2; i2++) {\n\t\t\t\tparent.insertBefore(_ctx2.rootNodes[i2], beforeNode);\n\t\t\t};\n\t\t\tctx0.subscribers.push(_ctx2);\n\t\t\told[_ctx2._oldIndex] = null;\n\t\t} else {\n\t\t\t//create new\n\t\t\t_ctx2 = appendItem(m2, [parent, beforeNode], tpl, ctx0);\n\t\t\tctx0.subscribers.push(_ctx2);\n\t\t}\n\t}\n}\n\nfunction nextOldPos(old, aktPosOld) {\n\twhile (aktPosOld < old.length) {\n\t\tvar v = old[aktPosOld];\n\t\tif (v != null) {\n\t\t\tif (v._newIndex >= 0) return aktPosOld;\n\t\t\tv.dispose();\n\t\t\told[aktPosOld] = null;\n\t\t}\n\t\taktPosOld++;\n\t}\n\treturn aktPosOld;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tGb3JlYWNoLmpzPzNhODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW53cmFwLCBkZXBlbmRlbmN5RGV0ZWN0aW9uIH0gIGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVkIH0gIGZyb20gJy4uL3Rrby90a28uY29tcHV0ZWQuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJDdHggfSAgZnJvbSAnLi4vcmVuZGVyQ3R4LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsb2NrRm9yZWFjaChzdGFtcCwgdHBsLCBjdHgwLCBsZXZlbCl7XHJcblx0aWYoISh0cGwgJiYgdHBsLmNoaWxkcmVuICYmIHRwbC5jaGlsZHJlbi5sZW5ndGg+MCkpe1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwiZW1wdHkgZm9yZWFjaFwiICx0cGwpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRpZih0cGwuYXR0cnMgJiYgdHBsLmF0dHJzWydpdGVtcyddICYmIHRwbC5hdHRyc1snaXRlbXMnXS5jYWxsKXtcclxuXHJcblx0XHR2YXIgaXRlbXMgPSB0cGwuYXR0cnNbJ2l0ZW1zJ107XHJcblx0XHR2YXIgdmFsMiA9IGN0eDAuZXhwcihpdGVtcyk7XHJcblx0XHR2YWwyID0gdW53cmFwKHZhbDIpO1xyXG5cdFx0ZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoZnVuY3Rpb24oKXtcclxuXHRcdFx0cmVuZGVySXRlbXModmFsMiwgc3RhbXAsIHRwbCwgY3R4MCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiByZW5kZXJJdGVtcyhpdGVtczIsIHN0YW1wLCB0cGwsIGN0eDApe1xyXG5cclxuXHRpZihpdGVtczIubGVuZ3RoPT0wKXtcclxuXHRcdC8vcmVtb3ZlIGFsbFxyXG5cdFx0Y29uc29sZS5sb2coJ3JlbW92ZUFsbCcpO1xyXG5cdFx0Y3R4MC5kaXNwb3NlKCk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRsZXQgZXFNaW4gPSBhcnJFcShjdHgwLnN1YnNjcmliZXJzLCBpdGVtczIpO1xyXG5cclxuXHRpZihlcU1pbj09Y3R4MC5zdWJzY3JpYmVycy5sZW5ndGgpe1xyXG5cdFx0Ly9vbmx5IEFwcGVuZFxyXG5cdFx0Y29uc29sZS5sb2coJ29ubHlBcHBlbmQnLCBlcU1pbik7XHJcblx0XHRmb3IobGV0IGk9ZXFNaW4sIG1heD1pdGVtczIubGVuZ3RoOyBpPG1heDsgaSsrKSBhcHBlbmRJdGVtKGl0ZW1zMltpXSwgc3RhbXAsIHRwbCwgY3R4MCk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdGlmKGN0eDAuc3Vic2NyaWJlcnMubGVuZ3RoPml0ZW1zMi5sZW5ndGggJiYgZXFNaW49PWl0ZW1zMi5sZW5ndGgpe1xyXG5cdFx0Ly9vbmx5IHJlbW92ZVxyXG5cdFx0Y29uc29sZS5sb2coJ29ubHlSZW1vdmUnLCBlcU1pbiwgY3R4MC5zdWJzY3JpYmVycy5sZW5ndGgsICc8JywgaXRlbXMyLmxlbmd0aCk7XHJcblx0XHRmb3IobGV0IGk9Y3R4MC5zdWJzY3JpYmVycy5sZW5ndGgtMTsgaT49aXRlbXMyLmxlbmd0aDsgaS0tKSBjdHgwLnN1YnNjcmliZXJzW2ldLmRpc3Bvc2UoKTtcclxuXHRcdGN0eDAuc3Vic2NyaWJlcnMgPSBjdHgwLnN1YnNjcmliZXJzLnNsaWNlKDAsIGl0ZW1zMi5sZW5ndGgpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0aWYoTWFwICYmIE1hcC5jYWxsKXtcclxuXHRcdC8vbWVyZ2UgY29udGVueHQgaW4gTWFwXHJcblx0XHRtZXJnZUl0ZW1zTWFwKGl0ZW1zMiwgZXFNaW4sIHRwbCwgY3R4MCwgc3RhbXBbMF0sIHN0YW1wWzFdKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vYmFkIHNjZW5hcmlvLCBkZWxldGUgYWxsIG9sZCwgYWRkIG5ld1xyXG5cdGN0eDAuZGlzcG9zZSgpO1xyXG5cdGZvcihsZXQgaT0wLCBtYXg9aXRlbXMyLmxlbmd0aDsgaTxtYXg7IGkrKykgYXBwZW5kSXRlbShpdGVtczJbaV0sIHN0YW1wLCB0cGwsIGN0eDApO1xyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGFyckVxKGNvbnRleHRzLCBpdGVtczIsIHN0YXJ0KXtcclxuXHRzdGFydCA9IHN0YXJ0IHx8IDA7XHJcblx0Y29uc3QgbWF4ID0gY29udGV4dHMubGVuZ3RoPGl0ZW1zMi5sZW5ndGggPyBjb250ZXh0cy5sZW5ndGggOiBpdGVtczIubGVuZ3RoO1xyXG5cdGZvcihsZXQgaSA9IDA7IGk8bWF4OyBpKyspe1xyXG5cdFx0aWYoY29udGV4dHNbaV0ubW9kZWwhPWl0ZW1zMltpXSkgcmV0dXJuIGk7XHJcblx0fVxyXG5cdHJldHVybiBtYXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGVuZEl0ZW0obTIsIHN0YW1wLCB0cGwsIGN0eDApe1xyXG5cdGNvbnN0IGN0eDIgPSBjdHgwLmNyZWF0ZUNoaWxkKG0yKTtcclxuXHRyZW5kZXJDdHgoc3RhbXAsIHRwbC5jaGlsZHJlbiwgY3R4MiwgMCk7XHJcblx0cmV0dXJuIGN0eDI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlSXRlbXNNYXAoaXRlbXMyLCBlcU1pbiwgdHBsLCBjdHgwLCBwYXJlbnQsIHN0YW1wMSl7XHJcblx0bGV0IG9sZE1hcCA9IG5ldyBNYXAoKTtcclxuXHRsZXQgb2xkID0gY3R4MC5zdWJzY3JpYmVycztcclxuXHQvL2luZGV4IG9sZFxyXG5cdGZvcihsZXQgaT1lcU1pbjsgaTxvbGQubGVuZ3RoOyBpKyspe1xyXG5cdFx0Y29uc3QgY3R4MiA9IG9sZFtpXTtcclxuXHRcdGN0eDIuX29sZEluZGV4ID0gaTtcclxuXHRcdGN0eDIuX25ld0luZGV4ID0gLTE7XHJcblx0XHRvbGRNYXAuc2V0KGN0eDIubW9kZWwsIGN0eDIpO1xyXG5cdH1cclxuXHQvL2luZGV4IG5ld1xyXG5cdGxldCByZXVzZWRDdHggPSBbXTtcclxuXHRmb3IobGV0IGk9ZXFNaW47IGk8aXRlbXMyLmxlbmd0aDsgaSsrKXtcclxuXHRcdGNvbnN0IGN0eDIgPSBvbGRNYXAuZ2V0KGl0ZW1zMltpXSk7XHJcblx0XHRpZihjdHgyKSB7IFxyXG5cdFx0XHRjdHgyLl9uZXdJbmRleCA9IGk7IFxyXG5cdFx0XHRyZXVzZWRDdHhbaV0gPSBjdHgyOyBcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGN0eDAuc3Vic2NyaWJlcnMgPSBjdHgwLnN1YnNjcmliZXJzLnNsaWNlKDAsIGVxTWluKTtcclxuXHRsZXQgYWt0UG9zT2xkID0gbmV4dE9sZFBvcyhvbGQsIGVxTWluKTtcclxuXHRmb3IobGV0IGk9ZXFNaW4sIG1heD1pdGVtczIubGVuZ3RoOyBpPG1heDsgaSsrKXtcclxuXHRcdGNvbnN0IG0yID0gaXRlbXMyW2ldO1xyXG5cdFx0aWYoYWt0UG9zT2xkPG9sZC5sZW5ndGggJiYgb2xkW2FrdFBvc09sZF0ubW9kZWw9PT1tMikge1xyXG5cdFx0XHQvL3RoZSBzYW1lIG1vZGVscywgYWxsIGlzIG9rXHJcblx0XHRcdGN0eDAuc3Vic2NyaWJlcnMucHVzaChvbGRbYWt0UG9zT2xkXSk7XHJcblx0XHRcdG9sZFtha3RQb3NPbGRdID0gbnVsbDtcclxuXHRcdFx0YWt0UG9zT2xkID0gbmV4dE9sZFBvcyhvbGQsIGFrdFBvc09sZCsxKTtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRjb25zdCBiZWZvcmVOb2RlID0gYWt0UG9zT2xkPG9sZC5sZW5ndGggPyBvbGRbYWt0UG9zT2xkXS5yb290Tm9kZXNbMF0gOiBzdGFtcDE7XHJcblx0XHRsZXQgY3R4MiA9IHJldXNlZEN0eFtpXTtcclxuXHRcdGlmKGN0eDIpe1xyXG5cdFx0XHQvL3JldXNlXHJcblx0XHRcdGZvcihsZXQgaTI9MCwgbWF4Mj1jdHgyLnJvb3ROb2Rlcy5sZW5ndGg7IGkyPG1heDI7IGkyKyspe1xyXG5cdFx0XHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoY3R4Mi5yb290Tm9kZXNbaTJdLGJlZm9yZU5vZGUpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRjdHgwLnN1YnNjcmliZXJzLnB1c2goY3R4Mik7XHJcblx0XHRcdG9sZFtjdHgyLl9vbGRJbmRleF0gPSBudWxsO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly9jcmVhdGUgbmV3XHJcblx0XHRcdGN0eDIgPSBhcHBlbmRJdGVtKG0yLCBbIHBhcmVudCwgYmVmb3JlTm9kZV0sIHRwbCwgY3R4MCk7XHJcblx0XHRcdGN0eDAuc3Vic2NyaWJlcnMucHVzaChjdHgyKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRPbGRQb3Mob2xkLCBha3RQb3NPbGQpe1xyXG5cdHdoaWxlKGFrdFBvc09sZDxvbGQubGVuZ3RoKSB7XHJcblx0XHRjb25zdCB2ID0gb2xkW2FrdFBvc09sZF07XHJcblx0XHRpZih2IT1udWxsKXtcclxuXHRcdFx0aWYodi5fbmV3SW5kZXg+PTApIHJldHVybiBha3RQb3NPbGQ7XHJcblx0XHRcdHYuZGlzcG9zZSgpO1xyXG5cdFx0XHRvbGRbYWt0UG9zT2xkXSA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRha3RQb3NPbGQrKztcclxuXHR9XHJcblx0cmV0dXJuIGFrdFBvc09sZDtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2Jsb2Nrcy9ibG9ja0ZvcmVhY2guanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBSUE7QUFDQTtBQUxBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockIf.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockIf;\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 1);\n\nfunction blockIf(stamp, tpl, ctx0, level) {\n\n\tif (tpl.children && tpl.children.length > 0 && tpl.attrs && tpl.attrs['value'] && tpl.attrs['value'].call) {\n\n\t\tvar value = tpl.attrs['value'];\n\t\tvar val2 = ctx0.expr(value);\n\t\tval2 = (0, _tkoObservable.unwrap)(val2) ? true : false;\n\n\t\t//check boolean expression change true/false\n\t\tif (val2 === ctx0.lastVal) return;\n\t\tctx0.lastVal = val2;\n\n\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\n\t\t\t//remove old children tpl\n\t\t\tctx0.dispose();\n\n\t\t\tif (val2) {\n\t\t\t\t//render new children tpl\n\t\t\t\t(0, _renderCtx.renderCtx)(stamp, tpl.children, ctx0, 0);\n\t\t\t}\n\t\t});\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tJZi5qcz9iYTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVud3JhcCwgZGVwZW5kZW5jeURldGVjdGlvbiB9ICBmcm9tICcuLi90a28vdGtvLm9ic2VydmFibGUuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJDdHggfSAgZnJvbSAnLi4vcmVuZGVyQ3R4LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsb2NrSWYoc3RhbXAsIHRwbCwgY3R4MCwgbGV2ZWwpe1xyXG5cclxuXHRpZih0cGwuY2hpbGRyZW4gJiYgdHBsLmNoaWxkcmVuLmxlbmd0aD4wICYmIHRwbC5hdHRycyAmJiB0cGwuYXR0cnNbJ3ZhbHVlJ10gJiYgdHBsLmF0dHJzWyd2YWx1ZSddLmNhbGwpe1xyXG5cdFx0XHJcblx0XHR2YXIgdmFsdWUgPSB0cGwuYXR0cnNbJ3ZhbHVlJ107XHJcblx0XHR2YXIgdmFsMiA9IGN0eDAuZXhwcih2YWx1ZSk7XHJcblx0XHR2YWwyID0gdW53cmFwKHZhbDIpID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuXHRcdC8vY2hlY2sgYm9vbGVhbiBleHByZXNzaW9uIGNoYW5nZSB0cnVlL2ZhbHNlXHJcblx0XHRpZih2YWwyPT09Y3R4MC5sYXN0VmFsKSByZXR1cm47XHJcblx0XHRjdHgwLmxhc3RWYWwgPSB2YWwyO1xyXG5cclxuXHRcdGRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uKCl7XHJcblx0XHJcblx0XHRcdC8vcmVtb3ZlIG9sZCBjaGlsZHJlbiB0cGxcclxuXHRcdFx0Y3R4MC5kaXNwb3NlKCk7XHJcblx0XHJcblx0XHRcdGlmKHZhbDIpe1xyXG5cdFx0XHRcdC8vcmVuZGVyIG5ldyBjaGlsZHJlbiB0cGxcclxuXHRcdFx0XHRyZW5kZXJDdHgoc3RhbXAsIHRwbC5jaGlsZHJlbiwgY3R4MCwgMCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvYmxvY2tzL2Jsb2NrSWYuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBR0E7QUFDQTtBQUpBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!**************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockHtml.js ***!
  \**************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockHtml;\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nfunction blockHtml(stamp, tpl, ctx0, level) {\n\n\tif (tpl.attrs && tpl.attrs['value'] && tpl.attrs['value'].call) {\n\n\t\tvar value = tpl.attrs['value'];\n\t\tvar val2 = ctx0.expr(value);\n\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\n\t\t//remove old\n\t\tctx0.dispose();\n\n\t\tif (typeof val2 != 'undefined' && val2 != null) {\n\t\t\t//add new\n\t\t\tvar div = document.createElement('div');\n\t\t\tdiv.innerHTML = \"\" + val2;\n\t\t\tctx0.rootNodes = Array.prototype.slice.call(div.childNodes);\n\t\t\tfor (var i = 0; i < ctx0.rootNodes.length; i++) {\n\t\t\t\tstamp[0].insertBefore(ctx0.rootNodes[i], stamp[1]);\n\t\t\t}\n\t\t}\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tIdG1sLmpzP2Y1MWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW53cmFwIH0gIGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBibG9ja0h0bWwoc3RhbXAsIHRwbCwgY3R4MCwgbGV2ZWwpe1xyXG5cclxuXHRpZih0cGwuYXR0cnMgJiYgdHBsLmF0dHJzWyd2YWx1ZSddICYmIHRwbC5hdHRyc1sndmFsdWUnXS5jYWxsKXtcclxuXHRcdFxyXG5cdFx0dmFyIHZhbHVlID0gdHBsLmF0dHJzWyd2YWx1ZSddO1xyXG5cdFx0dmFyIHZhbDIgPSBjdHgwLmV4cHIodmFsdWUpO1xyXG5cdFx0dmFsMiA9IHVud3JhcCh2YWwyKTtcclxuXHJcblx0XHQvL3JlbW92ZSBvbGRcclxuXHRcdGN0eDAuZGlzcG9zZSgpO1xyXG5cclxuXHRcdGlmKHR5cGVvZih2YWwyKSAhPSAndW5kZWZpbmVkJyAmJiB2YWwyICE9IG51bGwpe1xyXG5cdFx0XHQvL2FkZCBuZXdcclxuXHRcdFx0Y29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiK3ZhbDI7XHJcblx0XHRcdGN0eDAucm9vdE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGl2LmNoaWxkTm9kZXMpO1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGN0eDAucm9vdE5vZGVzLmxlbmd0aDsgaSsrKSB7IFxyXG5cdFx0XHQgICAgc3RhbXBbMF0uaW5zZXJ0QmVmb3JlKGN0eDAucm9vdE5vZGVzW2ldLCBzdGFtcFsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2Jsb2Nrcy9ibG9ja0h0bWwuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7QUFDQTtBQUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/*!******************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockTemplate.js ***!
  \******************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockTemplate;\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 1);\n\nfunction blockTemplate(stamp, tpl, ctx0, level) {\n\n\tif (tpl.attrs && tpl.attrs['value'] && tpl.attrs['value'].call) {\n\n\t\tvar value = tpl.attrs['value'];\n\t\tvar val2 = ctx0.expr(value);\n\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\n\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\n\t\t\t//remove old template\n\t\t\tctx0.dispose();\n\n\t\t\tif (val2) {\n\t\t\t\t//render value tpl\n\t\t\t\t(0, _renderCtx.renderCtx)(stamp, val2, ctx0, 0);\n\t\t\t}\n\t\t});\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tUZW1wbGF0ZS5qcz85NTVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVud3JhcCwgZGVwZW5kZW5jeURldGVjdGlvbiB9ICBmcm9tICcuLi90a28vdGtvLm9ic2VydmFibGUuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJDdHggfSAgZnJvbSAnLi4vcmVuZGVyQ3R4LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsb2NrVGVtcGxhdGUoc3RhbXAsIHRwbCwgY3R4MCwgbGV2ZWwpe1xyXG5cclxuXHRpZih0cGwuYXR0cnMgJiYgdHBsLmF0dHJzWyd2YWx1ZSddICYmIHRwbC5hdHRyc1sndmFsdWUnXS5jYWxsKXtcclxuXHRcdFxyXG5cdFx0dmFyIHZhbHVlID0gdHBsLmF0dHJzWyd2YWx1ZSddO1xyXG5cdFx0dmFyIHZhbDIgPSBjdHgwLmV4cHIodmFsdWUpO1xyXG5cdFx0dmFsMiA9IHVud3JhcCh2YWwyKTtcclxuXHJcblx0XHRkZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShmdW5jdGlvbigpe1xyXG5cclxuXHRcdFx0Ly9yZW1vdmUgb2xkIHRlbXBsYXRlXHJcblx0XHRcdGN0eDAuZGlzcG9zZSgpO1xyXG5cclxuXHRcdFx0aWYodmFsMil7XHJcblx0XHRcdFx0Ly9yZW5kZXIgdmFsdWUgdHBsXHJcblx0XHRcdFx0cmVuZGVyQ3R4KHN0YW1wLCB2YWwyLCBjdHgwLCAwKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2Jsb2Nrcy9ibG9ja1RlbXBsYXRlLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUdBO0FBQ0E7QUFKQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/bindings/click.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nexports.default = {\n\tinit: function init(el, val) {\n\t\tval = (0, _tkoObservable.unwrap)(val);\n\t\tif (val.call) el.addEventListener(\"click\", val);\n\t}\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9iaW5kaW5ncy9jbGljay5qcz82OGE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVud3JhcCB9IGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdDogZnVuY3Rpb24oZWwsIHZhbCl7XHJcblx0XHR2YWwgPSB1bndyYXAodmFsKTtcclxuXHRcdGlmKHZhbC5jYWxsKSBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdmFsKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2JpbmRpbmdzL2NsaWNrLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n");

/***/ })
/******/ ]);