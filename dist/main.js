/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!****************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/tko/tko.observable.js ***!
  \****************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extenders = exports.applyExtenders = exports.valuesArePrimitiveAndEqual = exports.deferUpdates = exports.toJSON = exports.toJS = exports.arrayChangeEventName = exports.trackArrayChanges = exports.observableArray = exports.subscribable = exports.isSubscribable = exports.isWritableObservable = exports.isWriteableObservable = exports.peek = exports.unwrap = exports.isObservable = exports.observable = exports.dependencyDetection = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _tkoUtils = __webpack_require__(/*! ./tko.utils.js */ 1);\n\n//\n//  Defer Updates\n//  ===\n//\nfunction deferUpdates(target) {\n  if (!target._deferUpdates) {\n    target._deferUpdates = true;\n    target.limit(function (callback) {\n      var handle;\n      return function () {\n        tasks.cancel(handle);\n        handle = tasks.schedule(callback);\n        target.notifySubscribers(undefined, 'dirty');\n      };\n    });\n  }\n}\n\n//\n// Observable extenders\n// ---\n//\nvar primitiveTypes = {\n  'undefined': 1, 'boolean': 1, 'number': 1, 'string': 1\n};\n\nfunction valuesArePrimitiveAndEqual(a, b) {\n  var oldValueIsPrimitive = a === null || (typeof a === 'undefined' ? 'undefined' : _typeof(a)) in primitiveTypes;\n  return oldValueIsPrimitive ? a === b : false;\n}\n\nfunction applyExtenders(requestedExtenders) {\n  var target = this;\n  if (requestedExtenders) {\n    (0, _tkoUtils.objectForEach)(requestedExtenders, function (key, value) {\n      var extenderHandler = extenders[key];\n      if (typeof extenderHandler === 'function') {\n        target = extenderHandler(target, value) || target;\n      } else {\n        _tkoUtils.options.onError(new Error('Extender not found: ' + key));\n      }\n    });\n  }\n  return target;\n}\n\n/*\n                --- DEFAULT EXTENDERS ---\n */\n\n// Change when notifications are published.\nfunction notify(target, notifyWhen) {\n  target.equalityComparer = notifyWhen == 'always' ? null : // null equalityComparer means to always notify\n  valuesArePrimitiveAndEqual;\n}\n\nfunction deferred(target, option) {\n  if (option !== true) {\n    throw new Error('The \\'deferred\\' extender only accepts the value \\'true\\', because it is not supported to turn deferral off once enabled.');\n  }\n  deferUpdates(target);\n}\n\nfunction rateLimit(target, options$$1) {\n  var timeout, method, limitFunction;\n\n  if (typeof options$$1 === 'number') {\n    timeout = options$$1;\n  } else {\n    timeout = options$$1.timeout;\n    method = options$$1.method;\n  }\n\n  // rateLimit supersedes deferred updates\n  target._deferUpdates = false;\n\n  limitFunction = method == 'notifyWhenChangesStop' ? _tkoUtils.debounce : _tkoUtils.throttle;\n\n  target.limit(function (callback) {\n    return limitFunction(callback, timeout);\n  });\n}\n\nvar extenders = {\n  notify: notify,\n  deferred: deferred,\n  rateLimit: rateLimit\n};\n\n/* eslint no-cond-assign: 0 */\nfunction subscription(target, callback, disposeCallback) {\n  this._target = target;\n  this.callback = callback;\n  this.disposeCallback = disposeCallback;\n  this.isDisposed = false;\n  window.count++;\n}\n\nsubscription.prototype.dispose = function () {\n  this.isDisposed = true;\n  this.disposeCallback();\n  window.count--;\n};\n\nfunction subscribable() {\n  (0, _tkoUtils.setPrototypeOfOrExtend)(this, ko_subscribable_fn);\n  ko_subscribable_fn.init(this);\n}\n\nvar defaultEvent = 'change';\n\nvar ko_subscribable_fn = {\n  init: function init(instance) {\n    instance._subscriptions = {};\n    instance._versionNumber = 1;\n  },\n  subscribe: function subscribe(callback, callbackTarget, event) {\n    var self = this;\n\n    event = event || defaultEvent;\n    var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;\n\n    var subscriptionInstance = new subscription(self, boundCallback, function () {\n      (0, _tkoUtils.arrayRemoveItem)(self._subscriptions[event], subscriptionInstance);\n      if (self.afterSubscriptionRemove) {\n        self.afterSubscriptionRemove(event);\n      }\n    });\n\n    if (self.beforeSubscriptionAdd) {\n      self.beforeSubscriptionAdd(event);\n    }\n\n    if (!self._subscriptions[event]) {\n      self._subscriptions[event] = [];\n    }\n    self._subscriptions[event].push(subscriptionInstance);\n\n    return subscriptionInstance;\n  },\n  notifySubscribers: function notifySubscribers(valueToNotify, event) {\n    event = event || defaultEvent;\n    if (event === defaultEvent) {\n      this.updateVersion();\n    }\n    if (this.hasSubscriptionsForEvent(event)) {\n      try {\n        begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)\n        for (var a = this._subscriptions[event].slice(0), i = 0, subscriptionInstance; subscriptionInstance = a[i]; ++i) {\n          // In case a subscription was disposed during the arrayForEach cycle, check\n          // for isDisposed on each subscription before invoking its callback\n          if (!subscriptionInstance.isDisposed) {\n            subscriptionInstance.callback(valueToNotify);\n          }\n        }\n      } finally {\n        end(); // End suppressing dependency detection\n      }\n    }\n  },\n  getVersion: function getVersion() {\n    return this._versionNumber;\n  },\n  hasChanged: function hasChanged(versionToCheck) {\n    return this.getVersion() !== versionToCheck;\n  },\n  updateVersion: function updateVersion() {\n    ++this._versionNumber;\n  },\n  hasSubscriptionsForEvent: function hasSubscriptionsForEvent(event) {\n    return this._subscriptions[event] && this._subscriptions[event].length;\n  },\n  getSubscriptionsCount: function getSubscriptionsCount(event) {\n    if (event) {\n      return this._subscriptions[event] && this._subscriptions[event].length || 0;\n    } else {\n      var total = 0;\n      (0, _tkoUtils.objectForEach)(this._subscriptions, function (eventName, subscriptions) {\n        if (eventName !== 'dirty') {\n          total += subscriptions.length;\n        }\n      });\n      return total;\n    }\n  },\n  isDifferent: function isDifferent(oldValue, newValue) {\n    return !this.equalityComparer || !this.equalityComparer(oldValue, newValue);\n  },\n  once: function once(cb) {\n    var subs = this.subscribe(function (nv) {\n      subs.dispose();\n      cb(nv);\n    });\n  },\n  when: function when(test, returnValue) {\n    var _this = this;\n\n    var current = this.peek();\n    var givenRv = arguments.length > 1;\n    var testFn = typeof test === 'function' ? test : function (v) {\n      return v === test;\n    };\n    if (testFn(current)) {\n      return _tkoUtils.options.Promise.resolve(givenRv ? returnValue : current);\n    }\n    return new _tkoUtils.options.Promise(function (resolve, reject) {\n      var subs = _this.subscribe(function (newValue) {\n        if (testFn(newValue)) {\n          subs.dispose();\n          resolve(givenRv ? returnValue : newValue);\n        }\n      });\n    });\n  },\n  yet: function yet(test) {\n    var testFn = typeof test === 'function' ? test : function (v) {\n      return v === test;\n    };\n    var negated = function negated(v) {\n      return !testFn(v);\n    };\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return this.when.apply(this, [negated].concat(args));\n  },\n  next: function next() {\n    var _this2 = this;\n\n    return new Promise(function (resolve) {\n      return _this2.once(resolve);\n    });\n  },\n\n\n  extend: applyExtenders\n};\n\n// For browsers that support proto assignment, we overwrite the prototype of each\n// observable instance. Since observables are functions, we need Function.prototype\n// to still be in the prototype chain.\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(ko_subscribable_fn, Function.prototype);\n}\n\nsubscribable.fn = ko_subscribable_fn;\n\nfunction isSubscribable(instance) {\n  return instance != null && typeof instance.subscribe === 'function' && typeof instance.notifySubscribers === 'function';\n}\n\n//\n// dependencyDetection\n// ---\n//\n// In KO 3.x, dependencyDetection was also known as computedContext.\n//\nvar outerFrames = [];\nvar currentFrame = void 0;\nvar lastId = 0;\n\n// Return a unique ID that can be assigned to an observable for dependency tracking.\n// Theoretically, you could eventually overflow the number storage size, resulting\n// in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53\n// or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would\n// take over 285 years to reach that number.\n// Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html\nfunction getId() {\n  return ++lastId;\n}\n\nfunction begin(options$$1) {\n  outerFrames.push(currentFrame);\n  currentFrame = options$$1;\n}\n\nfunction end() {\n  currentFrame = outerFrames.pop();\n}\n\nfunction registerDependency(subscribable$$1) {\n  if (currentFrame) {\n    if (!isSubscribable(subscribable$$1)) {\n      throw new Error('Only subscribable things can act as dependencies');\n    }\n    currentFrame.callback.call(currentFrame.callbackTarget, subscribable$$1, subscribable$$1._id || (subscribable$$1._id = getId()));\n  }\n}\n\nfunction ignore(callback, callbackTarget, callbackArgs) {\n  try {\n    begin();\n    return callback.apply(callbackTarget, callbackArgs || []);\n  } finally {\n    end();\n  }\n}\n\nfunction getDependenciesCount() {\n  if (currentFrame) {\n    return currentFrame.computed.getDependenciesCount();\n  }\n}\n\nfunction isInitial() {\n  if (currentFrame) {\n    return currentFrame.isInitial;\n  }\n}\n\nvar dependencyDetection = Object.freeze({\n  begin: begin,\n  end: end,\n  registerDependency: registerDependency,\n  ignore: ignore,\n  getDependenciesCount: getDependenciesCount,\n  isInitial: isInitial,\n  ignoreDependencies: ignore\n});\n\n//\n//  Observable values\n//  ---\n//\nvar observableLatestValue = (0, _tkoUtils.createSymbolOrString)('_latestValue');\n\nfunction observable(initialValue) {\n  function Observable() {\n    if (arguments.length > 0) {\n      // Write\n      // Ignore writes if the value hasn't changed\n      if (Observable.isDifferent(Observable[observableLatestValue], arguments[0])) {\n        Observable.valueWillMutate();\n        Observable[observableLatestValue] = arguments[0];\n        Observable.valueHasMutated();\n      }\n      return this; // Permits chained assignments\n    } else {\n      // Read\n      registerDependency(Observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n      return Observable[observableLatestValue];\n    }\n  }\n\n  Observable[observableLatestValue] = initialValue;\n\n  // Inherit from 'subscribable'\n  if (!_tkoUtils.canSetPrototype) {\n    // 'subscribable' won't be on the prototype chain unless we put it there directly\n    (0, _tkoUtils.extend)(Observable, subscribable.fn);\n  }\n  subscribable.fn.init(Observable);\n\n  // Inherit from 'observable'\n  (0, _tkoUtils.setPrototypeOfOrExtend)(Observable, observable.fn);\n\n  if (_tkoUtils.options.deferUpdates) {\n    deferUpdates(Observable);\n  }\n\n  return Observable;\n}\n\n// Define prototype for observables\nobservable.fn = {\n  equalityComparer: valuesArePrimitiveAndEqual,\n  peek: function peek() {\n    return this[observableLatestValue];\n  },\n  valueHasMutated: function valueHasMutated() {\n    this.notifySubscribers(this[observableLatestValue]);\n  },\n  valueWillMutate: function valueWillMutate() {\n    this.notifySubscribers(this[observableLatestValue], 'beforeChange');\n  },\n  then: function then(res, rej) {\n    try {\n      res(this());\n    } catch (e) {\n      rej(e);\n    }\n  }\n};\n\n// Moved out of \"limit\" to avoid the extra closure\nfunction limitNotifySubscribers(value, event) {\n  if (!event || event === defaultEvent) {\n    this._limitChange(value);\n  } else if (event === 'beforeChange') {\n    this._limitBeforeChange(value);\n  } else {\n    this._origNotifySubscribers(value, event);\n  }\n}\n\n// Add `limit` function to the subscribable prototype\nsubscribable.fn.limit = function limit(limitFunction) {\n  var self = this;\n  var selfIsObservable = isObservable(self);\n  var beforeChange = 'beforeChange';\n  var ignoreBeforeChange, previousValue, pendingValue;\n\n  if (!self._origNotifySubscribers) {\n    self._origNotifySubscribers = self.notifySubscribers;\n    self.notifySubscribers = limitNotifySubscribers;\n  }\n\n  var finish = limitFunction(function () {\n    self._notificationIsPending = false;\n\n    // If an observable provided a reference to itself, access it to get the latest value.\n    // This allows computed observables to delay calculating their value until needed.\n    if (selfIsObservable && pendingValue === self) {\n      pendingValue = self();\n    }\n    ignoreBeforeChange = false;\n    if (self.isDifferent(previousValue, pendingValue)) {\n      self._origNotifySubscribers(previousValue = pendingValue);\n    }\n  });\n\n  self._limitChange = function (value) {\n    self._notificationIsPending = ignoreBeforeChange = true;\n    pendingValue = value;\n    finish();\n  };\n  self._limitBeforeChange = function (value) {\n    if (!ignoreBeforeChange) {\n      previousValue = value;\n      self._origNotifySubscribers(value, beforeChange);\n    }\n  };\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the observable constructor\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(observable.fn, subscribable.fn);\n}\n\nvar protoProperty = observable.protoProperty = _tkoUtils.options.protoProperty;\nobservable.fn[protoProperty] = observable;\n\nfunction isObservable(instance) {\n  return (0, _tkoUtils.hasPrototype)(instance, observable);\n}\n\nfunction unwrap(value) {\n  return isObservable(value) ? value() : value;\n}\n\nfunction peek(value) {\n  return isObservable(value) ? value.peek() : value;\n}\n\nfunction isWriteableObservable(instance) {\n  // Observable\n  if (typeof instance === 'function' && instance[protoProperty] === observable) {\n    return true;\n  }\n  // Writeable dependent observable\n  if (typeof instance === 'function' && /* && (instance[protoProperty] === ko.dependentObservable) */instance.hasWriteFunction) {\n    return true;\n  }\n  // Anything else\n  return false;\n}\n\n//\n// Observable Array - Change Tracking Extender\n// ---\n//\n/* eslint no-fallthrough: 0*/\n\nvar arrayChangeEventName = 'arrayChange';\n\nfunction trackArrayChanges(target, options$$1) {\n  // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n  target.compareArrayOptions = {};\n  if (options$$1 && (typeof options$$1 === 'undefined' ? 'undefined' : _typeof(options$$1)) == \"object\") {\n    (0, _tkoUtils.extend)(target.compareArrayOptions, options$$1);\n  }\n  target.compareArrayOptions.sparse = true;\n\n  // Only modify the target observable once\n  if (target.cacheDiffForKnownOperation) {\n    return;\n  }\n  var trackingChanges = false,\n      cachedDiff = null,\n      arrayChangeSubscription,\n      pendingNotifications = 0,\n      underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,\n      underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n  // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n  target.beforeSubscriptionAdd = function (event) {\n    if (underlyingBeforeSubscriptionAddFunction) underlyingBeforeSubscriptionAddFunction.call(target, event);\n    if (event === arrayChangeEventName) {\n      trackChanges();\n    }\n  };\n\n  // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n  target.afterSubscriptionRemove = function (event) {\n    if (underlyingAfterSubscriptionRemoveFunction) underlyingAfterSubscriptionRemoveFunction.call(target, event);\n    if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n      if (arrayChangeSubscription) {\n        arrayChangeSubscription.dispose();\n      }\n      arrayChangeSubscription = null;\n      trackingChanges = false;\n    }\n  };\n\n  function trackChanges() {\n    // Calling 'trackChanges' multiple times is the same as calling it once\n    if (trackingChanges) {\n      return;\n    }\n\n    trackingChanges = true;\n\n    // Intercept \"notifySubscribers\" to track how many times it was called.\n    var underlyingNotifySubscribersFunction = target['notifySubscribers'];\n    target['notifySubscribers'] = function (valueToNotify, event) {\n      if (!event || event === defaultEvent) {\n        ++pendingNotifications;\n      }\n      return underlyingNotifySubscribersFunction.apply(this, arguments);\n    };\n\n    // Each time the array changes value, capture a clone so that on the next\n    // change it's possible to produce a diff\n    var previousContents = [].concat(target.peek() || []);\n    cachedDiff = null;\n    arrayChangeSubscription = target.subscribe(function (currentContents) {\n      // Make a copy of the current contents and ensure it's an array\n      currentContents = [].concat(currentContents || []);\n\n      // Compute the diff and issue notifications, but only if someone is listening\n      if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n        var changes = getChanges(previousContents, currentContents);\n      }\n\n      // Eliminate references to the old, removed items, so they can be GCed\n      previousContents = currentContents;\n      cachedDiff = null;\n      pendingNotifications = 0;\n\n      if (changes && changes.length) {\n        target['notifySubscribers'](changes, arrayChangeEventName);\n      }\n    });\n  }\n\n  function getChanges(previousContents, currentContents) {\n    // We try to re-use cached diffs.\n    // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n    // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n    // notifications are issued immediately so we wouldn't be queueing up more than one.\n    if (!cachedDiff || pendingNotifications > 1) {\n      cachedDiff = trackArrayChanges.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n    }\n\n    return cachedDiff;\n  }\n\n  target.cacheDiffForKnownOperation = function (rawArray, operationName, args) {\n    var index, argsIndex;\n    // Only run if we're currently tracking changes for this observable array\n    // and there aren't any pending deferred notifications.\n    if (!trackingChanges || pendingNotifications) {\n      return;\n    }\n    var diff = [],\n        arrayLength = rawArray.length,\n        argsLength = args.length,\n        offset = 0;\n\n    function pushDiff(status, value, index) {\n      return diff[diff.length] = { 'status': status, 'value': value, 'index': index };\n    }\n    switch (operationName) {\n      case 'push':\n        offset = arrayLength;\n      case 'unshift':\n        for (index = 0; index < argsLength; index++) {\n          pushDiff('added', args[index], offset + index);\n        }\n        break;\n\n      case 'pop':\n        offset = arrayLength - 1;\n      case 'shift':\n        if (arrayLength) {\n          pushDiff('deleted', rawArray[offset], offset);\n        }\n        break;\n\n      case 'splice':\n        // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n            endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n            endAddIndex = startIndex + argsLength - 2,\n            endIndex = Math.max(endDeleteIndex, endAddIndex),\n            additions = [],\n            deletions = [];\n        for (index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n          if (index < endDeleteIndex) deletions.push(pushDiff('deleted', rawArray[index], index));\n          if (index < endAddIndex) additions.push(pushDiff('added', args[argsIndex], index));\n        }\n        (0, _tkoUtils.findMovesInArrayComparison)(deletions, additions);\n        break;\n\n      default:\n        return;\n    }\n    cachedDiff = diff;\n  };\n}\n\n// Expose compareArrays for testing.\ntrackArrayChanges.compareArrays = _tkoUtils.compareArrays;\n\n// Add the trackArrayChanges extender so we can use\n// obs.extend({ trackArrayChanges: true })\nextenders.trackArrayChanges = trackArrayChanges;\n\n//\n// Observable Arrays\n// ===\n//\nfunction observableArray(initialValues) {\n  initialValues = initialValues || [];\n\n  if ((typeof initialValues === 'undefined' ? 'undefined' : _typeof(initialValues)) !== 'object' || !('length' in initialValues)) {\n    throw new Error('The argument passed when initializing an observable array must be an array, or null, or undefined.');\n  }\n\n  var result = observable(initialValues);\n  (0, _tkoUtils.setPrototypeOfOrExtend)(result, observableArray.fn);\n  trackArrayChanges(result);\n  // ^== result.extend({ trackArrayChanges: true })\n  return result;\n}\n\nobservableArray.fn = {\n  remove: function remove(valueOrPredicate) {\n    var underlyingArray = this.peek();\n    var removedValues = [];\n    var predicate = typeof valueOrPredicate === 'function' && !isObservable(valueOrPredicate) ? valueOrPredicate : function (value) {\n      return value === valueOrPredicate;\n    };\n    for (var i = 0; i < underlyingArray.length; i++) {\n      var value = underlyingArray[i];\n      if (predicate(value)) {\n        if (removedValues.length === 0) {\n          this.valueWillMutate();\n        }\n        removedValues.push(value);\n        underlyingArray.splice(i, 1);\n        i--;\n      }\n    }\n    if (removedValues.length) {\n      this.valueHasMutated();\n    }\n    return removedValues;\n  },\n\n  removeAll: function removeAll(arrayOfValues) {\n    // If you passed zero args, we remove everything\n    if (arrayOfValues === undefined) {\n      var underlyingArray = this.peek();\n      var allValues = underlyingArray.slice(0);\n      this.valueWillMutate();\n      underlyingArray.splice(0, underlyingArray.length);\n      this.valueHasMutated();\n      return allValues;\n    }\n    // If you passed an arg, we interpret it as an array of entries to remove\n    if (!arrayOfValues) {\n      return [];\n    }\n    return this['remove'](function (value) {\n      return (0, _tkoUtils.arrayIndexOf)(arrayOfValues, value) >= 0;\n    });\n  },\n\n  destroy: function destroy(valueOrPredicate) {\n    var underlyingArray = this.peek();\n    var predicate = typeof valueOrPredicate === 'function' && !isObservable(valueOrPredicate) ? valueOrPredicate : function (value) {\n      return value === valueOrPredicate;\n    };\n    this.valueWillMutate();\n    for (var i = underlyingArray.length - 1; i >= 0; i--) {\n      var value = underlyingArray[i];\n      if (predicate(value)) {\n        underlyingArray[i]['_destroy'] = true;\n      }\n    }\n    this.valueHasMutated();\n  },\n\n  destroyAll: function destroyAll(arrayOfValues) {\n    // If you passed zero args, we destroy everything\n    if (arrayOfValues === undefined) {\n      return this.destroy(function () {\n        return true;\n      });\n    }\n\n    // If you passed an arg, we interpret it as an array of entries to destroy\n    if (!arrayOfValues) {\n      return [];\n    }\n    return this.destroy(function (value) {\n      return (0, _tkoUtils.arrayIndexOf)(arrayOfValues, value) >= 0;\n    });\n  },\n\n  indexOf: function indexOf(item) {\n    var underlyingArray = this();\n    return (0, _tkoUtils.arrayIndexOf)(underlyingArray, item);\n  },\n\n  replace: function replace(oldItem, newItem) {\n    var index = this.indexOf(oldItem);\n    if (index >= 0) {\n      this.valueWillMutate();\n      this.peek()[index] = newItem;\n      this.valueHasMutated();\n    }\n  }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observableArray constructor\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(observableArray.fn, observable.fn);\n}\n\n// Populate ko.observableArray.fn with read/write functions from native arrays\n// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array\n// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale\n(0, _tkoUtils.arrayForEach)(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {\n  observableArray.fn[methodName] = function () {\n    // Use \"peek\" to avoid creating a subscription in any computed that we're executing in the context of\n    // (for consistency with mutating regular observables)\n    var underlyingArray = this.peek();\n    this.valueWillMutate();\n    this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n    var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n    this.valueHasMutated();\n    // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.\n    return methodCallResult === underlyingArray ? this : methodCallResult;\n  };\n});\n\n// Populate ko.observableArray.fn with read-only functions from native arrays\n(0, _tkoUtils.arrayForEach)(['slice'], function (methodName) {\n  observableArray.fn[methodName] = function () {\n    var underlyingArray = this();\n    return underlyingArray[methodName].apply(underlyingArray, arguments);\n  };\n});\n\n//\n// Helpers\n// ---\n// toJS & toJSON\n//\nvar maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)\n\nfunction toJS(rootObject) {\n  if (arguments.length == 0) throw new Error(\"When calling ko.toJS, pass the object you want to convert.\");\n\n  // We just unwrap everything at every level in the object graph\n  return mapJsObjectGraph(rootObject, function (valueToMap) {\n    // Loop because an observable's value might in turn be another observable wrapper\n    for (var i = 0; isObservable(valueToMap) && i < maxNestedObservableDepth; i++) {\n      valueToMap = valueToMap();\n    }return valueToMap;\n  });\n}\n\nfunction toJSON(rootObject, replacer, space) {\n  // replacer and space are optional\n  var plainJavaScriptObject = toJS(rootObject);\n  return (0, _tkoUtils.stringifyJson)(plainJavaScriptObject, replacer, space);\n}\n\nfunction mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {\n  visitedObjects = visitedObjects || new objectLookup();\n\n  rootObject = mapInputCallback(rootObject);\n  var canHaveProperties = (typeof rootObject === 'undefined' ? 'undefined' : _typeof(rootObject)) == \"object\" && rootObject !== null && rootObject !== undefined && !(rootObject instanceof RegExp) && !(rootObject instanceof Date) && !(rootObject instanceof String) && !(rootObject instanceof Number) && !(rootObject instanceof Boolean);\n  if (!canHaveProperties) return rootObject;\n\n  var outputProperties = rootObject instanceof Array ? [] : {};\n  visitedObjects.save(rootObject, outputProperties);\n\n  visitPropertiesOrArrayEntries(rootObject, function (indexer) {\n    var propertyValue = mapInputCallback(rootObject[indexer]);\n\n    switch (typeof propertyValue === 'undefined' ? 'undefined' : _typeof(propertyValue)) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n      case \"function\":\n        outputProperties[indexer] = propertyValue;\n        break;\n      case \"object\":\n      case \"undefined\":\n        var previouslyMappedValue = visitedObjects.get(propertyValue);\n        outputProperties[indexer] = previouslyMappedValue !== undefined ? previouslyMappedValue : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n        break;\n    }\n  });\n\n  return outputProperties;\n}\n\nfunction visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n  if (rootObject instanceof Array) {\n    for (var i = 0; i < rootObject.length; i++) {\n      visitorCallback(i);\n    } // For arrays, also respect toJSON property for custom mappings (fixes #278)\n    if (typeof rootObject['toJSON'] == 'function') visitorCallback('toJSON');\n  } else {\n    for (var propertyName in rootObject) {\n      visitorCallback(propertyName);\n    }\n  }\n}\n\nfunction objectLookup() {\n  this.keys = [];\n  this.values = [];\n}\n\nobjectLookup.prototype = {\n  constructor: objectLookup,\n  save: function save(key, value) {\n    var existingIndex = (0, _tkoUtils.arrayIndexOf)(this.keys, key);\n    if (existingIndex >= 0) this.values[existingIndex] = value;else {\n      this.keys.push(key);\n      this.values.push(value);\n    }\n  },\n  get: function get(key) {\n    var existingIndex = (0, _tkoUtils.arrayIndexOf)(this.keys, key);\n    return existingIndex >= 0 ? this.values[existingIndex] : undefined;\n  }\n};\n\n//\n// Observables.\n// ---\n//\n// The following are added to the root `[t]ko` object.\n//\n\nexports.dependencyDetection = dependencyDetection;\nexports.observable = observable;\nexports.isObservable = isObservable;\nexports.unwrap = unwrap;\nexports.peek = peek;\nexports.isWriteableObservable = isWriteableObservable;\nexports.isWritableObservable = isWriteableObservable;\nexports.isSubscribable = isSubscribable;\nexports.subscribable = subscribable;\nexports.observableArray = observableArray;\nexports.trackArrayChanges = trackArrayChanges;\nexports.arrayChangeEventName = arrayChangeEventName;\nexports.toJS = toJS;\nexports.toJSON = toJSON;\nexports.deferUpdates = deferUpdates;\nexports.valuesArePrimitiveAndEqual = valuesArePrimitiveAndEqual;\nexports.applyExtenders = applyExtenders;\nexports.extenders = extenders;\n//# sourceMappingURL=tko.observable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28ub2JzZXJ2YWJsZS5qcz82MzdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycmF5Rm9yRWFjaCwgYXJyYXlJbmRleE9mLCBhcnJheVJlbW92ZUl0ZW0sIGNhblNldFByb3RvdHlwZSwgY29tcGFyZUFycmF5cywgY3JlYXRlU3ltYm9sT3JTdHJpbmcsIGRlYm91bmNlLCBleHRlbmQsIGZpbmRNb3Zlc0luQXJyYXlDb21wYXJpc29uLCBoYXNQcm90b3R5cGUsIG9iamVjdEZvckVhY2gsIG9wdGlvbnMsIHNldFByb3RvdHlwZU9mLCBzZXRQcm90b3R5cGVPZk9yRXh0ZW5kLCBzdHJpbmdpZnlKc29uLCB0aHJvdHRsZSB9IGZyb20gJy4vdGtvLnV0aWxzLmpzJztcblxuLy9cbi8vICBEZWZlciBVcGRhdGVzXG4vLyAgPT09XG4vL1xuZnVuY3Rpb24gZGVmZXJVcGRhdGVzKHRhcmdldCkge1xuICAgIGlmICghdGFyZ2V0Ll9kZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgdGFyZ2V0Ll9kZWZlclVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB0YXJnZXQubGltaXQoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0YXNrcy5jYW5jZWwoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSB0YXNrcy5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm5vdGlmeVN1YnNjcmliZXJzKHVuZGVmaW5lZCwgJ2RpcnR5Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vXG4vLyBPYnNlcnZhYmxlIGV4dGVuZGVyc1xuLy8gLS0tXG4vL1xudmFyIHByaW1pdGl2ZVR5cGVzID0ge1xuICAndW5kZWZpbmVkJzogMSwgJ2Jvb2xlYW4nOiAxLCAnbnVtYmVyJzogMSwgJ3N0cmluZyc6IDFcbn07XG5cbmZ1bmN0aW9uIHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsIChhLCBiKSB7XG4gIHZhciBvbGRWYWx1ZUlzUHJpbWl0aXZlID0gKGEgPT09IG51bGwpIHx8ICh0eXBlb2YgKGEpIGluIHByaW1pdGl2ZVR5cGVzKTtcbiAgcmV0dXJuIG9sZFZhbHVlSXNQcmltaXRpdmUgPyAoYSA9PT0gYikgOiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhcHBseUV4dGVuZGVycyAocmVxdWVzdGVkRXh0ZW5kZXJzKSB7XG4gIHZhciB0YXJnZXQgPSB0aGlzO1xuICBpZiAocmVxdWVzdGVkRXh0ZW5kZXJzKSB7XG4gICAgb2JqZWN0Rm9yRWFjaChyZXF1ZXN0ZWRFeHRlbmRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZXh0ZW5kZXJIYW5kbGVyID0gZXh0ZW5kZXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGV4dGVuZGVySGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0YXJnZXQgPSBleHRlbmRlckhhbmRsZXIodGFyZ2V0LCB2YWx1ZSkgfHwgdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5vbkVycm9yKG5ldyBFcnJvcignRXh0ZW5kZXIgbm90IGZvdW5kOiAnICsga2V5KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKlxuICAgICAgICAgICAgICAgIC0tLSBERUZBVUxUIEVYVEVOREVSUyAtLS1cbiAqL1xuXG4vLyBDaGFuZ2Ugd2hlbiBub3RpZmljYXRpb25zIGFyZSBwdWJsaXNoZWQuXG5mdW5jdGlvbiBub3RpZnkgKHRhcmdldCwgbm90aWZ5V2hlbikge1xuICB0YXJnZXQuZXF1YWxpdHlDb21wYXJlciA9IG5vdGlmeVdoZW4gPT0gJ2Fsd2F5cycgP1xuICAgICAgICBudWxsIDogIC8vIG51bGwgZXF1YWxpdHlDb21wYXJlciBtZWFucyB0byBhbHdheXMgbm90aWZ5XG4gICAgICAgIHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsO1xufVxuXG5mdW5jdGlvbiBkZWZlcnJlZCAodGFyZ2V0LCBvcHRpb24pIHtcbiAgaWYgKG9wdGlvbiAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIFxcJ2RlZmVycmVkXFwnIGV4dGVuZGVyIG9ubHkgYWNjZXB0cyB0aGUgdmFsdWUgXFwndHJ1ZVxcJywgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHR1cm4gZGVmZXJyYWwgb2ZmIG9uY2UgZW5hYmxlZC4nKVxuICB9XG4gIGRlZmVyVXBkYXRlcyh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiByYXRlTGltaXQgKHRhcmdldCwgb3B0aW9ucyQkMSkge1xuICB2YXIgdGltZW91dCwgbWV0aG9kLCBsaW1pdEZ1bmN0aW9uO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyQkMSA9PT0gJ251bWJlcicpIHtcbiAgICB0aW1lb3V0ID0gb3B0aW9ucyQkMTtcbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gb3B0aW9ucyQkMS50aW1lb3V0O1xuICAgIG1ldGhvZCA9IG9wdGlvbnMkJDEubWV0aG9kO1xuICB9XG5cbiAgICAvLyByYXRlTGltaXQgc3VwZXJzZWRlcyBkZWZlcnJlZCB1cGRhdGVzXG4gIHRhcmdldC5fZGVmZXJVcGRhdGVzID0gZmFsc2U7XG5cbiAgbGltaXRGdW5jdGlvbiA9IG1ldGhvZCA9PSAnbm90aWZ5V2hlbkNoYW5nZXNTdG9wJyA/IGRlYm91bmNlIDogdGhyb3R0bGU7XG5cbiAgdGFyZ2V0LmxpbWl0KGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiBsaW1pdEZ1bmN0aW9uKGNhbGxiYWNrLCB0aW1lb3V0KVxuICB9KTtcbn1cblxudmFyIGV4dGVuZGVycyA9IHtcbiAgbm90aWZ5OiBub3RpZnksXG4gIGRlZmVycmVkOiBkZWZlcnJlZCxcbiAgcmF0ZUxpbWl0OiByYXRlTGltaXRcbn07XG5cbi8qIGVzbGludCBuby1jb25kLWFzc2lnbjogMCAqL1xuZnVuY3Rpb24gc3Vic2NyaXB0aW9uICh0YXJnZXQsIGNhbGxiYWNrLCBkaXNwb3NlQ2FsbGJhY2spIHtcbiAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuZGlzcG9zZUNhbGxiYWNrID0gZGlzcG9zZUNhbGxiYWNrO1xuICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgd2luZG93LmNvdW50Kys7XG59XG5cbnN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgdGhpcy5kaXNwb3NlQ2FsbGJhY2soKTtcbiAgd2luZG93LmNvdW50LS07XG59O1xuXG5mdW5jdGlvbiBzdWJzY3JpYmFibGUgKCkge1xuICBzZXRQcm90b3R5cGVPZk9yRXh0ZW5kKHRoaXMsIGtvX3N1YnNjcmliYWJsZV9mbik7XG4gIGtvX3N1YnNjcmliYWJsZV9mbi5pbml0KHRoaXMpO1xufVxuXG52YXIgZGVmYXVsdEV2ZW50ID0gJ2NoYW5nZSc7XG5cbnZhciBrb19zdWJzY3JpYmFibGVfZm4gPSB7XG4gIGluaXQgKGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UuX3N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICBpbnN0YW5jZS5fdmVyc2lvbk51bWJlciA9IDE7XG4gIH0sXG5cbiAgc3Vic2NyaWJlIChjYWxsYmFjaywgY2FsbGJhY2tUYXJnZXQsIGV2ZW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZXZlbnQgPSBldmVudCB8fCBkZWZhdWx0RXZlbnQ7XG4gICAgdmFyIGJvdW5kQ2FsbGJhY2sgPSBjYWxsYmFja1RhcmdldCA/IGNhbGxiYWNrLmJpbmQoY2FsbGJhY2tUYXJnZXQpIDogY2FsbGJhY2s7XG5cbiAgICB2YXIgc3Vic2NyaXB0aW9uSW5zdGFuY2UgPSBuZXcgc3Vic2NyaXB0aW9uKHNlbGYsIGJvdW5kQ2FsbGJhY2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFycmF5UmVtb3ZlSXRlbShzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XSwgc3Vic2NyaXB0aW9uSW5zdGFuY2UpO1xuICAgICAgaWYgKHNlbGYuYWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmUpIHtcbiAgICAgICAgc2VsZi5hZnRlclN1YnNjcmlwdGlvblJlbW92ZShldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZi5iZWZvcmVTdWJzY3JpcHRpb25BZGQpIHtcbiAgICAgIHNlbGYuYmVmb3JlU3Vic2NyaXB0aW9uQWRkKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYuX3N1YnNjcmlwdGlvbnNbZXZlbnRdKSB7XG4gICAgICBzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICBzZWxmLl9zdWJzY3JpcHRpb25zW2V2ZW50XS5wdXNoKHN1YnNjcmlwdGlvbkluc3RhbmNlKTtcblxuICAgIHJldHVybiBzdWJzY3JpcHRpb25JbnN0YW5jZVxuICB9LFxuXG4gIG5vdGlmeVN1YnNjcmliZXJzICh2YWx1ZVRvTm90aWZ5LCBldmVudCkge1xuICAgIGV2ZW50ID0gZXZlbnQgfHwgZGVmYXVsdEV2ZW50O1xuICAgIGlmIChldmVudCA9PT0gZGVmYXVsdEV2ZW50KSB7XG4gICAgICB0aGlzLnVwZGF0ZVZlcnNpb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzU3Vic2NyaXB0aW9uc0ZvckV2ZW50KGV2ZW50KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmVnaW4oKTsgLy8gQmVnaW4gc3VwcHJlc3NpbmcgZGVwZW5kZW5jeSBkZXRlY3Rpb24gKGJ5IHNldHRpbmcgdGhlIHRvcCBmcmFtZSB0byB1bmRlZmluZWQpXG4gICAgICAgIGZvciAodmFyIGEgPSB0aGlzLl9zdWJzY3JpcHRpb25zW2V2ZW50XS5zbGljZSgwKSwgaSA9IDAsIHN1YnNjcmlwdGlvbkluc3RhbmNlOyBzdWJzY3JpcHRpb25JbnN0YW5jZSA9IGFbaV07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGEgc3Vic2NyaXB0aW9uIHdhcyBkaXNwb3NlZCBkdXJpbmcgdGhlIGFycmF5Rm9yRWFjaCBjeWNsZSwgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGlzRGlzcG9zZWQgb24gZWFjaCBzdWJzY3JpcHRpb24gYmVmb3JlIGludm9raW5nIGl0cyBjYWxsYmFja1xuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uSW5zdGFuY2UuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uSW5zdGFuY2UuY2FsbGJhY2sodmFsdWVUb05vdGlmeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBlbmQoKTsgLy8gRW5kIHN1cHByZXNzaW5nIGRlcGVuZGVuY3kgZGV0ZWN0aW9uXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldFZlcnNpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJzaW9uTnVtYmVyXG4gIH0sXG5cbiAgaGFzQ2hhbmdlZCAodmVyc2lvblRvQ2hlY2spIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWZXJzaW9uKCkgIT09IHZlcnNpb25Ub0NoZWNrXG4gIH0sXG5cbiAgdXBkYXRlVmVyc2lvbiAoKSB7XG4gICAgKyt0aGlzLl92ZXJzaW9uTnVtYmVyO1xuICB9LFxuXG4gIGhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudCAoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0gJiYgdGhpcy5fc3Vic2NyaXB0aW9uc1tldmVudF0ubGVuZ3RoXG4gIH0sXG5cbiAgZ2V0U3Vic2NyaXB0aW9uc0NvdW50IChldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdICYmIHRoaXMuX3N1YnNjcmlwdGlvbnNbZXZlbnRdLmxlbmd0aCB8fCAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICBvYmplY3RGb3JFYWNoKHRoaXMuX3N1YnNjcmlwdGlvbnMsIGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ2RpcnR5Jykge1xuICAgICAgICAgIHRvdGFsICs9IHN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0b3RhbFxuICAgIH1cbiAgfSxcblxuICBpc0RpZmZlcmVudCAob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuICF0aGlzLmVxdWFsaXR5Q29tcGFyZXIgfHxcbiAgICAgICAgICAgICAgICF0aGlzLmVxdWFsaXR5Q29tcGFyZXIob2xkVmFsdWUsIG5ld1ZhbHVlKVxuICB9LFxuXG4gIG9uY2UgKGNiKSB7XG4gICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vic2NyaWJlKChudikgPT4ge1xuICAgICAgc3Vicy5kaXNwb3NlKCk7XG4gICAgICBjYihudik7XG4gICAgfSk7XG4gIH0sXG5cbiAgd2hlbiAodGVzdCwgcmV0dXJuVmFsdWUpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5wZWVrKCk7XG4gICAgY29uc3QgZ2l2ZW5SdiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxO1xuICAgIGNvbnN0IHRlc3RGbiA9IHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nID8gdGVzdCA6IHYgPT4gdiA9PT0gdGVzdDtcbiAgICBpZiAodGVzdEZuKGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5Qcm9taXNlLnJlc29sdmUoZ2l2ZW5SdiA/IHJldHVyblZhbHVlIDogY3VycmVudClcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBvcHRpb25zLlByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vic2NyaWJlKG5ld1ZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRlc3RGbihuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBzdWJzLmRpc3Bvc2UoKTtcbiAgICAgICAgICByZXNvbHZlKGdpdmVuUnYgPyByZXR1cm5WYWx1ZSA6IG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlcbiAgfSxcblxuICB5ZXQgKHRlc3QsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0ZXN0Rm4gPSB0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJyA/IHRlc3QgOiB2ID0+IHYgPT09IHRlc3Q7XG4gICAgY29uc3QgbmVnYXRlZCA9IHYgPT4gIXRlc3RGbih2KTtcbiAgICByZXR1cm4gdGhpcy53aGVuKG5lZ2F0ZWQsIC4uLmFyZ3MpXG4gIH0sXG5cbiAgbmV4dCAoKSB7IHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMub25jZShyZXNvbHZlKSkgfSxcblxuICBleHRlbmQ6IGFwcGx5RXh0ZW5kZXJzXG59O1xuXG4vLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHdlIG92ZXJ3cml0ZSB0aGUgcHJvdG90eXBlIG9mIGVhY2hcbi8vIG9ic2VydmFibGUgaW5zdGFuY2UuIFNpbmNlIG9ic2VydmFibGVzIGFyZSBmdW5jdGlvbnMsIHdlIG5lZWQgRnVuY3Rpb24ucHJvdG90eXBlXG4vLyB0byBzdGlsbCBiZSBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuaWYgKGNhblNldFByb3RvdHlwZSkge1xuICBzZXRQcm90b3R5cGVPZihrb19zdWJzY3JpYmFibGVfZm4sIEZ1bmN0aW9uLnByb3RvdHlwZSk7XG59XG5cbnN1YnNjcmliYWJsZS5mbiA9IGtvX3N1YnNjcmliYWJsZV9mbjtcblxuZnVuY3Rpb24gaXNTdWJzY3JpYmFibGUgKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZSAhPSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLm5vdGlmeVN1YnNjcmliZXJzID09PSAnZnVuY3Rpb24nXG59XG5cbi8vXG4vLyBkZXBlbmRlbmN5RGV0ZWN0aW9uXG4vLyAtLS1cbi8vXG4vLyBJbiBLTyAzLngsIGRlcGVuZGVuY3lEZXRlY3Rpb24gd2FzIGFsc28ga25vd24gYXMgY29tcHV0ZWRDb250ZXh0LlxuLy9cbmNvbnN0IG91dGVyRnJhbWVzID0gW107XG5sZXQgY3VycmVudEZyYW1lO1xubGV0IGxhc3RJZCA9IDA7XG5cbi8vIFJldHVybiBhIHVuaXF1ZSBJRCB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhbiBvYnNlcnZhYmxlIGZvciBkZXBlbmRlbmN5IHRyYWNraW5nLlxuLy8gVGhlb3JldGljYWxseSwgeW91IGNvdWxkIGV2ZW50dWFsbHkgb3ZlcmZsb3cgdGhlIG51bWJlciBzdG9yYWdlIHNpemUsIHJlc3VsdGluZ1xuLy8gaW4gZHVwbGljYXRlIElEcy4gQnV0IGluIEphdmFTY3JpcHQsIHRoZSBsYXJnZXN0IGV4YWN0IGludGVncmFsIHZhbHVlIGlzIDJeNTNcbi8vIG9yIDksMDA3LDE5OSwyNTQsNzQwLDk5Mi4gSWYgeW91IGNyZWF0ZWQgMSwwMDAsMDAwIElEcyBwZXIgc2Vjb25kLCBpdCB3b3VsZFxuLy8gdGFrZSBvdmVyIDI4NSB5ZWFycyB0byByZWFjaCB0aGF0IG51bWJlci5cbi8vIFJlZmVyZW5jZSBodHRwOi8vYmxvZy52amV1eC5jb20vMjAxMC9qYXZhc2NyaXB0L2phdmFzY3JpcHQtbWF4X2ludC1udW1iZXItbGltaXRzLmh0bWxcbmZ1bmN0aW9uIGdldElkICgpIHtcbiAgcmV0dXJuICsrbGFzdElkXG59XG5cbmZ1bmN0aW9uIGJlZ2luIChvcHRpb25zJCQxKSB7XG4gIG91dGVyRnJhbWVzLnB1c2goY3VycmVudEZyYW1lKTtcbiAgY3VycmVudEZyYW1lID0gb3B0aW9ucyQkMTtcbn1cblxuZnVuY3Rpb24gZW5kICgpIHtcbiAgY3VycmVudEZyYW1lID0gb3V0ZXJGcmFtZXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVwZW5kZW5jeSAoc3Vic2NyaWJhYmxlJCQxKSB7XG4gIGlmIChjdXJyZW50RnJhbWUpIHtcbiAgICBpZiAoIWlzU3Vic2NyaWJhYmxlKHN1YnNjcmliYWJsZSQkMSkpIHsgdGhyb3cgbmV3IEVycm9yKCdPbmx5IHN1YnNjcmliYWJsZSB0aGluZ3MgY2FuIGFjdCBhcyBkZXBlbmRlbmNpZXMnKSB9XG4gICAgY3VycmVudEZyYW1lLmNhbGxiYWNrLmNhbGwoY3VycmVudEZyYW1lLmNhbGxiYWNrVGFyZ2V0LCBzdWJzY3JpYmFibGUkJDEsIHN1YnNjcmliYWJsZSQkMS5faWQgfHwgKHN1YnNjcmliYWJsZSQkMS5faWQgPSBnZXRJZCgpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlIChjYWxsYmFjaywgY2FsbGJhY2tUYXJnZXQsIGNhbGxiYWNrQXJncykge1xuICB0cnkge1xuICAgIGJlZ2luKCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrVGFyZ2V0LCBjYWxsYmFja0FyZ3MgfHwgW10pXG4gIH0gZmluYWxseSB7XG4gICAgZW5kKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzQ291bnQgKCkge1xuICBpZiAoY3VycmVudEZyYW1lKSB7IHJldHVybiBjdXJyZW50RnJhbWUuY29tcHV0ZWQuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKSB9XG59XG5cbmZ1bmN0aW9uIGlzSW5pdGlhbCAoKSB7XG4gIGlmIChjdXJyZW50RnJhbWUpIHsgcmV0dXJuIGN1cnJlbnRGcmFtZS5pc0luaXRpYWwgfVxufVxuXG5cblxuXG52YXIgZGVwZW5kZW5jeURldGVjdGlvbiA9IE9iamVjdC5mcmVlemUoe1xuXHRiZWdpbjogYmVnaW4sXG5cdGVuZDogZW5kLFxuXHRyZWdpc3RlckRlcGVuZGVuY3k6IHJlZ2lzdGVyRGVwZW5kZW5jeSxcblx0aWdub3JlOiBpZ25vcmUsXG5cdGdldERlcGVuZGVuY2llc0NvdW50OiBnZXREZXBlbmRlbmNpZXNDb3VudCxcblx0aXNJbml0aWFsOiBpc0luaXRpYWwsXG5cdGlnbm9yZURlcGVuZGVuY2llczogaWdub3JlXG59KTtcblxuLy9cbi8vICBPYnNlcnZhYmxlIHZhbHVlc1xuLy8gIC0tLVxuLy9cbnZhciBvYnNlcnZhYmxlTGF0ZXN0VmFsdWUgPSBjcmVhdGVTeW1ib2xPclN0cmluZygnX2xhdGVzdFZhbHVlJyk7XG5cbmZ1bmN0aW9uIG9ic2VydmFibGUgKGluaXRpYWxWYWx1ZSkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFdyaXRlXG4gICAgICAgICAgICAvLyBJZ25vcmUgd3JpdGVzIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZFxuICAgICAgaWYgKE9ic2VydmFibGUuaXNEaWZmZXJlbnQoT2JzZXJ2YWJsZVtvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdLCBhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIE9ic2VydmFibGUudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICAgIE9ic2VydmFibGVbb2JzZXJ2YWJsZUxhdGVzdFZhbHVlXSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgT2JzZXJ2YWJsZS52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzIC8vIFBlcm1pdHMgY2hhaW5lZCBhc3NpZ25tZW50c1xuICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWFkXG4gICAgICByZWdpc3RlckRlcGVuZGVuY3koT2JzZXJ2YWJsZSk7IC8vIFRoZSBjYWxsZXIgb25seSBuZWVkcyB0byBiZSBub3RpZmllZCBvZiBjaGFuZ2VzIGlmIHRoZXkgZGlkIGEgXCJyZWFkXCIgb3BlcmF0aW9uXG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZVtvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdXG4gICAgfVxuICB9XG5cbiAgT2JzZXJ2YWJsZVtvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgLy8gSW5oZXJpdCBmcm9tICdzdWJzY3JpYmFibGUnXG4gIGlmICghY2FuU2V0UHJvdG90eXBlKSB7XG4gICAgICAgIC8vICdzdWJzY3JpYmFibGUnIHdvbid0IGJlIG9uIHRoZSBwcm90b3R5cGUgY2hhaW4gdW5sZXNzIHdlIHB1dCBpdCB0aGVyZSBkaXJlY3RseVxuICAgIGV4dGVuZChPYnNlcnZhYmxlLCBzdWJzY3JpYmFibGUuZm4pO1xuICB9XG4gIHN1YnNjcmliYWJsZS5mbi5pbml0KE9ic2VydmFibGUpO1xuXG4gICAgLy8gSW5oZXJpdCBmcm9tICdvYnNlcnZhYmxlJ1xuICBzZXRQcm90b3R5cGVPZk9yRXh0ZW5kKE9ic2VydmFibGUsIG9ic2VydmFibGUuZm4pO1xuXG4gIGlmIChvcHRpb25zLmRlZmVyVXBkYXRlcykge1xuICAgIGRlZmVyVXBkYXRlcyhPYnNlcnZhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBPYnNlcnZhYmxlXG59XG5cbi8vIERlZmluZSBwcm90b3R5cGUgZm9yIG9ic2VydmFibGVzXG5vYnNlcnZhYmxlLmZuID0ge1xuICBlcXVhbGl0eUNvbXBhcmVyOiB2YWx1ZXNBcmVQcmltaXRpdmVBbmRFcXVhbCxcbiAgcGVlayAoKSB7IHJldHVybiB0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV0gfSxcbiAgdmFsdWVIYXNNdXRhdGVkICgpIHsgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzW29ic2VydmFibGVMYXRlc3RWYWx1ZV0pOyB9LFxuICB2YWx1ZVdpbGxNdXRhdGUgKCkge1xuICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpc1tvYnNlcnZhYmxlTGF0ZXN0VmFsdWVdLCAnYmVmb3JlQ2hhbmdlJyk7XG4gIH0sXG4gIHRoZW4gKHJlcywgcmVqKSB7IHRyeSB7IHJlcyh0aGlzKCkpOyB9IGNhdGNoIChlKSB7IHJlaihlKTsgfSB9LFxufTtcblxuLy8gTW92ZWQgb3V0IG9mIFwibGltaXRcIiB0byBhdm9pZCB0aGUgZXh0cmEgY2xvc3VyZVxuZnVuY3Rpb24gbGltaXROb3RpZnlTdWJzY3JpYmVycyAodmFsdWUsIGV2ZW50KSB7XG4gIGlmICghZXZlbnQgfHwgZXZlbnQgPT09IGRlZmF1bHRFdmVudCkge1xuICAgIHRoaXMuX2xpbWl0Q2hhbmdlKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChldmVudCA9PT0gJ2JlZm9yZUNoYW5nZScpIHtcbiAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCBldmVudCk7XG4gIH1cbn1cblxuLy8gQWRkIGBsaW1pdGAgZnVuY3Rpb24gdG8gdGhlIHN1YnNjcmliYWJsZSBwcm90b3R5cGVcbnN1YnNjcmliYWJsZS5mbi5saW1pdCA9IGZ1bmN0aW9uIGxpbWl0IChsaW1pdEZ1bmN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbGZJc09ic2VydmFibGUgPSBpc09ic2VydmFibGUoc2VsZik7XG4gIHZhciBiZWZvcmVDaGFuZ2UgPSAnYmVmb3JlQ2hhbmdlJztcbiAgdmFyIGlnbm9yZUJlZm9yZUNoYW5nZSwgcHJldmlvdXNWYWx1ZSwgcGVuZGluZ1ZhbHVlO1xuXG4gIGlmICghc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKSB7XG4gICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzID0gc2VsZi5ub3RpZnlTdWJzY3JpYmVycztcbiAgICBzZWxmLm5vdGlmeVN1YnNjcmliZXJzID0gbGltaXROb3RpZnlTdWJzY3JpYmVycztcbiAgfVxuXG4gIHZhciBmaW5pc2ggPSBsaW1pdEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9ub3RpZmljYXRpb25Jc1BlbmRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBJZiBhbiBvYnNlcnZhYmxlIHByb3ZpZGVkIGEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgYWNjZXNzIGl0IHRvIGdldCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAgICAvLyBUaGlzIGFsbG93cyBjb21wdXRlZCBvYnNlcnZhYmxlcyB0byBkZWxheSBjYWxjdWxhdGluZyB0aGVpciB2YWx1ZSB1bnRpbCBuZWVkZWQuXG4gICAgaWYgKHNlbGZJc09ic2VydmFibGUgJiYgcGVuZGluZ1ZhbHVlID09PSBzZWxmKSB7XG4gICAgICBwZW5kaW5nVmFsdWUgPSBzZWxmKCk7XG4gICAgfVxuICAgIGlnbm9yZUJlZm9yZUNoYW5nZSA9IGZhbHNlO1xuICAgIGlmIChzZWxmLmlzRGlmZmVyZW50KHByZXZpb3VzVmFsdWUsIHBlbmRpbmdWYWx1ZSkpIHtcbiAgICAgIHNlbGYuX29yaWdOb3RpZnlTdWJzY3JpYmVycyhwcmV2aW91c1ZhbHVlID0gcGVuZGluZ1ZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNlbGYuX2xpbWl0Q2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgc2VsZi5fbm90aWZpY2F0aW9uSXNQZW5kaW5nID0gaWdub3JlQmVmb3JlQ2hhbmdlID0gdHJ1ZTtcbiAgICBwZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICBmaW5pc2goKTtcbiAgfTtcbiAgc2VsZi5fbGltaXRCZWZvcmVDaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIWlnbm9yZUJlZm9yZUNoYW5nZSkge1xuICAgICAgcHJldmlvdXNWYWx1ZSA9IHZhbHVlO1xuICAgICAgc2VsZi5fb3JpZ05vdGlmeVN1YnNjcmliZXJzKHZhbHVlLCBiZWZvcmVDaGFuZ2UpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIE5vdGUgdGhhdCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHByb3RvIGFzc2lnbm1lbnQsIHRoZVxuLy8gaW5oZXJpdGFuY2UgY2hhaW4gaXMgY3JlYXRlZCBtYW51YWxseSBpbiB0aGUgb2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuaWYgKGNhblNldFByb3RvdHlwZSkge1xuICBzZXRQcm90b3R5cGVPZihvYnNlcnZhYmxlLmZuLCBzdWJzY3JpYmFibGUuZm4pO1xufVxuXG52YXIgcHJvdG9Qcm9wZXJ0eSA9IG9ic2VydmFibGUucHJvdG9Qcm9wZXJ0eSA9IG9wdGlvbnMucHJvdG9Qcm9wZXJ0eTtcbm9ic2VydmFibGUuZm5bcHJvdG9Qcm9wZXJ0eV0gPSBvYnNlcnZhYmxlO1xuXG5mdW5jdGlvbiBpc09ic2VydmFibGUgKGluc3RhbmNlKSB7XG4gIHJldHVybiBoYXNQcm90b3R5cGUoaW5zdGFuY2UsIG9ic2VydmFibGUpXG59XG5cbmZ1bmN0aW9uIHVud3JhcCAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyB2YWx1ZSgpIDogdmFsdWVcbn1cblxuZnVuY3Rpb24gcGVlayAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyB2YWx1ZS5wZWVrKCkgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBpc1dyaXRlYWJsZU9ic2VydmFibGUgKGluc3RhbmNlKSB7XG4gICAgLy8gT2JzZXJ2YWJsZVxuICBpZiAoKHR5cGVvZiBpbnN0YW5jZSA9PT0gJ2Z1bmN0aW9uJykgJiYgaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0gPT09IG9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gICAgLy8gV3JpdGVhYmxlIGRlcGVuZGVudCBvYnNlcnZhYmxlXG4gIGlmICgodHlwZW9mIGluc3RhbmNlID09PSAnZnVuY3Rpb24nKSAvKiAmJiAoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0gPT09IGtvLmRlcGVuZGVudE9ic2VydmFibGUpICovICYmIChpbnN0YW5jZS5oYXNXcml0ZUZ1bmN0aW9uKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgICAvLyBBbnl0aGluZyBlbHNlXG4gIHJldHVybiBmYWxzZVxufVxuXG4vL1xuLy8gT2JzZXJ2YWJsZSBBcnJheSAtIENoYW5nZSBUcmFja2luZyBFeHRlbmRlclxuLy8gLS0tXG4vL1xuLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiAwKi9cblxudmFyIGFycmF5Q2hhbmdlRXZlbnROYW1lID0gJ2FycmF5Q2hhbmdlJztcblxuXG5mdW5jdGlvbiB0cmFja0FycmF5Q2hhbmdlcyh0YXJnZXQsIG9wdGlvbnMkJDEpIHtcbiAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIG9wdGlvbnMtLWVhY2ggY2FsbCB0byB0cmFja0FycmF5Q2hhbmdlcyBvdmVyd3JpdGVzIHRoZSBwcmV2aW91c2x5IHNldCBvcHRpb25zXG4gICAgdGFyZ2V0LmNvbXBhcmVBcnJheU9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucyQkMSAmJiB0eXBlb2Ygb3B0aW9ucyQkMSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGV4dGVuZCh0YXJnZXQuY29tcGFyZUFycmF5T3B0aW9ucywgb3B0aW9ucyQkMSk7XG4gICAgfVxuICAgIHRhcmdldC5jb21wYXJlQXJyYXlPcHRpb25zLnNwYXJzZSA9IHRydWU7XG5cbiAgICAvLyBPbmx5IG1vZGlmeSB0aGUgdGFyZ2V0IG9ic2VydmFibGUgb25jZVxuICAgIGlmICh0YXJnZXQuY2FjaGVEaWZmRm9yS25vd25PcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdHJhY2tpbmdDaGFuZ2VzID0gZmFsc2UsXG4gICAgICAgIGNhY2hlZERpZmYgPSBudWxsLFxuICAgICAgICBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbixcbiAgICAgICAgcGVuZGluZ05vdGlmaWNhdGlvbnMgPSAwLFxuICAgICAgICB1bmRlcmx5aW5nQmVmb3JlU3Vic2NyaXB0aW9uQWRkRnVuY3Rpb24gPSB0YXJnZXQuYmVmb3JlU3Vic2NyaXB0aW9uQWRkLFxuICAgICAgICB1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbiA9IHRhcmdldC5hZnRlclN1YnNjcmlwdGlvblJlbW92ZTtcblxuICAgIC8vIFdhdGNoIFwic3Vic2NyaWJlXCIgY2FsbHMsIGFuZCBmb3IgYXJyYXkgY2hhbmdlIGV2ZW50cywgZW5zdXJlIGNoYW5nZSB0cmFja2luZyBpcyBlbmFibGVkXG4gICAgdGFyZ2V0LmJlZm9yZVN1YnNjcmlwdGlvbkFkZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uKVxuICAgICAgICAgICAgdW5kZXJseWluZ0JlZm9yZVN1YnNjcmlwdGlvbkFkZEZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICAgIGlmIChldmVudCA9PT0gYXJyYXlDaGFuZ2VFdmVudE5hbWUpIHtcbiAgICAgICAgICAgIHRyYWNrQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdhdGNoIFwiZGlzcG9zZVwiIGNhbGxzLCBhbmQgZm9yIGFycmF5IGNoYW5nZSBldmVudHMsIGVuc3VyZSBjaGFuZ2UgdHJhY2tpbmcgaXMgZGlzYWJsZWQgd2hlbiBhbGwgYXJlIGRpc3Bvc2VkXG4gICAgdGFyZ2V0LmFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh1bmRlcmx5aW5nQWZ0ZXJTdWJzY3JpcHRpb25SZW1vdmVGdW5jdGlvbilcbiAgICAgICAgICAgIHVuZGVybHlpbmdBZnRlclN1YnNjcmlwdGlvblJlbW92ZUZ1bmN0aW9uLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICAgIGlmIChldmVudCA9PT0gYXJyYXlDaGFuZ2VFdmVudE5hbWUgJiYgIXRhcmdldC5oYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQoYXJyYXlDaGFuZ2VFdmVudE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlDaGFuZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnJheUNoYW5nZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0cmFja2luZ0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmFja0NoYW5nZXMoKSB7XG4gICAgICAgIC8vIENhbGxpbmcgJ3RyYWNrQ2hhbmdlcycgbXVsdGlwbGUgdGltZXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyBpdCBvbmNlXG4gICAgICAgIGlmICh0cmFja2luZ0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNraW5nQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgLy8gSW50ZXJjZXB0IFwibm90aWZ5U3Vic2NyaWJlcnNcIiB0byB0cmFjayBob3cgbWFueSB0aW1lcyBpdCB3YXMgY2FsbGVkLlxuICAgICAgICB2YXIgdW5kZXJseWluZ05vdGlmeVN1YnNjcmliZXJzRnVuY3Rpb24gPSB0YXJnZXRbJ25vdGlmeVN1YnNjcmliZXJzJ107XG4gICAgICAgIHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXSA9IGZ1bmN0aW9uKHZhbHVlVG9Ob3RpZnksIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50ID09PSBkZWZhdWx0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICArK3BlbmRpbmdOb3RpZmljYXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdOb3RpZnlTdWJzY3JpYmVyc0Z1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRWFjaCB0aW1lIHRoZSBhcnJheSBjaGFuZ2VzIHZhbHVlLCBjYXB0dXJlIGEgY2xvbmUgc28gdGhhdCBvbiB0aGUgbmV4dFxuICAgICAgICAvLyBjaGFuZ2UgaXQncyBwb3NzaWJsZSB0byBwcm9kdWNlIGEgZGlmZlxuICAgICAgICB2YXIgcHJldmlvdXNDb250ZW50cyA9IFtdLmNvbmNhdCh0YXJnZXQucGVlaygpIHx8IFtdKTtcbiAgICAgICAgY2FjaGVkRGlmZiA9IG51bGw7XG4gICAgICAgIGFycmF5Q2hhbmdlU3Vic2NyaXB0aW9uID0gdGFyZ2V0LnN1YnNjcmliZShmdW5jdGlvbihjdXJyZW50Q29udGVudHMpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGNvbnRlbnRzIGFuZCBlbnN1cmUgaXQncyBhbiBhcnJheVxuICAgICAgICAgICAgY3VycmVudENvbnRlbnRzID0gW10uY29uY2F0KGN1cnJlbnRDb250ZW50cyB8fCBbXSk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGRpZmYgYW5kIGlzc3VlIG5vdGlmaWNhdGlvbnMsIGJ1dCBvbmx5IGlmIHNvbWVvbmUgaXMgbGlzdGVuaW5nXG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc1N1YnNjcmlwdGlvbnNGb3JFdmVudChhcnJheUNoYW5nZUV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IGdldENoYW5nZXMocHJldmlvdXNDb250ZW50cywgY3VycmVudENvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWxpbWluYXRlIHJlZmVyZW5jZXMgdG8gdGhlIG9sZCwgcmVtb3ZlZCBpdGVtcywgc28gdGhleSBjYW4gYmUgR0NlZFxuICAgICAgICAgICAgcHJldmlvdXNDb250ZW50cyA9IGN1cnJlbnRDb250ZW50cztcbiAgICAgICAgICAgIGNhY2hlZERpZmYgPSBudWxsO1xuICAgICAgICAgICAgcGVuZGluZ05vdGlmaWNhdGlvbnMgPSAwO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmJiBjaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFsnbm90aWZ5U3Vic2NyaWJlcnMnXShjaGFuZ2VzLCBhcnJheUNoYW5nZUV2ZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENoYW5nZXMocHJldmlvdXNDb250ZW50cywgY3VycmVudENvbnRlbnRzKSB7XG4gICAgICAgIC8vIFdlIHRyeSB0byByZS11c2UgY2FjaGVkIGRpZmZzLlxuICAgICAgICAvLyBUaGUgc2NlbmFyaW9zIHdoZXJlIHBlbmRpbmdOb3RpZmljYXRpb25zID4gMSBhcmUgd2hlbiB1c2luZyByYXRlLWxpbWl0aW5nIG9yIHRoZSBEZWZlcnJlZCBVcGRhdGVzXG4gICAgICAgIC8vIHBsdWdpbiwgd2hpY2ggd2l0aG91dCB0aGlzIGNoZWNrIHdvdWxkIG5vdCBiZSBjb21wYXRpYmxlIHdpdGggYXJyYXlDaGFuZ2Ugbm90aWZpY2F0aW9ucy4gTm9ybWFsbHksXG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbnMgYXJlIGlzc3VlZCBpbW1lZGlhdGVseSBzbyB3ZSB3b3VsZG4ndCBiZSBxdWV1ZWluZyB1cCBtb3JlIHRoYW4gb25lLlxuICAgICAgICBpZiAoIWNhY2hlZERpZmYgfHwgcGVuZGluZ05vdGlmaWNhdGlvbnMgPiAxKSB7XG4gICAgICAgICAgICBjYWNoZWREaWZmID0gdHJhY2tBcnJheUNoYW5nZXMuY29tcGFyZUFycmF5cyhwcmV2aW91c0NvbnRlbnRzLCBjdXJyZW50Q29udGVudHMsIHRhcmdldC5jb21wYXJlQXJyYXlPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZWREaWZmO1xuICAgIH1cblxuICAgIHRhcmdldC5jYWNoZURpZmZGb3JLbm93bk9wZXJhdGlvbiA9IGZ1bmN0aW9uKHJhd0FycmF5LCBvcGVyYXRpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCwgYXJnc0luZGV4O1xuICAgICAgICAvLyBPbmx5IHJ1biBpZiB3ZSdyZSBjdXJyZW50bHkgdHJhY2tpbmcgY2hhbmdlcyBmb3IgdGhpcyBvYnNlcnZhYmxlIGFycmF5XG4gICAgICAgIC8vIGFuZCB0aGVyZSBhcmVuJ3QgYW55IHBlbmRpbmcgZGVmZXJyZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgICAgaWYgKCF0cmFja2luZ0NoYW5nZXMgfHwgcGVuZGluZ05vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZiA9IFtdLFxuICAgICAgICAgICAgYXJyYXlMZW5ndGggPSByYXdBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1c2hEaWZmKHN0YXR1cywgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZltkaWZmLmxlbmd0aF0gPSB7ICdzdGF0dXMnOiBzdGF0dXMsICd2YWx1ZSc6IHZhbHVlLCAnaW5kZXgnOiBpbmRleCB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uTmFtZSkge1xuICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgICAgIG9mZnNldCA9IGFycmF5TGVuZ3RoO1xuICAgICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFyZ3NMZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBwdXNoRGlmZignYWRkZWQnLCBhcmdzW2luZGV4XSwgb2Zmc2V0ICsgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncG9wJzpcbiAgICAgICAgICAgIG9mZnNldCA9IGFycmF5TGVuZ3RoIC0gMTtcbiAgICAgICAgY2FzZSAnc2hpZnQnOlxuICAgICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHVzaERpZmYoJ2RlbGV0ZWQnLCByYXdBcnJheVtvZmZzZXRdLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIHN0YXJ0IGluZGV4IG1lYW5zICdmcm9tIGVuZCBvZiBhcnJheScuIEFmdGVyIHRoYXQgd2UgY2xhbXAgdG8gWzAuLi5hcnJheUxlbmd0aF0uXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlXG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGFyZ3NbMF0gPCAwID8gYXJyYXlMZW5ndGggKyBhcmdzWzBdIDogYXJnc1swXSksIGFycmF5TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBlbmREZWxldGVJbmRleCA9IGFyZ3NMZW5ndGggPT09IDEgPyBhcnJheUxlbmd0aCA6IE1hdGgubWluKHN0YXJ0SW5kZXggKyAoYXJnc1sxXSB8fCAwKSwgYXJyYXlMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGVuZEFkZEluZGV4ID0gc3RhcnRJbmRleCArIGFyZ3NMZW5ndGggLSAyLFxuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gTWF0aC5tYXgoZW5kRGVsZXRlSW5kZXgsIGVuZEFkZEluZGV4KSxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbnMgPSBbXSwgZGVsZXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gc3RhcnRJbmRleCwgYXJnc0luZGV4ID0gMjsgaW5kZXggPCBlbmRJbmRleDsgKytpbmRleCwgKythcmdzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBlbmREZWxldGVJbmRleClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRpb25zLnB1c2gocHVzaERpZmYoJ2RlbGV0ZWQnLCByYXdBcnJheVtpbmRleF0sIGluZGV4KSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZW5kQWRkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKHB1c2hEaWZmKCdhZGRlZCcsIGFyZ3NbYXJnc0luZGV4XSwgaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmRNb3Zlc0luQXJyYXlDb21wYXJpc29uKGRlbGV0aW9ucywgYWRkaXRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVkRGlmZiA9IGRpZmY7XG4gICAgfTtcbn1cblxuXG4vLyBFeHBvc2UgY29tcGFyZUFycmF5cyBmb3IgdGVzdGluZy5cbnRyYWNrQXJyYXlDaGFuZ2VzLmNvbXBhcmVBcnJheXMgPSBjb21wYXJlQXJyYXlzO1xuXG5cbi8vIEFkZCB0aGUgdHJhY2tBcnJheUNoYW5nZXMgZXh0ZW5kZXIgc28gd2UgY2FuIHVzZVxuLy8gb2JzLmV4dGVuZCh7IHRyYWNrQXJyYXlDaGFuZ2VzOiB0cnVlIH0pXG5leHRlbmRlcnMudHJhY2tBcnJheUNoYW5nZXMgPSB0cmFja0FycmF5Q2hhbmdlcztcblxuLy9cbi8vIE9ic2VydmFibGUgQXJyYXlzXG4vLyA9PT1cbi8vXG5mdW5jdGlvbiBvYnNlcnZhYmxlQXJyYXkgKGluaXRpYWxWYWx1ZXMpIHtcbiAgaW5pdGlhbFZhbHVlcyA9IGluaXRpYWxWYWx1ZXMgfHwgW107XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWVzICE9PSAnb2JqZWN0JyB8fCAhKCdsZW5ndGgnIGluIGluaXRpYWxWYWx1ZXMpKSB7IHRocm93IG5ldyBFcnJvcignVGhlIGFyZ3VtZW50IHBhc3NlZCB3aGVuIGluaXRpYWxpemluZyBhbiBvYnNlcnZhYmxlIGFycmF5IG11c3QgYmUgYW4gYXJyYXksIG9yIG51bGwsIG9yIHVuZGVmaW5lZC4nKSB9XG5cbiAgdmFyIHJlc3VsdCA9IG9ic2VydmFibGUoaW5pdGlhbFZhbHVlcyk7XG4gIHNldFByb3RvdHlwZU9mT3JFeHRlbmQocmVzdWx0LCBvYnNlcnZhYmxlQXJyYXkuZm4pO1xuICB0cmFja0FycmF5Q2hhbmdlcyhyZXN1bHQpO1xuICAgICAgICAvLyBePT0gcmVzdWx0LmV4dGVuZCh7IHRyYWNrQXJyYXlDaGFuZ2VzOiB0cnVlIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxub2JzZXJ2YWJsZUFycmF5LmZuID0ge1xuICByZW1vdmU6IGZ1bmN0aW9uICh2YWx1ZU9yUHJlZGljYXRlKSB7XG4gICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgIHZhciByZW1vdmVkVmFsdWVzID0gW107XG4gICAgdmFyIHByZWRpY2F0ZSA9IHR5cGVvZiB2YWx1ZU9yUHJlZGljYXRlID09PSAnZnVuY3Rpb24nICYmICFpc09ic2VydmFibGUodmFsdWVPclByZWRpY2F0ZSkgPyB2YWx1ZU9yUHJlZGljYXRlIDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gdmFsdWVPclByZWRpY2F0ZSB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5kZXJseWluZ0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB1bmRlcmx5aW5nQXJyYXlbaV07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICBpZiAocmVtb3ZlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnZhbHVlV2lsbE11dGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHVuZGVybHlpbmdBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZWRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZFZhbHVlc1xuICB9LFxuXG4gIHJlbW92ZUFsbDogZnVuY3Rpb24gKGFycmF5T2ZWYWx1ZXMpIHtcbiAgICAgICAgLy8gSWYgeW91IHBhc3NlZCB6ZXJvIGFyZ3MsIHdlIHJlbW92ZSBldmVyeXRoaW5nXG4gICAgaWYgKGFycmF5T2ZWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgICAgdmFyIGFsbFZhbHVlcyA9IHVuZGVybHlpbmdBcnJheS5zbGljZSgwKTtcbiAgICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgICB1bmRlcmx5aW5nQXJyYXkuc3BsaWNlKDAsIHVuZGVybHlpbmdBcnJheS5sZW5ndGgpO1xuICAgICAgdGhpcy52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgIHJldHVybiBhbGxWYWx1ZXNcbiAgICB9XG4gICAgICAgIC8vIElmIHlvdSBwYXNzZWQgYW4gYXJnLCB3ZSBpbnRlcnByZXQgaXQgYXMgYW4gYXJyYXkgb2YgZW50cmllcyB0byByZW1vdmVcbiAgICBpZiAoIWFycmF5T2ZWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1sncmVtb3ZlJ10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGFycmF5T2ZWYWx1ZXMsIHZhbHVlKSA+PSAwXG4gICAgfSlcbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiAodmFsdWVPclByZWRpY2F0ZSkge1xuICAgIHZhciB1bmRlcmx5aW5nQXJyYXkgPSB0aGlzLnBlZWsoKTtcbiAgICB2YXIgcHJlZGljYXRlID0gdHlwZW9mIHZhbHVlT3JQcmVkaWNhdGUgPT09ICdmdW5jdGlvbicgJiYgIWlzT2JzZXJ2YWJsZSh2YWx1ZU9yUHJlZGljYXRlKSA/IHZhbHVlT3JQcmVkaWNhdGUgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSB2YWx1ZU9yUHJlZGljYXRlIH07XG4gICAgdGhpcy52YWx1ZVdpbGxNdXRhdGUoKTtcbiAgICBmb3IgKHZhciBpID0gdW5kZXJseWluZ0FycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdmFsdWUgPSB1bmRlcmx5aW5nQXJyYXlbaV07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICB1bmRlcmx5aW5nQXJyYXlbaV1bJ19kZXN0cm95J10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZhbHVlSGFzTXV0YXRlZCgpO1xuICB9LFxuXG4gIGRlc3Ryb3lBbGw6IGZ1bmN0aW9uIChhcnJheU9mVmFsdWVzKSB7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzZWQgemVybyBhcmdzLCB3ZSBkZXN0cm95IGV2ZXJ5dGhpbmdcbiAgICBpZiAoYXJyYXlPZlZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB0aGlzLmRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9KSB9XG5cbiAgICAgICAgLy8gSWYgeW91IHBhc3NlZCBhbiBhcmcsIHdlIGludGVycHJldCBpdCBhcyBhbiBhcnJheSBvZiBlbnRyaWVzIHRvIGRlc3Ryb3lcbiAgICBpZiAoIWFycmF5T2ZWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihhcnJheU9mVmFsdWVzLCB2YWx1ZSkgPj0gMFxuICAgIH0pXG4gIH0sXG5cbiAgaW5kZXhPZjogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgdW5kZXJseWluZ0FycmF5ID0gdGhpcygpO1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodW5kZXJseWluZ0FycmF5LCBpdGVtKVxuICB9LFxuXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIChvbGRJdGVtLCBuZXdJdGVtKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKG9sZEl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnZhbHVlV2lsbE11dGF0ZSgpO1xuICAgICAgdGhpcy5wZWVrKClbaW5kZXhdID0gbmV3SXRlbTtcbiAgICAgIHRoaXMudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBOb3RlIHRoYXQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwcm90byBhc3NpZ25tZW50LCB0aGVcbi8vIGluaGVyaXRhbmNlIGNoYWluIGlzIGNyZWF0ZWQgbWFudWFsbHkgaW4gdGhlIGtvLm9ic2VydmFibGVBcnJheSBjb25zdHJ1Y3RvclxuaWYgKGNhblNldFByb3RvdHlwZSkge1xuICBzZXRQcm90b3R5cGVPZihvYnNlcnZhYmxlQXJyYXkuZm4sIG9ic2VydmFibGUuZm4pO1xufVxuXG4vLyBQb3B1bGF0ZSBrby5vYnNlcnZhYmxlQXJyYXkuZm4gd2l0aCByZWFkL3dyaXRlIGZ1bmN0aW9ucyBmcm9tIG5hdGl2ZSBhcnJheXNcbi8vIEltcG9ydGFudDogRG8gbm90IGFkZCBhbnkgYWRkaXRpb25hbCBmdW5jdGlvbnMgaGVyZSB0aGF0IG1heSByZWFzb25hYmx5IGJlIHVzZWQgdG8gKnJlYWQqIGRhdGEgZnJvbSB0aGUgYXJyYXlcbi8vIGJlY2F1c2Ugd2UnbGwgZXZhbCB0aGVtIHdpdGhvdXQgY2F1c2luZyBzdWJzY3JpcHRpb25zLCBzbyBrby5jb21wdXRlZCBvdXRwdXQgY291bGQgZW5kIHVwIGdldHRpbmcgc3RhbGVcbmFycmF5Rm9yRWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBvYnNlcnZhYmxlQXJyYXkuZm5bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVzZSBcInBlZWtcIiB0byBhdm9pZCBjcmVhdGluZyBhIHN1YnNjcmlwdGlvbiBpbiBhbnkgY29tcHV0ZWQgdGhhdCB3ZSdyZSBleGVjdXRpbmcgaW4gdGhlIGNvbnRleHQgb2ZcbiAgICAgICAgLy8gKGZvciBjb25zaXN0ZW5jeSB3aXRoIG11dGF0aW5nIHJlZ3VsYXIgb2JzZXJ2YWJsZXMpXG4gICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMucGVlaygpO1xuICAgIHRoaXMudmFsdWVXaWxsTXV0YXRlKCk7XG4gICAgdGhpcy5jYWNoZURpZmZGb3JLbm93bk9wZXJhdGlvbih1bmRlcmx5aW5nQXJyYXksIG1ldGhvZE5hbWUsIGFyZ3VtZW50cyk7XG4gICAgdmFyIG1ldGhvZENhbGxSZXN1bHQgPSB1bmRlcmx5aW5nQXJyYXlbbWV0aG9kTmFtZV0uYXBwbHkodW5kZXJseWluZ0FycmF5LCBhcmd1bWVudHMpO1xuICAgIHRoaXMudmFsdWVIYXNNdXRhdGVkKCk7XG4gICAgICAgIC8vIFRoZSBuYXRpdmUgc29ydCBhbmQgcmV2ZXJzZSBtZXRob2RzIHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXksIGJ1dCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHJldHVybiB0aGUgb2JzZXJ2YWJsZSBhcnJheSBpbnN0ZWFkLlxuICAgIHJldHVybiBtZXRob2RDYWxsUmVzdWx0ID09PSB1bmRlcmx5aW5nQXJyYXkgPyB0aGlzIDogbWV0aG9kQ2FsbFJlc3VsdFxuICB9O1xufSk7XG5cbi8vIFBvcHVsYXRlIGtvLm9ic2VydmFibGVBcnJheS5mbiB3aXRoIHJlYWQtb25seSBmdW5jdGlvbnMgZnJvbSBuYXRpdmUgYXJyYXlzXG5hcnJheUZvckVhY2goWydzbGljZSddLCBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBvYnNlcnZhYmxlQXJyYXkuZm5bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVuZGVybHlpbmdBcnJheSA9IHRoaXMoKTtcbiAgICByZXR1cm4gdW5kZXJseWluZ0FycmF5W21ldGhvZE5hbWVdLmFwcGx5KHVuZGVybHlpbmdBcnJheSwgYXJndW1lbnRzKVxuICB9O1xufSk7XG5cbi8vXG4vLyBIZWxwZXJzXG4vLyAtLS1cbi8vIHRvSlMgJiB0b0pTT05cbi8vXG52YXIgbWF4TmVzdGVkT2JzZXJ2YWJsZURlcHRoID0gMTA7IC8vIEVzY2FwZSB0aGUgKHVubGlrZWx5KSBwYXRoYWxvZ2ljYWwgY2FzZSB3aGVyZSBhbiBvYnNlcnZhYmxlJ3MgY3VycmVudCB2YWx1ZSBpcyBpdHNlbGYgKG9yIHNpbWlsYXIgcmVmZXJlbmNlIGN5Y2xlKVxuXG5mdW5jdGlvbiB0b0pTKHJvb3RPYmplY3QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcga28udG9KUywgcGFzcyB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGNvbnZlcnQuXCIpO1xuXG4gICAgLy8gV2UganVzdCB1bndyYXAgZXZlcnl0aGluZyBhdCBldmVyeSBsZXZlbCBpbiB0aGUgb2JqZWN0IGdyYXBoXG4gICAgcmV0dXJuIG1hcEpzT2JqZWN0R3JhcGgocm9vdE9iamVjdCwgZnVuY3Rpb24odmFsdWVUb01hcCkge1xuICAgICAgICAvLyBMb29wIGJlY2F1c2UgYW4gb2JzZXJ2YWJsZSdzIHZhbHVlIG1pZ2h0IGluIHR1cm4gYmUgYW5vdGhlciBvYnNlcnZhYmxlIHdyYXBwZXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGlzT2JzZXJ2YWJsZSh2YWx1ZVRvTWFwKSAmJiAoaSA8IG1heE5lc3RlZE9ic2VydmFibGVEZXB0aCk7IGkrKylcbiAgICAgICAgICAgIHZhbHVlVG9NYXAgPSB2YWx1ZVRvTWFwKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZVRvTWFwO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0b0pTT04ocm9vdE9iamVjdCwgcmVwbGFjZXIsIHNwYWNlKSB7ICAgICAvLyByZXBsYWNlciBhbmQgc3BhY2UgYXJlIG9wdGlvbmFsXG4gICAgdmFyIHBsYWluSmF2YVNjcmlwdE9iamVjdCA9IHRvSlMocm9vdE9iamVjdCk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUpzb24ocGxhaW5KYXZhU2NyaXB0T2JqZWN0LCByZXBsYWNlciwgc3BhY2UpO1xufVxuXG5mdW5jdGlvbiBtYXBKc09iamVjdEdyYXBoKHJvb3RPYmplY3QsIG1hcElucHV0Q2FsbGJhY2ssIHZpc2l0ZWRPYmplY3RzKSB7XG4gICAgdmlzaXRlZE9iamVjdHMgPSB2aXNpdGVkT2JqZWN0cyB8fCBuZXcgb2JqZWN0TG9va3VwKCk7XG5cbiAgICByb290T2JqZWN0ID0gbWFwSW5wdXRDYWxsYmFjayhyb290T2JqZWN0KTtcbiAgICB2YXIgY2FuSGF2ZVByb3BlcnRpZXMgPSAodHlwZW9mIHJvb3RPYmplY3QgPT0gXCJvYmplY3RcIikgJiYgKHJvb3RPYmplY3QgIT09IG51bGwpICYmIChyb290T2JqZWN0ICE9PSB1bmRlZmluZWQpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBSZWdFeHApKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkpICYmICghKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpKSAmJiAoIShyb290T2JqZWN0IGluc3RhbmNlb2YgTnVtYmVyKSkgJiYgKCEocm9vdE9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pKTtcbiAgICBpZiAoIWNhbkhhdmVQcm9wZXJ0aWVzKVxuICAgICAgICByZXR1cm4gcm9vdE9iamVjdDtcblxuICAgIHZhciBvdXRwdXRQcm9wZXJ0aWVzID0gcm9vdE9iamVjdCBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTtcbiAgICB2aXNpdGVkT2JqZWN0cy5zYXZlKHJvb3RPYmplY3QsIG91dHB1dFByb3BlcnRpZXMpO1xuXG4gICAgdmlzaXRQcm9wZXJ0aWVzT3JBcnJheUVudHJpZXMocm9vdE9iamVjdCwgZnVuY3Rpb24oaW5kZXhlcikge1xuICAgICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IG1hcElucHV0Q2FsbGJhY2socm9vdE9iamVjdFtpbmRleGVyXSk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBvdXRwdXRQcm9wZXJ0aWVzW2luZGV4ZXJdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHZhciBwcmV2aW91c2x5TWFwcGVkVmFsdWUgPSB2aXNpdGVkT2JqZWN0cy5nZXQocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICBvdXRwdXRQcm9wZXJ0aWVzW2luZGV4ZXJdID0gKHByZXZpb3VzbHlNYXBwZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgID8gcHJldmlvdXNseU1hcHBlZFZhbHVlXG4gICAgICAgICAgICAgICAgOiBtYXBKc09iamVjdEdyYXBoKHByb3BlcnR5VmFsdWUsIG1hcElucHV0Q2FsbGJhY2ssIHZpc2l0ZWRPYmplY3RzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3V0cHV0UHJvcGVydGllcztcbn1cblxuZnVuY3Rpb24gdmlzaXRQcm9wZXJ0aWVzT3JBcnJheUVudHJpZXMocm9vdE9iamVjdCwgdmlzaXRvckNhbGxiYWNrKSB7XG4gICAgaWYgKHJvb3RPYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RPYmplY3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2soaSk7XG5cbiAgICAgICAgLy8gRm9yIGFycmF5cywgYWxzbyByZXNwZWN0IHRvSlNPTiBwcm9wZXJ0eSBmb3IgY3VzdG9tIG1hcHBpbmdzIChmaXhlcyAjMjc4KVxuICAgICAgICBpZiAodHlwZW9mIHJvb3RPYmplY3RbJ3RvSlNPTiddID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2soJ3RvSlNPTicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiByb290T2JqZWN0KSB7XG4gICAgICAgICAgICB2aXNpdG9yQ2FsbGJhY2socHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gb2JqZWN0TG9va3VwKCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG59XG5cbm9iamVjdExvb2t1cC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IG9iamVjdExvb2t1cCxcbiAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZ0luZGV4ID0gYXJyYXlJbmRleE9mKHRoaXMua2V5cywga2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMClcbiAgICAgICAgICAgIHRoaXMudmFsdWVzW2V4aXN0aW5nSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IGFycmF5SW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgIHJldHVybiAoZXhpc3RpbmdJbmRleCA+PSAwKSA/IHRoaXMudmFsdWVzW2V4aXN0aW5nSW5kZXhdIDogdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8vXG4vLyBPYnNlcnZhYmxlcy5cbi8vIC0tLVxuLy9cbi8vIFRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIHRvIHRoZSByb290IGBbdF1rb2Agb2JqZWN0LlxuLy9cblxuZXhwb3J0IHsgZGVwZW5kZW5jeURldGVjdGlvbiwgb2JzZXJ2YWJsZSwgaXNPYnNlcnZhYmxlLCB1bndyYXAsIHBlZWssIGlzV3JpdGVhYmxlT2JzZXJ2YWJsZSwgaXNXcml0ZWFibGVPYnNlcnZhYmxlIGFzIGlzV3JpdGFibGVPYnNlcnZhYmxlLCBpc1N1YnNjcmliYWJsZSwgc3Vic2NyaWJhYmxlLCBvYnNlcnZhYmxlQXJyYXksIHRyYWNrQXJyYXlDaGFuZ2VzLCBhcnJheUNoYW5nZUV2ZW50TmFtZSwgdG9KUywgdG9KU09OLCBkZWZlclVwZGF0ZXMsIHZhbHVlc0FyZVByaW1pdGl2ZUFuZEVxdWFsLCBhcHBseUV4dGVuZGVycywgZXh0ZW5kZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10a28ub2JzZXJ2YWJsZS5qcy5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28ub2JzZXJ2YWJsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBdkhBO0FBQ0E7QUF5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvRUE7QUFDQTtBQWlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***********************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/tko/tko.utils.js ***!
  \***********************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n//\n// Array utilities\n//\n/* eslint no-cond-assign: 0 */\n\nfunction arrayForEach(array, action) {\n    for (var i = 0, j = array.length; i < j; i++) {\n        action(array[i], i);\n    }\n}\n\nfunction arrayIndexOf(array, item) {\n    // IE9\n    if (typeof Array.prototype.indexOf == \"function\") return Array.prototype.indexOf.call(array, item);\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (array[i] === item) return i;\n    }return -1;\n}\n\nfunction arrayFirst(array, predicate, predicateOwner) {\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (predicate.call(predicateOwner, array[i], i)) return array[i];\n    }return null;\n}\n\nfunction arrayRemoveItem(array, itemToRemove) {\n    var index = arrayIndexOf(array, itemToRemove);\n    if (index > 0) {\n        array.splice(index, 1);\n    } else if (index === 0) {\n        array.shift();\n    }\n}\n\nfunction arrayGetDistinctValues(array) {\n    array = array || [];\n    var result = [];\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (arrayIndexOf(result, array[i]) < 0) result.push(array[i]);\n    }\n    return result;\n}\n\nfunction arrayMap(array, mapping) {\n    array = array || [];\n    var result = [];\n    for (var i = 0, j = array.length; i < j; i++) {\n        result.push(mapping(array[i], i));\n    }return result;\n}\n\nfunction arrayFilter(array, predicate) {\n    array = array || [];\n    var result = [];\n    for (var i = 0, j = array.length; i < j; i++) {\n        if (predicate(array[i], i)) result.push(array[i]);\n    }return result;\n}\n\nfunction arrayPushAll(array, valuesToPush) {\n    if (valuesToPush instanceof Array) array.push.apply(array, valuesToPush);else for (var i = 0, j = valuesToPush.length; i < j; i++) {\n        array.push(valuesToPush[i]);\n    }return array;\n}\n\nfunction addOrRemoveItem(array, value, included) {\n    var existingEntryIndex = arrayIndexOf(typeof array.peek === 'function' ? array.peek() : array, value);\n    if (existingEntryIndex < 0) {\n        if (included) array.push(value);\n    } else {\n        if (!included) array.splice(existingEntryIndex, 1);\n    }\n}\n\nfunction makeArray(arrayLikeObject) {\n    var result = [];\n    for (var i = 0, j = arrayLikeObject.length; i < j; i++) {\n        result.push(arrayLikeObject[i]);\n    }\n    return result;\n}\n\nfunction range(min, max) {\n    min = typeof min === 'function' ? min() : min;\n    max = typeof max === 'function' ? max() : max;\n    var result = [];\n    for (var i = min; i <= max; i++) {\n        result.push(i);\n    }return result;\n}\n\n// Go through the items that have been added and deleted and try to find matches between them.\nfunction findMovesInArrayComparison(left, right, limitFailedCompares) {\n    if (left.length && right.length) {\n        var failedCompares, l, r, leftItem, rightItem;\n        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {\n            for (r = 0; rightItem = right[r]; ++r) {\n                if (leftItem['value'] === rightItem['value']) {\n                    leftItem['moved'] = rightItem['index'];\n                    rightItem['moved'] = leftItem['index'];\n                    right.splice(r, 1); // This item is marked as moved; so remove it from right list\n                    failedCompares = r = 0; // Reset failed compares count because we're checking for consecutive failures\n                    break;\n                }\n            }\n            failedCompares += r;\n        }\n    }\n}\n\nvar statusNotInOld = 'added';\nvar statusNotInNew = 'deleted';\n\n// Simple calculation based on Levenshtein distance.\nfunction compareArrays(oldArray, newArray, options) {\n    // For backward compatibility, if the third arg is actually a bool, interpret\n    // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.\n    options = typeof options === 'boolean' ? { 'dontLimitMoves': options } : options || {};\n    oldArray = oldArray || [];\n    newArray = newArray || [];\n\n    if (oldArray.length < newArray.length) return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);else return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);\n}\n\nfunction compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {\n    var myMin = Math.min,\n        myMax = Math.max,\n        editDistanceMatrix = [],\n        smlIndex,\n        smlIndexMax = smlArray.length,\n        bigIndex,\n        bigIndexMax = bigArray.length,\n        compareRange = bigIndexMax - smlIndexMax || 1,\n        maxDistance = smlIndexMax + bigIndexMax + 1,\n        thisRow,\n        lastRow,\n        bigIndexMaxForRow,\n        bigIndexMinForRow;\n\n    for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {\n        lastRow = thisRow;\n        editDistanceMatrix.push(thisRow = []);\n        bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);\n        bigIndexMinForRow = myMax(0, smlIndex - 1);\n        for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {\n            if (!bigIndex) thisRow[bigIndex] = smlIndex + 1;else if (!smlIndex) // Top row - transform empty array into new array via additions\n                thisRow[bigIndex] = bigIndex + 1;else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1]) thisRow[bigIndex] = lastRow[bigIndex - 1]; // copy value (no edit)\n            else {\n                    var northDistance = lastRow[bigIndex] || maxDistance; // not in big (deletion)\n                    var westDistance = thisRow[bigIndex - 1] || maxDistance; // not in small (addition)\n                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;\n                }\n        }\n    }\n\n    var editScript = [],\n        meMinusOne,\n        notInSml = [],\n        notInBig = [];\n    for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {\n        meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;\n        if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex - 1]) {\n            notInSml.push(editScript[editScript.length] = { // added\n                'status': statusNotInSml,\n                'value': bigArray[--bigIndex],\n                'index': bigIndex });\n        } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {\n            notInBig.push(editScript[editScript.length] = { // deleted\n                'status': statusNotInBig,\n                'value': smlArray[--smlIndex],\n                'index': smlIndex });\n        } else {\n            --bigIndex;\n            --smlIndex;\n            if (!options['sparse']) {\n                editScript.push({\n                    'status': \"retained\",\n                    'value': bigArray[bigIndex] });\n            }\n        }\n    }\n\n    // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of\n    // smlIndexMax keeps the time complexity of this algorithm linear.\n    findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);\n\n    return editScript.reverse();\n}\n\n//\n// This becomes ko.options\n// --\n//\n// This is the root 'options', which must be extended by others.\n\nvar _global;\n\ntry {\n    _global = window;\n} catch (e) {\n    _global = global;\n}\n\nvar options = {\n    deferUpdates: false,\n\n    useOnlyNativeEvents: false,\n\n    protoProperty: '__ko_proto__',\n\n    // Modify the default attribute from `data-bind`.\n    defaultBindingAttribute: 'data-bind',\n\n    // Enable/disable <!-- ko binding: ... -> style bindings\n    allowVirtualElements: true,\n\n    // Global variables that can be accessed from bindings.\n    bindingGlobals: _global,\n\n    // An instance of the binding provider.\n    bindingProviderInstance: null,\n\n    // jQuery will be automatically set to _global.jQuery in applyBindings\n    // if it is (strictly equal to) undefined.  Set it to false or null to\n    // disable automatically setting jQuery.\n    jQuery: _global && _global.jQuery,\n\n    Promise: _global && _global.Promise,\n\n    taskScheduler: null,\n\n    debug: false,\n\n    global: _global,\n    document: _global.document,\n\n    // Filters for bindings\n    //   data-bind=\"expression | filter_1 | filter_2\"\n    filters: {},\n\n    onError: function onError(e) {\n        throw e;\n    },\n\n    set: function set(name, value) {\n        options[name] = value;\n    }\n};\n\nObject.defineProperty(options, '$', {\n    get: function get() {\n        return options.jQuery;\n    }\n});\n\n//\n// Error handling\n// ---\n//\n// The default onError handler is to re-throw.\nfunction catchFunctionErrors(delegate) {\n    return options.onError ? function () {\n        try {\n            return delegate.apply(this, arguments);\n        } catch (e) {\n            options.onError(e);\n        }\n    } : delegate;\n}\n\nfunction deferError(error) {\n    safeSetTimeout(function () {\n        options.onError(error);\n    }, 0);\n}\n\nfunction safeSetTimeout(handler, timeout) {\n    return setTimeout(catchFunctionErrors(handler), timeout);\n}\n\n//\n// Asynchronous functionality\n// ---\nfunction throttle(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        if (!timeoutInstance) {\n            timeoutInstance = safeSetTimeout(function () {\n                timeoutInstance = undefined;\n                callback();\n            }, timeout);\n        }\n    };\n}\n\nfunction debounce(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        clearTimeout(timeoutInstance);\n        timeoutInstance = safeSetTimeout(callback, timeout);\n    };\n}\n\n//\n// Detection and Workarounds for Internet Explorer\n//\n// Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)\n// Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.\n// Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.\n// If there is a future need to detect specific versions of IE10+, we will amend this.\nvar ieVersion = options.document && function () {\n    var version = 3,\n        div = options.document.createElement('div'),\n        iElems = div.getElementsByTagName('i');\n\n    // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n    while (div.innerHTML = '<!--[if gt IE ' + ++version + ']><i></i><![endif]-->', iElems[0]) {}\n    return version > 4 ? version : undefined;\n}();\n\nvar isIe6 = ieVersion === 6;\nvar isIe7 = ieVersion === 7;\n\n//\n// Object functions\n//\n\nfunction extend(target, source) {\n    if (source) {\n        for (var prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n}\n\nfunction objectForEach(obj, action) {\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            action(prop, obj[prop]);\n        }\n    }\n}\n\nfunction objectMap(source, mapping) {\n    if (!source) return source;\n    var target = {};\n    for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n            target[prop] = mapping(source[prop], prop, source);\n        }\n    }\n    return target;\n}\n\nfunction getObjectOwnProperty(obj, propName) {\n    return obj.hasOwnProperty(propName) ? obj[propName] : undefined;\n}\n\nfunction clonePlainObjectDeep(obj, seen) {\n    if (!seen) {\n        seen = [];\n    }\n\n    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj.constructor !== Object || seen.indexOf(obj) !== -1) {\n        return obj;\n    }\n\n    // Anything that makes it below is a plain object that has not yet\n    // been seen/cloned.\n    seen.push(obj);\n\n    var result = {};\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            result[prop] = clonePlainObjectDeep(obj[prop], seen);\n        }\n    }\n    return result;\n}\n\n//\n// Prototype Functions\n//\nvar protoProperty = options.protoProperty;\n\nvar canSetPrototype = { __proto__: [] } instanceof Array;\n\nfunction setPrototypeOf(obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n}\n\nvar setPrototypeOfOrExtend = canSetPrototype ? setPrototypeOf : extend;\n\nfunction hasPrototype(instance, prototype) {\n    if (instance === null || instance === undefined || instance[protoProperty] === undefined) return false;\n    if (instance[protoProperty] === prototype) return true;\n    return hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n}\n\n//\n// String (and JSON)\n//\n\n\nfunction stringTrim(string) {\n    return string === null || string === undefined ? '' : string.trim ? string.trim() : string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n}\n\nfunction stringStartsWith(string, startsWith) {\n    string = string || \"\";\n    if (startsWith.length > string.length) return false;\n    return string.substring(0, startsWith.length) === startsWith;\n}\n\nfunction parseJson(jsonString) {\n    if (typeof jsonString == \"string\") {\n        jsonString = stringTrim(jsonString);\n        if (jsonString) {\n            if (JSON && JSON.parse) // Use native parsing where available\n                return JSON.parse(jsonString);\n            return new Function(\"return \" + jsonString)(); // Fallback on less safe parsing for older browsers\n        }\n    }\n    return null;\n}\n\nfunction stringifyJson(data, replacer, space) {\n    // replacer and space are optional\n    if (!JSON || !JSON.stringify) throw new Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\n    return JSON.stringify(typeof data === 'function' ? data() : data, replacer, space);\n}\n\n//\n// ES6 Symbols\n//\n\nvar useSymbols = typeof Symbol === 'function';\n\nfunction createSymbolOrString(identifier) {\n    return useSymbols ? Symbol(identifier) : identifier;\n}\n\n//\n// DOM - CSS\n//\n\n// For details on the pattern for changing node classes\n// see: https://github.com/knockout/knockout/issues/1597\nvar cssClassNameRegex = /\\S+/g;\n\nfunction toggleDomNodeCssClass(node, classNames, shouldHaveClass) {\n    var addOrRemoveFn;\n    if (!classNames) {\n        return;\n    }\n    if (_typeof(node.classList) === 'object') {\n        addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];\n        arrayForEach(classNames.match(cssClassNameRegex), function (className) {\n            addOrRemoveFn.call(node.classList, className);\n        });\n    } else if (typeof node.className['baseVal'] === 'string') {\n        // SVG tag .classNames is an SVGAnimatedString instance\n        toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);\n    } else {\n        // node.className ought to be a string.\n        toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);\n    }\n}\n\nfunction toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {\n    // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.\n    var currentClassNames = obj[prop].match(cssClassNameRegex) || [];\n    arrayForEach(classNames.match(cssClassNameRegex), function (className) {\n        addOrRemoveItem(currentClassNames, className, shouldHaveClass);\n    });\n    obj[prop] = currentClassNames.join(\" \");\n}\n\n//\n// jQuery\n//\n// TODO: deprecate in favour of options.$\n\nvar jQueryInstance = options.global && options.global.jQuery;\n\nfunction jQuerySetInstance(jquery) {\n    options.jQuery = jQueryInstance = jquery;\n}\n\n//\n//  Tasks Micro-scheduler\n//  ===\n//\n/* eslint no-cond-assign: 0 */\nvar taskQueue = [];\nvar taskQueueLength = 0;\nvar nextHandle = 1;\nvar nextIndexToProcess = 0;\nvar w = options.global;\n\nif (w && w.MutationObserver && !(w.navigator && w.navigator.standalone)) {\n    // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+, node\n    // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT\n    options.taskScheduler = function (callback) {\n        var div = w.document.createElement(\"div\");\n        new MutationObserver(callback).observe(div, { attributes: true });\n        return function () {\n            div.classList.toggle(\"foo\");\n        };\n    }(scheduledProcess);\n} else if (w && w.document && \"onreadystatechange\" in w.document.createElement(\"script\")) {\n    // IE 6-10\n    // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT\n    options.taskScheduler = function (callback) {\n        var script = document.createElement(\"script\");\n        script.onreadystatechange = function () {\n            script.onreadystatechange = null;\n            document.documentElement.removeChild(script);\n            script = null;\n            callback();\n        };\n        document.documentElement.appendChild(script);\n    };\n} else {\n    options.taskScheduler = function (callback) {\n        setTimeout(callback, 0);\n    };\n}\n\nfunction processTasks() {\n    if (taskQueueLength) {\n        // Each mark represents the end of a logical group of tasks and the number of these groups is\n        // limited to prevent unchecked recursion.\n        var mark = taskQueueLength,\n            countMarks = 0;\n\n        // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue\n        for (var task; nextIndexToProcess < taskQueueLength;) {\n            if (task = taskQueue[nextIndexToProcess++]) {\n                if (nextIndexToProcess > mark) {\n                    if (++countMarks >= 5000) {\n                        nextIndexToProcess = taskQueueLength; // skip all tasks remaining in the queue since any of them could be causing the recursion\n                        deferError(Error(\"'Too much recursion' after processing \" + countMarks + \" task groups.\"));\n                        break;\n                    }\n                    mark = taskQueueLength;\n                }\n                try {\n                    task();\n                } catch (ex) {\n                    deferError(ex);\n                }\n            }\n        }\n    }\n}\n\nfunction scheduledProcess() {\n    processTasks();\n\n    // Reset the queue\n    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n}\n\nfunction scheduleTaskProcessing() {\n    options.taskScheduler(scheduledProcess);\n}\n\nfunction schedule(func) {\n    if (!taskQueueLength) {\n        scheduleTaskProcessing();\n    }\n\n    taskQueue[taskQueueLength++] = func;\n    return nextHandle++;\n}\n\nfunction cancel(handle) {\n    var index = handle - (nextHandle - taskQueueLength);\n    if (index >= nextIndexToProcess && index < taskQueueLength) {\n        taskQueue[index] = null;\n    }\n}\n\n// For testing only: reset the queue and return the previous queue length\nfunction resetForTesting() {\n    var length = taskQueueLength - nextIndexToProcess;\n    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n    return length;\n}\n\nvar tasks = Object.freeze({\n    schedule: schedule,\n    cancel: cancel,\n    resetForTesting: resetForTesting,\n    runEarly: processTasks\n});\n\n/*\r\n  tko.util\r\n  ===\r\n\r\n\r\n*/\n// DOM;\n/*\r\nexport * from './dom/event.js';\r\nexport * from './dom/info.js';\r\nexport * from './dom/manipulation.js';\r\nexport * from './dom/fixes.js';\r\nexport * from './dom/html.js';\r\nexport * from './dom/disposal.js';\r\n\r\n// Sub-Modules;\r\nimport * as memoization from './memoization';\r\nimport * as tasks from './tasks.js';\r\nimport * as virtualElements from './dom/virtualElements.js';\r\nimport * as domData from './dom/data.js';\r\n\r\nexport {tasks, virtualElements, domData, memoization};\r\n*/\n\nexports.tasks = tasks;\nexports.jQuerySetInstance = jQuerySetInstance;\nexports.options = options;\nexports.arrayForEach = arrayForEach;\nexports.arrayIndexOf = arrayIndexOf;\nexports.arrayFirst = arrayFirst;\nexports.arrayRemoveItem = arrayRemoveItem;\nexports.arrayGetDistinctValues = arrayGetDistinctValues;\nexports.arrayMap = arrayMap;\nexports.arrayFilter = arrayFilter;\nexports.arrayPushAll = arrayPushAll;\nexports.addOrRemoveItem = addOrRemoveItem;\nexports.makeArray = makeArray;\nexports.range = range;\nexports.findMovesInArrayComparison = findMovesInArrayComparison;\nexports.compareArrays = compareArrays;\nexports.throttle = throttle;\nexports.debounce = debounce;\nexports.catchFunctionErrors = catchFunctionErrors;\nexports.deferError = deferError;\nexports.safeSetTimeout = safeSetTimeout;\nexports.ieVersion = ieVersion;\nexports.isIe6 = isIe6;\nexports.isIe7 = isIe7;\nexports.extend = extend;\nexports.objectForEach = objectForEach;\nexports.objectMap = objectMap;\nexports.getObjectOwnProperty = getObjectOwnProperty;\nexports.clonePlainObjectDeep = clonePlainObjectDeep;\nexports.canSetPrototype = canSetPrototype;\nexports.setPrototypeOf = setPrototypeOf;\nexports.setPrototypeOfOrExtend = setPrototypeOfOrExtend;\nexports.hasPrototype = hasPrototype;\nexports.stringTrim = stringTrim;\nexports.stringStartsWith = stringStartsWith;\nexports.parseJson = parseJson;\nexports.stringifyJson = stringifyJson;\nexports.useSymbols = useSymbols;\nexports.createSymbolOrString = createSymbolOrString;\nexports.toggleDomNodeCssClass = toggleDomNodeCssClass;\n//# sourceMappingURL=tko.utils.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ 7)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28udXRpbHMuanM/ODRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gQXJyYXkgdXRpbGl0aWVzXG4vL1xuLyogZXNsaW50IG5vLWNvbmQtYXNzaWduOiAwICovXG5cbmZ1bmN0aW9uIGFycmF5Rm9yRWFjaChhcnJheSwgYWN0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgIGFjdGlvbihhcnJheVtpXSwgaSk7XG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgaXRlbSkge1xuICAgIC8vIElFOVxuICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gYXJyYXlGaXJzdChhcnJheSwgcHJlZGljYXRlLCBwcmVkaWNhdGVPd25lcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwocHJlZGljYXRlT3duZXIsIGFycmF5W2ldLCBpKSlcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXJyYXlSZW1vdmVJdGVtKGFycmF5LCBpdGVtVG9SZW1vdmUpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW1Ub1JlbW92ZSk7XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBhcnJheS5zaGlmdCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlHZXREaXN0aW5jdFZhbHVlcyhhcnJheSkge1xuICAgIGFycmF5ID0gYXJyYXkgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheUluZGV4T2YocmVzdWx0LCBhcnJheVtpXSkgPCAwKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgbWFwcGluZykge1xuICAgIGFycmF5ID0gYXJyYXkgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaChtYXBwaW5nKGFycmF5W2ldLCBpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIGFycmF5ID0gYXJyYXkgfHwgW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKVxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldLCBpKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhcnJheVB1c2hBbGwoYXJyYXksIHZhbHVlc1RvUHVzaCkge1xuICAgIGlmICh2YWx1ZXNUb1B1c2ggaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgYXJyYXkucHVzaC5hcHBseShhcnJheSwgdmFsdWVzVG9QdXNoKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdmFsdWVzVG9QdXNoLmxlbmd0aDsgaSA8IGo7IGkrKylcbiAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWVzVG9QdXNoW2ldKTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGFkZE9yUmVtb3ZlSXRlbShhcnJheSwgdmFsdWUsIGluY2x1ZGVkKSB7XG4gICAgdmFyIGV4aXN0aW5nRW50cnlJbmRleCA9IGFycmF5SW5kZXhPZih0eXBlb2YgYXJyYXkucGVlayA9PT0gJ2Z1bmN0aW9uJyA/IGFycmF5LnBlZWsoKSA6IGFycmF5LCB2YWx1ZSk7XG4gICAgaWYgKGV4aXN0aW5nRW50cnlJbmRleCA8IDApIHtcbiAgICAgICAgaWYgKGluY2x1ZGVkKVxuICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlZClcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShleGlzdGluZ0VudHJ5SW5kZXgsIDEpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBtYWtlQXJyYXkoYXJyYXlMaWtlT2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXlMaWtlT2JqZWN0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChhcnJheUxpa2VPYmplY3RbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4KSB7XG4gICAgbWluID0gdHlwZW9mIG1pbiA9PT0gJ2Z1bmN0aW9uJyA/IG1pbigpIDogbWluO1xuICAgIG1heCA9IHR5cGVvZiBtYXggPT09ICdmdW5jdGlvbicgPyBtYXgoKSA6IG1heDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR28gdGhyb3VnaCB0aGUgaXRlbXMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgYW5kIGRlbGV0ZWQgYW5kIHRyeSB0byBmaW5kIG1hdGNoZXMgYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24obGVmdCwgcmlnaHQsIGxpbWl0RmFpbGVkQ29tcGFyZXMpIHtcbiAgICBpZiAobGVmdC5sZW5ndGggJiYgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmYWlsZWRDb21wYXJlcywgbCwgciwgbGVmdEl0ZW0sIHJpZ2h0SXRlbTtcbiAgICAgICAgZm9yIChmYWlsZWRDb21wYXJlcyA9IGwgPSAwOyAoIWxpbWl0RmFpbGVkQ29tcGFyZXMgfHwgZmFpbGVkQ29tcGFyZXMgPCBsaW1pdEZhaWxlZENvbXBhcmVzKSAmJiAobGVmdEl0ZW0gPSBsZWZ0W2xdKTsgKytsKSB7XG4gICAgICAgICAgICBmb3IgKHIgPSAwOyByaWdodEl0ZW0gPSByaWdodFtyXTsgKytyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRJdGVtWyd2YWx1ZSddID09PSByaWdodEl0ZW1bJ3ZhbHVlJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEl0ZW1bJ21vdmVkJ10gPSByaWdodEl0ZW1bJ2luZGV4J107XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0SXRlbVsnbW92ZWQnXSA9IGxlZnRJdGVtWydpbmRleCddO1xuICAgICAgICAgICAgICAgICAgICByaWdodC5zcGxpY2UociwgMSk7ICAgICAgICAgLy8gVGhpcyBpdGVtIGlzIG1hcmtlZCBhcyBtb3ZlZDsgc28gcmVtb3ZlIGl0IGZyb20gcmlnaHQgbGlzdFxuICAgICAgICAgICAgICAgICAgICBmYWlsZWRDb21wYXJlcyA9IHIgPSAwOyAgICAgLy8gUmVzZXQgZmFpbGVkIGNvbXBhcmVzIGNvdW50IGJlY2F1c2Ugd2UncmUgY2hlY2tpbmcgZm9yIGNvbnNlY3V0aXZlIGZhaWx1cmVzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhaWxlZENvbXBhcmVzICs9IHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG52YXIgc3RhdHVzTm90SW5PbGQgPSAnYWRkZWQnO1xudmFyIHN0YXR1c05vdEluTmV3ID0gJ2RlbGV0ZWQnO1xuXG4gICAgLy8gU2ltcGxlIGNhbGN1bGF0aW9uIGJhc2VkIG9uIExldmVuc2h0ZWluIGRpc3RhbmNlLlxuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhvbGRBcnJheSwgbmV3QXJyYXksIG9wdGlvbnMpIHtcbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgaWYgdGhlIHRoaXJkIGFyZyBpcyBhY3R1YWxseSBhIGJvb2wsIGludGVycHJldFxuICAgIC8vIGl0IGFzIHRoZSBvbGQgcGFyYW1ldGVyICdkb250TGltaXRNb3ZlcycuIE5ld2VyIGNvZGUgc2hvdWxkIHVzZSB7IGRvbnRMaW1pdE1vdmVzOiB0cnVlIH0uXG4gICAgb3B0aW9ucyA9ICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSA/IHsgJ2RvbnRMaW1pdE1vdmVzJzogb3B0aW9ucyB9IDogKG9wdGlvbnMgfHwge30pO1xuICAgIG9sZEFycmF5ID0gb2xkQXJyYXkgfHwgW107XG4gICAgbmV3QXJyYXkgPSBuZXdBcnJheSB8fCBbXTtcblxuICAgIGlmIChvbGRBcnJheS5sZW5ndGggPCBuZXdBcnJheS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjb21wYXJlU21hbGxBcnJheVRvQmlnQXJyYXkob2xkQXJyYXksIG5ld0FycmF5LCBzdGF0dXNOb3RJbk9sZCwgc3RhdHVzTm90SW5OZXcsIG9wdGlvbnMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVTbWFsbEFycmF5VG9CaWdBcnJheShuZXdBcnJheSwgb2xkQXJyYXksIHN0YXR1c05vdEluTmV3LCBzdGF0dXNOb3RJbk9sZCwgb3B0aW9ucyk7XG59XG5cblxuZnVuY3Rpb24gY29tcGFyZVNtYWxsQXJyYXlUb0JpZ0FycmF5KHNtbEFycmF5LCBiaWdBcnJheSwgc3RhdHVzTm90SW5TbWwsIHN0YXR1c05vdEluQmlnLCBvcHRpb25zKSB7XG4gICAgdmFyIG15TWluID0gTWF0aC5taW4sXG4gICAgICAgIG15TWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGVkaXREaXN0YW5jZU1hdHJpeCA9IFtdLFxuICAgICAgICBzbWxJbmRleCwgc21sSW5kZXhNYXggPSBzbWxBcnJheS5sZW5ndGgsXG4gICAgICAgIGJpZ0luZGV4LCBiaWdJbmRleE1heCA9IGJpZ0FycmF5Lmxlbmd0aCxcbiAgICAgICAgY29tcGFyZVJhbmdlID0gKGJpZ0luZGV4TWF4IC0gc21sSW5kZXhNYXgpIHx8IDEsXG4gICAgICAgIG1heERpc3RhbmNlID0gc21sSW5kZXhNYXggKyBiaWdJbmRleE1heCArIDEsXG4gICAgICAgIHRoaXNSb3csIGxhc3RSb3csXG4gICAgICAgIGJpZ0luZGV4TWF4Rm9yUm93LCBiaWdJbmRleE1pbkZvclJvdztcblxuICAgIGZvciAoc21sSW5kZXggPSAwOyBzbWxJbmRleCA8PSBzbWxJbmRleE1heDsgc21sSW5kZXgrKykge1xuICAgICAgICBsYXN0Um93ID0gdGhpc1JvdztcbiAgICAgICAgZWRpdERpc3RhbmNlTWF0cml4LnB1c2godGhpc1JvdyA9IFtdKTtcbiAgICAgICAgYmlnSW5kZXhNYXhGb3JSb3cgPSBteU1pbihiaWdJbmRleE1heCwgc21sSW5kZXggKyBjb21wYXJlUmFuZ2UpO1xuICAgICAgICBiaWdJbmRleE1pbkZvclJvdyA9IG15TWF4KDAsIHNtbEluZGV4IC0gMSk7XG4gICAgICAgIGZvciAoYmlnSW5kZXggPSBiaWdJbmRleE1pbkZvclJvdzsgYmlnSW5kZXggPD0gYmlnSW5kZXhNYXhGb3JSb3c7IGJpZ0luZGV4KyspIHtcbiAgICAgICAgICAgIGlmICghYmlnSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBzbWxJbmRleCArIDE7XG4gICAgICAgICAgICBlbHNlIGlmICghc21sSW5kZXgpICAvLyBUb3Agcm93IC0gdHJhbnNmb3JtIGVtcHR5IGFycmF5IGludG8gbmV3IGFycmF5IHZpYSBhZGRpdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzUm93W2JpZ0luZGV4XSA9IGJpZ0luZGV4ICsgMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNtbEFycmF5W3NtbEluZGV4IC0gMV0gPT09IGJpZ0FycmF5W2JpZ0luZGV4IC0gMV0pXG4gICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBsYXN0Um93W2JpZ0luZGV4IC0gMV07ICAgICAgICAgICAgICAgICAgLy8gY29weSB2YWx1ZSAobm8gZWRpdClcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub3J0aERpc3RhbmNlID0gbGFzdFJvd1tiaWdJbmRleF0gfHwgbWF4RGlzdGFuY2U7ICAgICAgIC8vIG5vdCBpbiBiaWcgKGRlbGV0aW9uKVxuICAgICAgICAgICAgICAgIHZhciB3ZXN0RGlzdGFuY2UgPSB0aGlzUm93W2JpZ0luZGV4IC0gMV0gfHwgbWF4RGlzdGFuY2U7ICAgIC8vIG5vdCBpbiBzbWFsbCAoYWRkaXRpb24pXG4gICAgICAgICAgICAgICAgdGhpc1Jvd1tiaWdJbmRleF0gPSBteU1pbihub3J0aERpc3RhbmNlLCB3ZXN0RGlzdGFuY2UpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0U2NyaXB0ID0gW10sIG1lTWludXNPbmUsIG5vdEluU21sID0gW10sIG5vdEluQmlnID0gW107XG4gICAgZm9yIChzbWxJbmRleCA9IHNtbEluZGV4TWF4LCBiaWdJbmRleCA9IGJpZ0luZGV4TWF4OyBzbWxJbmRleCB8fCBiaWdJbmRleDspIHtcbiAgICAgICAgbWVNaW51c09uZSA9IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleF1bYmlnSW5kZXhdIC0gMTtcbiAgICAgICAgaWYgKGJpZ0luZGV4ICYmIG1lTWludXNPbmUgPT09IGVkaXREaXN0YW5jZU1hdHJpeFtzbWxJbmRleF1bYmlnSW5kZXgtMV0pIHtcbiAgICAgICAgICAgIG5vdEluU21sLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBhZGRlZFxuICAgICAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXNOb3RJblNtbCxcbiAgICAgICAgICAgICAgICAndmFsdWUnOiBiaWdBcnJheVstLWJpZ0luZGV4XSxcbiAgICAgICAgICAgICAgICAnaW5kZXgnOiBiaWdJbmRleCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzbWxJbmRleCAmJiBtZU1pbnVzT25lID09PSBlZGl0RGlzdGFuY2VNYXRyaXhbc21sSW5kZXggLSAxXVtiaWdJbmRleF0pIHtcbiAgICAgICAgICAgIG5vdEluQmlnLnB1c2goZWRpdFNjcmlwdFtlZGl0U2NyaXB0Lmxlbmd0aF0gPSB7ICAgICAvLyBkZWxldGVkXG4gICAgICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1c05vdEluQmlnLFxuICAgICAgICAgICAgICAgICd2YWx1ZSc6IHNtbEFycmF5Wy0tc21sSW5kZXhdLFxuICAgICAgICAgICAgICAgICdpbmRleCc6IHNtbEluZGV4IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLS1iaWdJbmRleDtcbiAgICAgICAgICAgIC0tc21sSW5kZXg7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNbJ3NwYXJzZSddKSB7XG4gICAgICAgICAgICAgICAgZWRpdFNjcmlwdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IFwicmV0YWluZWRcIixcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogYmlnQXJyYXlbYmlnSW5kZXhdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGEgbGltaXQgb24gdGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBub24tbWF0Y2hpbmcgY29tcGFyaXNvbnM7IGhhdmluZyBpdCBhIG11bHRpcGxlIG9mXG4gICAgLy8gc21sSW5kZXhNYXgga2VlcHMgdGhlIHRpbWUgY29tcGxleGl0eSBvZiB0aGlzIGFsZ29yaXRobSBsaW5lYXIuXG4gICAgZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24obm90SW5CaWcsIG5vdEluU21sLCAhb3B0aW9uc1snZG9udExpbWl0TW92ZXMnXSAmJiBzbWxJbmRleE1heCAqIDEwKTtcblxuICAgIHJldHVybiBlZGl0U2NyaXB0LnJldmVyc2UoKTtcbn1cblxuLy9cbi8vIFRoaXMgYmVjb21lcyBrby5vcHRpb25zXG4vLyAtLVxuLy9cbi8vIFRoaXMgaXMgdGhlIHJvb3QgJ29wdGlvbnMnLCB3aGljaCBtdXN0IGJlIGV4dGVuZGVkIGJ5IG90aGVycy5cblxudmFyIF9nbG9iYWw7XG5cbnRyeSB7IF9nbG9iYWwgPSB3aW5kb3c7IH0gY2F0Y2ggKGUpIHsgX2dsb2JhbCA9IGdsb2JhbDsgfVxuXG52YXIgb3B0aW9ucyA9IHtcbiAgZGVmZXJVcGRhdGVzOiBmYWxzZSxcblxuICB1c2VPbmx5TmF0aXZlRXZlbnRzOiBmYWxzZSxcblxuICBwcm90b1Byb3BlcnR5OiAnX19rb19wcm90b19fJyxcblxuICAgIC8vIE1vZGlmeSB0aGUgZGVmYXVsdCBhdHRyaWJ1dGUgZnJvbSBgZGF0YS1iaW5kYC5cbiAgZGVmYXVsdEJpbmRpbmdBdHRyaWJ1dGU6ICdkYXRhLWJpbmQnLFxuXG4gICAgLy8gRW5hYmxlL2Rpc2FibGUgPCEtLSBrbyBiaW5kaW5nOiAuLi4gLT4gc3R5bGUgYmluZGluZ3NcbiAgYWxsb3dWaXJ0dWFsRWxlbWVudHM6IHRydWUsXG5cbiAgICAvLyBHbG9iYWwgdmFyaWFibGVzIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIGZyb20gYmluZGluZ3MuXG4gIGJpbmRpbmdHbG9iYWxzOiBfZ2xvYmFsLFxuXG4gICAgLy8gQW4gaW5zdGFuY2Ugb2YgdGhlIGJpbmRpbmcgcHJvdmlkZXIuXG4gIGJpbmRpbmdQcm92aWRlckluc3RhbmNlOiBudWxsLFxuXG4gICAgLy8galF1ZXJ5IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gX2dsb2JhbC5qUXVlcnkgaW4gYXBwbHlCaW5kaW5nc1xuICAgIC8vIGlmIGl0IGlzIChzdHJpY3RseSBlcXVhbCB0bykgdW5kZWZpbmVkLiAgU2V0IGl0IHRvIGZhbHNlIG9yIG51bGwgdG9cbiAgICAvLyBkaXNhYmxlIGF1dG9tYXRpY2FsbHkgc2V0dGluZyBqUXVlcnkuXG4gIGpRdWVyeTogX2dsb2JhbCAmJiBfZ2xvYmFsLmpRdWVyeSxcblxuICBQcm9taXNlOiBfZ2xvYmFsICYmIF9nbG9iYWwuUHJvbWlzZSxcblxuICB0YXNrU2NoZWR1bGVyOiBudWxsLFxuXG4gIGRlYnVnOiBmYWxzZSxcblxuICBnbG9iYWw6IF9nbG9iYWwsXG4gIGRvY3VtZW50OiBfZ2xvYmFsLmRvY3VtZW50LFxuXG4gICAgLy8gRmlsdGVycyBmb3IgYmluZGluZ3NcbiAgICAvLyAgIGRhdGEtYmluZD1cImV4cHJlc3Npb24gfCBmaWx0ZXJfMSB8IGZpbHRlcl8yXCJcbiAgZmlsdGVyczoge30sXG5cbiAgb25FcnJvcjogZnVuY3Rpb24gKGUpIHsgdGhyb3cgZSB9LFxuXG4gIHNldDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJyQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb3B0aW9ucy5qUXVlcnkgfVxufSk7XG5cbi8vXG4vLyBFcnJvciBoYW5kbGluZ1xuLy8gLS0tXG4vL1xuLy8gVGhlIGRlZmF1bHQgb25FcnJvciBoYW5kbGVyIGlzIHRvIHJlLXRocm93LlxuZnVuY3Rpb24gY2F0Y2hGdW5jdGlvbkVycm9ycyhkZWxlZ2F0ZSkge1xuICAgIHJldHVybiBvcHRpb25zLm9uRXJyb3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfSA6IGRlbGVnYXRlO1xufVxuXG5mdW5jdGlvbiBkZWZlckVycm9yKGVycm9yKSB7XG4gICAgc2FmZVNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBvcHRpb25zLm9uRXJyb3IoZXJyb3IpOyB9LCAwKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlU2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2F0Y2hGdW5jdGlvbkVycm9ycyhoYW5kbGVyKSwgdGltZW91dCk7XG59XG5cbi8vXG4vLyBBc3luY2hyb25vdXMgZnVuY3Rpb25hbGl0eVxuLy8gLS0tXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0SW5zdGFuY2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aW1lb3V0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXRJbnN0YW5jZSA9IHNhZmVTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dEluc3RhbmNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SW5zdGFuY2UpO1xuICAgICAgICB0aW1lb3V0SW5zdGFuY2UgPSBzYWZlU2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCk7XG4gICAgfTtcbn1cblxuLy9cbi8vIERldGVjdGlvbiBhbmQgV29ya2Fyb3VuZHMgZm9yIEludGVybmV0IEV4cGxvcmVyXG4vL1xuLy8gRGV0ZWN0IElFIHZlcnNpb25zIGZvciBidWcgd29ya2Fyb3VuZHMgKHVzZXMgSUUgY29uZGl0aW9uYWxzLCBub3QgVUEgc3RyaW5nLCBmb3Igcm9idXN0bmVzcylcbi8vIE5vdGUgdGhhdCwgc2luY2UgSUUgMTAgZG9lcyBub3Qgc3VwcG9ydCBjb25kaXRpb25hbCBjb21tZW50cywgdGhlIGZvbGxvd2luZyBsb2dpYyBvbmx5IGRldGVjdHMgSUUgPCAxMC5cbi8vIEN1cnJlbnRseSB0aGlzIGlzIGJ5IGRlc2lnbiwgc2luY2UgSUUgMTArIGJlaGF2ZXMgY29ycmVjdGx5IHdoZW4gdHJlYXRlZCBhcyBhIHN0YW5kYXJkIGJyb3dzZXIuXG4vLyBJZiB0aGVyZSBpcyBhIGZ1dHVyZSBuZWVkIHRvIGRldGVjdCBzcGVjaWZpYyB2ZXJzaW9ucyBvZiBJRTEwKywgd2Ugd2lsbCBhbWVuZCB0aGlzLlxudmFyIGllVmVyc2lvbiA9IG9wdGlvbnMuZG9jdW1lbnQgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlcnNpb24gPSAzLCBkaXYgPSBvcHRpb25zLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBpRWxlbXMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2knKTtcblxuICAgIC8vIEtlZXAgY29uc3RydWN0aW5nIGNvbmRpdGlvbmFsIEhUTUwgYmxvY2tzIHVudGlsIHdlIGhpdCBvbmUgdGhhdCByZXNvbHZlcyB0byBhbiBlbXB0eSBmcmFnbWVudFxuICB3aGlsZSAoXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCEtLVtpZiBndCBJRSAnICsgKCsrdmVyc2lvbikgKyAnXT48aT48L2k+PCFbZW5kaWZdLS0+JyxcbiAgICAgICAgaUVsZW1zWzBdXG4gICAgKSB7fVxuICByZXR1cm4gdmVyc2lvbiA+IDQgPyB2ZXJzaW9uIDogdW5kZWZpbmVkXG59KCkpO1xuXG52YXIgaXNJZTYgPSBpZVZlcnNpb24gPT09IDY7XG52YXIgaXNJZTcgPSBpZVZlcnNpb24gPT09IDc7XG5cbi8vXG4vLyBPYmplY3QgZnVuY3Rpb25zXG4vL1xuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvcih2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RGb3JFYWNoKG9iaiwgYWN0aW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgYWN0aW9uKHByb3AsIG9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gb2JqZWN0TWFwKHNvdXJjZSwgbWFwcGluZykge1xuICAgIGlmICghc291cmNlKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBtYXBwaW5nKHNvdXJjZVtwcm9wXSwgcHJvcCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIGdldE9iamVjdE93blByb3BlcnR5KG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IG9ialtwcm9wTmFtZV0gOiB1bmRlZmluZWQ7XG59XG5cblxuZnVuY3Rpb24gY2xvbmVQbGFpbk9iamVjdERlZXAob2JqLCBzZWVuKSB7XG4gICAgaWYgKCFzZWVuKSB7IHNlZW4gPSBbXTsgfVxuXG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCdcbiAgICAgICAgfHwgb2JqLmNvbnN0cnVjdG9yICE9PSBPYmplY3RcbiAgICAgICAgfHwgc2Vlbi5pbmRleE9mKG9iaikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgdGhhdCBtYWtlcyBpdCBiZWxvdyBpcyBhIHBsYWluIG9iamVjdCB0aGF0IGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiBzZWVuL2Nsb25lZC5cbiAgICBzZWVuLnB1c2gob2JqKTtcblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBjbG9uZVBsYWluT2JqZWN0RGVlcChvYmpbcHJvcF0sIHNlZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vXG4vLyBQcm90b3R5cGUgRnVuY3Rpb25zXG4vL1xudmFyIHByb3RvUHJvcGVydHkgPSBvcHRpb25zLnByb3RvUHJvcGVydHk7XG5cbnZhciBjYW5TZXRQcm90b3R5cGUgPSAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSk7XG5cbmZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKG9iaiwgcHJvdG8pIHtcbiAgICBvYmouX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIG9iajtcbn1cblxudmFyIHNldFByb3RvdHlwZU9mT3JFeHRlbmQgPSBjYW5TZXRQcm90b3R5cGUgPyBzZXRQcm90b3R5cGVPZiA6IGV4dGVuZDtcblxuZnVuY3Rpb24gaGFzUHJvdG90eXBlKGluc3RhbmNlLCBwcm90b3R5cGUpIHtcbiAgICBpZiAoKGluc3RhbmNlID09PSBudWxsKSB8fCAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkgfHwgKGluc3RhbmNlW3Byb3RvUHJvcGVydHldID09PSB1bmRlZmluZWQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGluc3RhbmNlW3Byb3RvUHJvcGVydHldID09PSBwcm90b3R5cGUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBoYXNQcm90b3R5cGUoaW5zdGFuY2VbcHJvdG9Qcm9wZXJ0eV0sIHByb3RvdHlwZSk7IC8vIFdhbGsgdGhlIHByb3RvdHlwZSBjaGFpblxufVxuXG4vL1xuLy8gU3RyaW5nIChhbmQgSlNPTilcbi8vXG5cblxuZnVuY3Rpb24gc3RyaW5nVHJpbSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcnIDpcbiAgICAgICAgc3RyaW5nLnRyaW0gP1xuICAgICAgICAgICAgc3RyaW5nLnRyaW0oKSA6XG4gICAgICAgICAgICBzdHJpbmcudG9TdHJpbmcoKS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csICcnKTtcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTdGFydHNXaXRoIChzdHJpbmcsIHN0YXJ0c1dpdGgpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcgfHwgXCJcIjtcbiAgICBpZiAoc3RhcnRzV2l0aC5sZW5ndGggPiBzdHJpbmcubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgc3RhcnRzV2l0aC5sZW5ndGgpID09PSBzdGFydHNXaXRoO1xufVxuXG5cbmZ1bmN0aW9uIHBhcnNlSnNvbiAoanNvblN0cmluZykge1xuICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGpzb25TdHJpbmcgPSBzdHJpbmdUcmltKGpzb25TdHJpbmcpO1xuICAgICAgICBpZiAoanNvblN0cmluZykge1xuICAgICAgICAgICAgaWYgKEpTT04gJiYgSlNPTi5wYXJzZSkgLy8gVXNlIG5hdGl2ZSBwYXJzaW5nIHdoZXJlIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBqc29uU3RyaW5nKSkoKTsgLy8gRmFsbGJhY2sgb24gbGVzcyBzYWZlIHBhcnNpbmcgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5SnNvbiAoZGF0YSwgcmVwbGFjZXIsIHNwYWNlKSB7ICAgLy8gcmVwbGFjZXIgYW5kIHNwYWNlIGFyZSBvcHRpb25hbFxuICAgIGlmICghSlNPTiB8fCAhSlNPTi5zdHJpbmdpZnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIEpTT04uc3RyaW5naWZ5KCkuIFNvbWUgYnJvd3NlcnMgKGUuZy4sIElFIDwgOCkgZG9uJ3Qgc3VwcG9ydCBpdCBuYXRpdmVseSwgYnV0IHlvdSBjYW4gb3ZlcmNvbWUgdGhpcyBieSBhZGRpbmcgYSBzY3JpcHQgcmVmZXJlbmNlIHRvIGpzb24yLmpzLCBkb3dubG9hZGFibGUgZnJvbSBodHRwOi8vd3d3Lmpzb24ub3JnL2pzb24yLmpzXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IGRhdGEoKSA6IGRhdGEsIHJlcGxhY2VyLCBzcGFjZSk7XG59XG5cbi8vXG4vLyBFUzYgU3ltYm9sc1xuLy9cblxudmFyIHVzZVN5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBjcmVhdGVTeW1ib2xPclN0cmluZyhpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHVzZVN5bWJvbHMgPyBTeW1ib2woaWRlbnRpZmllcikgOiBpZGVudGlmaWVyO1xufVxuXG4vL1xuLy8gRE9NIC0gQ1NTXG4vL1xuXG4vLyBGb3IgZGV0YWlscyBvbiB0aGUgcGF0dGVybiBmb3IgY2hhbmdpbmcgbm9kZSBjbGFzc2VzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9rbm9ja291dC9rbm9ja291dC9pc3N1ZXMvMTU5N1xudmFyIGNzc0NsYXNzTmFtZVJlZ2V4ID0gL1xcUysvZztcblxuXG5mdW5jdGlvbiB0b2dnbGVEb21Ob2RlQ3NzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lcywgc2hvdWxkSGF2ZUNsYXNzKSB7XG4gICAgdmFyIGFkZE9yUmVtb3ZlRm47XG4gICAgaWYgKCFjbGFzc05hbWVzKSB7IHJldHVybjsgfVxuICAgIGlmICh0eXBlb2Ygbm9kZS5jbGFzc0xpc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFkZE9yUmVtb3ZlRm4gPSBub2RlLmNsYXNzTGlzdFtzaG91bGRIYXZlQ2xhc3MgPyAnYWRkJyA6ICdyZW1vdmUnXTtcbiAgICAgICAgYXJyYXlGb3JFYWNoKGNsYXNzTmFtZXMubWF0Y2goY3NzQ2xhc3NOYW1lUmVnZXgpLCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGFkZE9yUmVtb3ZlRm4uY2FsbChub2RlLmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5jbGFzc05hbWVbJ2Jhc2VWYWwnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gU1ZHIHRhZyAuY2xhc3NOYW1lcyBpcyBhbiBTVkdBbmltYXRlZFN0cmluZyBpbnN0YW5jZVxuICAgICAgICB0b2dnbGVPYmplY3RDbGFzc1Byb3BlcnR5U3RyaW5nKG5vZGUuY2xhc3NOYW1lLCAnYmFzZVZhbCcsIGNsYXNzTmFtZXMsIHNob3VsZEhhdmVDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm9kZS5jbGFzc05hbWUgb3VnaHQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICAgIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcobm9kZSwgJ2NsYXNzTmFtZScsIGNsYXNzTmFtZXMsIHNob3VsZEhhdmVDbGFzcyk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIHRvZ2dsZU9iamVjdENsYXNzUHJvcGVydHlTdHJpbmcob2JqLCBwcm9wLCBjbGFzc05hbWVzLCBzaG91bGRIYXZlQ2xhc3MpIHtcbiAgICAvLyBvYmovcHJvcCBpcyBlaXRoZXIgYSBub2RlLydjbGFzc05hbWUnIG9yIGEgU1ZHQW5pbWF0ZWRTdHJpbmcvJ2Jhc2VWYWwnLlxuICAgIHZhciBjdXJyZW50Q2xhc3NOYW1lcyA9IG9ialtwcm9wXS5tYXRjaChjc3NDbGFzc05hbWVSZWdleCkgfHwgW107XG4gICAgYXJyYXlGb3JFYWNoKGNsYXNzTmFtZXMubWF0Y2goY3NzQ2xhc3NOYW1lUmVnZXgpLCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgYWRkT3JSZW1vdmVJdGVtKGN1cnJlbnRDbGFzc05hbWVzLCBjbGFzc05hbWUsIHNob3VsZEhhdmVDbGFzcyk7XG4gICAgfSk7XG4gICAgb2JqW3Byb3BdID0gY3VycmVudENsYXNzTmFtZXMuam9pbihcIiBcIik7XG59XG5cbi8vXG4vLyBqUXVlcnlcbi8vXG4vLyBUT0RPOiBkZXByZWNhdGUgaW4gZmF2b3VyIG9mIG9wdGlvbnMuJFxuXG52YXIgalF1ZXJ5SW5zdGFuY2UgPSBvcHRpb25zLmdsb2JhbCAmJiBvcHRpb25zLmdsb2JhbC5qUXVlcnk7XG5cbmZ1bmN0aW9uIGpRdWVyeVNldEluc3RhbmNlKGpxdWVyeSkge1xuICAgIG9wdGlvbnMualF1ZXJ5ID0galF1ZXJ5SW5zdGFuY2UgPSBqcXVlcnk7XG59XG5cbi8vXG4vLyAgVGFza3MgTWljcm8tc2NoZWR1bGVyXG4vLyAgPT09XG4vL1xuLyogZXNsaW50IG5vLWNvbmQtYXNzaWduOiAwICovXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGFza1F1ZXVlTGVuZ3RoID0gMDtcbnZhciBuZXh0SGFuZGxlID0gMTtcbnZhciBuZXh0SW5kZXhUb1Byb2Nlc3MgPSAwO1xudmFyIHcgPSBvcHRpb25zLmdsb2JhbDtcblxuaWYgKHcgJiYgdy5NdXRhdGlvbk9ic2VydmVyICYmICEody5uYXZpZ2F0b3IgJiYgdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICAvLyBDaHJvbWUgMjcrLCBGaXJlZm94IDE0KywgSUUgMTErLCBPcGVyYSAxNSssIFNhZmFyaSA2LjErLCBub2RlXG4gICAgLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkICogQ29weXJpZ2h0IChjKSAyMDE0IFBldGthIEFudG9ub3YgKiBMaWNlbnNlOiBNSVRcbiAgICBvcHRpb25zLnRhc2tTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkaXYgPSB3LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKS5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7IH07XG4gICAgfSkoc2NoZWR1bGVkUHJvY2Vzcyk7XG59IGVsc2UgaWYgKHcgJiYgdy5kb2N1bWVudCAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIHcuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgIC8vIElFIDYtMTBcbiAgICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ZdXp1SlMvc2V0SW1tZWRpYXRlICogQ29weXJpZ2h0IChjKSAyMDEyIEJhcm5lc2FuZG5vYmxlLmNvbSwgbGxjLCBEb25hdm9uIFdlc3QsIGFuZCBEb21lbmljIERlbmljb2xhICogTGljZW5zZTogTUlUXG4gICAgb3B0aW9ucy50YXNrU2NoZWR1bGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBvcHRpb25zLnRhc2tTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Rhc2tzKCkge1xuICAgIGlmICh0YXNrUXVldWVMZW5ndGgpIHtcbiAgICAgICAgLy8gRWFjaCBtYXJrIHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhIGxvZ2ljYWwgZ3JvdXAgb2YgdGFza3MgYW5kIHRoZSBudW1iZXIgb2YgdGhlc2UgZ3JvdXBzIGlzXG4gICAgICAgIC8vIGxpbWl0ZWQgdG8gcHJldmVudCB1bmNoZWNrZWQgcmVjdXJzaW9uLlxuICAgICAgICB2YXIgbWFyayA9IHRhc2tRdWV1ZUxlbmd0aCwgY291bnRNYXJrcyA9IDA7XG5cbiAgICAgICAgLy8gbmV4dEluZGV4VG9Qcm9jZXNzIGtlZXBzIHRyYWNrIG9mIHdoZXJlIHdlIGFyZSBpbiB0aGUgcXVldWU7IHByb2Nlc3NUYXNrcyBjYW4gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IHdpdGhvdXQgaXNzdWVcbiAgICAgICAgZm9yICh2YXIgdGFzazsgbmV4dEluZGV4VG9Qcm9jZXNzIDwgdGFza1F1ZXVlTGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGlmICh0YXNrID0gdGFza1F1ZXVlW25leHRJbmRleFRvUHJvY2VzcysrXSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SW5kZXhUb1Byb2Nlc3MgPiBtYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50TWFya3MgPj0gNTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEluZGV4VG9Qcm9jZXNzID0gdGFza1F1ZXVlTGVuZ3RoOyAgIC8vIHNraXAgYWxsIHRhc2tzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUgc2luY2UgYW55IG9mIHRoZW0gY291bGQgYmUgY2F1c2luZyB0aGUgcmVjdXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlckVycm9yKEVycm9yKFwiJ1RvbyBtdWNoIHJlY3Vyc2lvbicgYWZ0ZXIgcHJvY2Vzc2luZyBcIiArIGNvdW50TWFya3MgKyBcIiB0YXNrIGdyb3Vwcy5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFyayA9IHRhc2tRdWV1ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyRXJyb3IoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVkUHJvY2VzcygpIHtcbiAgICBwcm9jZXNzVGFza3MoKTtcblxuICAgIC8vIFJlc2V0IHRoZSBxdWV1ZVxuICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aCA9IHRhc2tRdWV1ZS5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVRhc2tQcm9jZXNzaW5nKCkge1xuICAgIG9wdGlvbnMudGFza1NjaGVkdWxlcihzY2hlZHVsZWRQcm9jZXNzKTtcbn1cblxuXG5mdW5jdGlvbiBzY2hlZHVsZShmdW5jKSB7XG4gICAgaWYgKCF0YXNrUXVldWVMZW5ndGgpIHtcbiAgICAgICAgc2NoZWR1bGVUYXNrUHJvY2Vzc2luZygpO1xuICAgIH1cblxuICAgIHRhc2tRdWV1ZVt0YXNrUXVldWVMZW5ndGgrK10gPSBmdW5jO1xuICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbChoYW5kbGUpIHtcbiAgICB2YXIgaW5kZXggPSBoYW5kbGUgLSAobmV4dEhhbmRsZSAtIHRhc2tRdWV1ZUxlbmd0aCk7XG4gICAgaWYgKGluZGV4ID49IG5leHRJbmRleFRvUHJvY2VzcyAmJiBpbmRleCA8IHRhc2tRdWV1ZUxlbmd0aCkge1xuICAgICAgICB0YXNrUXVldWVbaW5kZXhdID0gbnVsbDtcbiAgICB9XG59XG5cbi8vIEZvciB0ZXN0aW5nIG9ubHk6IHJlc2V0IHRoZSBxdWV1ZSBhbmQgcmV0dXJuIHRoZSBwcmV2aW91cyBxdWV1ZSBsZW5ndGhcbmZ1bmN0aW9uIHJlc2V0Rm9yVGVzdGluZygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGFza1F1ZXVlTGVuZ3RoIC0gbmV4dEluZGV4VG9Qcm9jZXNzO1xuICAgIG5leHRJbmRleFRvUHJvY2VzcyA9IHRhc2tRdWV1ZUxlbmd0aCA9IHRhc2tRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5cblxuXG5cbnZhciB0YXNrcyA9IE9iamVjdC5mcmVlemUoe1xuXHRzY2hlZHVsZTogc2NoZWR1bGUsXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRyZXNldEZvclRlc3Rpbmc6IHJlc2V0Rm9yVGVzdGluZyxcblx0cnVuRWFybHk6IHByb2Nlc3NUYXNrc1xufSk7XG5cbi8qXHJcbiAgdGtvLnV0aWxcclxuICA9PT1cclxuXHJcblxyXG4qL1xyXG4vLyBET007XHJcbi8qXHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2V2ZW50LmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kb20vaW5mby5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL21hbmlwdWxhdGlvbi5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2ZpeGVzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kb20vaHRtbC5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2Rpc3Bvc2FsLmpzJztcclxuXHJcbi8vIFN1Yi1Nb2R1bGVzO1xyXG5pbXBvcnQgKiBhcyBtZW1vaXphdGlvbiBmcm9tICcuL21lbW9pemF0aW9uJztcclxuaW1wb3J0ICogYXMgdGFza3MgZnJvbSAnLi90YXNrcy5qcyc7XHJcbmltcG9ydCAqIGFzIHZpcnR1YWxFbGVtZW50cyBmcm9tICcuL2RvbS92aXJ0dWFsRWxlbWVudHMuanMnO1xyXG5pbXBvcnQgKiBhcyBkb21EYXRhIGZyb20gJy4vZG9tL2RhdGEuanMnO1xyXG5cclxuZXhwb3J0IHt0YXNrcywgdmlydHVhbEVsZW1lbnRzLCBkb21EYXRhLCBtZW1vaXphdGlvbn07XHJcbiovXG5cbmV4cG9ydCB7IHRhc2tzLCBqUXVlcnlTZXRJbnN0YW5jZSwgb3B0aW9ucywgYXJyYXlGb3JFYWNoLCBhcnJheUluZGV4T2YsIGFycmF5Rmlyc3QsIGFycmF5UmVtb3ZlSXRlbSwgYXJyYXlHZXREaXN0aW5jdFZhbHVlcywgYXJyYXlNYXAsIGFycmF5RmlsdGVyLCBhcnJheVB1c2hBbGwsIGFkZE9yUmVtb3ZlSXRlbSwgbWFrZUFycmF5LCByYW5nZSwgZmluZE1vdmVzSW5BcnJheUNvbXBhcmlzb24sIGNvbXBhcmVBcnJheXMsIHRocm90dGxlLCBkZWJvdW5jZSwgY2F0Y2hGdW5jdGlvbkVycm9ycywgZGVmZXJFcnJvciwgc2FmZVNldFRpbWVvdXQsIGllVmVyc2lvbiwgaXNJZTYsIGlzSWU3LCBleHRlbmQsIG9iamVjdEZvckVhY2gsIG9iamVjdE1hcCwgZ2V0T2JqZWN0T3duUHJvcGVydHksIGNsb25lUGxhaW5PYmplY3REZWVwLCBjYW5TZXRQcm90b3R5cGUsIHNldFByb3RvdHlwZU9mLCBzZXRQcm90b3R5cGVPZk9yRXh0ZW5kLCBoYXNQcm90b3R5cGUsIHN0cmluZ1RyaW0sIHN0cmluZ1N0YXJ0c1dpdGgsIHBhcnNlSnNvbiwgc3RyaW5naWZ5SnNvbiwgdXNlU3ltYm9scywgY3JlYXRlU3ltYm9sT3JTdHJpbmcsIHRvZ2dsZURvbU5vZGVDc3NDbGFzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGtvLnV0aWxzLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvdGtvL3Rrby51dGlscy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUNBO0FBMkNBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!**************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/tko/tko.computed.js ***!
  \**************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.throttleExtender = exports.pureComputed = exports.isPureComputed = exports.isComputed = exports.computed = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _tkoUtils = __webpack_require__(/*! ./tko.utils.js */ 1);\n\nvar _tkoObservable = __webpack_require__(/*! ./tko.observable.js */ 0);\n\n//\n// Computed Observable Values\n//\n// (before tko, `computed` was also known as `dependentObservable`)\n//\nvar computedState = (0, _tkoUtils.createSymbolOrString)('_state');\n\nfunction computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options$$1) {\n  if ((typeof evaluatorFunctionOrOptions === 'undefined' ? 'undefined' : _typeof(evaluatorFunctionOrOptions)) === 'object') {\n    // Single-parameter syntax - everything is on this \"options\" param\n    options$$1 = evaluatorFunctionOrOptions;\n  } else {\n    // Multi-parameter syntax - construct the options according to the params passed\n    options$$1 = options$$1 || {};\n    if (evaluatorFunctionOrOptions) {\n      options$$1.read = evaluatorFunctionOrOptions;\n    }\n  }\n  if (typeof options$$1.read !== 'function') {\n    throw Error('Pass a function that returns the value of the computed');\n  }\n\n  var writeFunction = options$$1.write;\n  var state = {\n    latestValue: undefined,\n    isStale: true,\n    isBeingEvaluated: false,\n    suppressDisposalUntilDisposeWhenReturnsFalse: false,\n    isDisposed: false,\n    pure: false,\n    isSleeping: false,\n    readFunction: options$$1.read,\n    evaluatorFunctionTarget: evaluatorFunctionTarget || options$$1.owner,\n    disposeWhenNodeIsRemoved: options$$1.disposeWhenNodeIsRemoved || options$$1.disposeWhenNodeIsRemoved || null,\n    disposeWhen: options$$1.disposeWhen || options$$1.disposeWhen,\n    domNodeDisposalCallback: null,\n    dependencyTracking: {},\n    dependenciesCount: 0,\n    evaluationTimeoutInstance: null\n  };\n\n  function computedObservable() {\n    if (arguments.length > 0) {\n      if (typeof writeFunction === 'function') {\n        // Writing a value\n        writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n      } else {\n        throw new Error(\"Cannot write a value to a computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n      }\n      return this; // Permits chained assignments\n    } else {\n      // Reading the value\n      _tkoObservable.dependencyDetection.registerDependency(computedObservable);\n      if (state.isStale || state.isSleeping && computedObservable.haveDependenciesChanged()) {\n        computedObservable.evaluateImmediate();\n      }\n      return state.latestValue;\n    }\n  }\n\n  computedObservable[computedState] = state;\n  computedObservable.hasWriteFunction = typeof writeFunction === 'function';\n\n  // Inherit from 'subscribable'\n  if (!_tkoUtils.canSetPrototype) {\n    // 'subscribable' won't be on the prototype chain unless we put it there directly\n    (0, _tkoUtils.extend)(computedObservable, _tkoObservable.subscribable.fn);\n  }\n  _tkoObservable.subscribable.fn.init(computedObservable);\n\n  // Inherit from 'computed'\n  (0, _tkoUtils.setPrototypeOfOrExtend)(computedObservable, computed.fn);\n\n  if (options$$1.pure) {\n    state.pure = true;\n    state.isSleeping = true; // Starts off sleeping; will awake on the first subscription\n    (0, _tkoUtils.extend)(computedObservable, pureComputedOverrides);\n  } else if (options$$1.deferEvaluation) {\n    (0, _tkoUtils.extend)(computedObservable, deferEvaluationOverrides);\n  }\n\n  if (_tkoUtils.options.deferUpdates) {\n    _tkoObservable.extenders.deferred(computedObservable, true);\n  }\n\n  if (_tkoUtils.options.debug) {\n    // #1731 - Aid debugging by exposing the computed's options\n    computedObservable._options = options$$1;\n  }\n\n  if (state.disposeWhenNodeIsRemoved) {\n    // Since this computed is associated with a DOM node, and we don't want to dispose the computed\n    // until the DOM node is *removed* from the document (as opposed to never having been in the document),\n    // we'll prevent disposal until \"disposeWhen\" first returns false.\n    state.suppressDisposalUntilDisposeWhenReturnsFalse = true;\n\n    // disposeWhenNodeIsRemoved: true can be used to opt into the \"only dispose after first false result\"\n    // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try\n    // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't\n    // be documented or used by application code, as it's likely to change in a future version of KO.\n    if (!state.disposeWhenNodeIsRemoved.nodeType) {\n      state.disposeWhenNodeIsRemoved = null;\n    }\n  }\n\n  // Evaluate, unless sleeping or deferEvaluation is true\n  if (!state.isSleeping && !options$$1.deferEvaluation) {\n    computedObservable.evaluateImmediate();\n  }\n\n  return computedObservable;\n}\n\n// Utility function that disposes a given dependencyTracking entry\nfunction computedDisposeDependencyCallback(id, entryToDispose) {\n  if (entryToDispose !== null && entryToDispose.dispose) {\n    entryToDispose.dispose();\n  }\n}\n\n// This function gets called each time a dependency is detected while evaluating a computed.\n// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\nfunction computedBeginDependencyDetectionCallback(subscribable$$1, id) {\n  var computedObservable = this.computedObservable,\n      state = computedObservable[computedState];\n  if (!state.isDisposed) {\n    if (this.disposalCount && this.disposalCandidates[id]) {\n      // Don't want to dispose this subscription, as it's still being used\n      computedObservable.addDependencyTracking(id, subscribable$$1, this.disposalCandidates[id]);\n      this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n      --this.disposalCount;\n    } else if (!state.dependencyTracking[id]) {\n      // Brand new subscription - add it\n      computedObservable.addDependencyTracking(id, subscribable$$1, state.isSleeping ? { _target: subscribable$$1 } : computedObservable.subscribeToDependency(subscribable$$1));\n    }\n  }\n}\n\ncomputed.fn = {\n  equalityComparer: _tkoObservable.valuesArePrimitiveAndEqual,\n  getDependenciesCount: function getDependenciesCount() {\n    return this[computedState].dependenciesCount;\n  },\n  addDependencyTracking: function addDependencyTracking(id, target, trackingObj) {\n    if (this[computedState].pure && target === this) {\n      throw Error(\"A 'pure' computed must not be called recursively\");\n    }\n\n    this[computedState].dependencyTracking[id] = trackingObj;\n    trackingObj._order = this[computedState].dependenciesCount++;\n    trackingObj._version = target.getVersion();\n  },\n  haveDependenciesChanged: function haveDependenciesChanged() {\n    var id,\n        dependency,\n        dependencyTracking = this[computedState].dependencyTracking;\n    for (id in dependencyTracking) {\n      if (dependencyTracking.hasOwnProperty(id)) {\n        dependency = dependencyTracking[id];\n        if (dependency._target.hasChanged(dependency._version)) {\n          return true;\n        }\n      }\n    }\n  },\n  markDirty: function markDirty() {\n    // Process \"dirty\" events if we can handle delayed notifications\n    if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n      this._evalDelayed();\n    }\n  },\n  isActive: function isActive() {\n    return this[computedState].isStale || this[computedState].dependenciesCount > 0;\n  },\n  respondToChange: function respondToChange() {\n    // Ignore \"change\" events if we've already scheduled a delayed notification\n    if (!this._notificationIsPending) {\n      this.evaluatePossiblyAsync();\n    }\n  },\n  subscribeToDependency: function subscribeToDependency(target) {\n    if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {\n      var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),\n          changeSub = target.subscribe(this.respondToChange, this);\n      return {\n        _target: target,\n        dispose: function dispose() {\n          dirtySub.dispose();\n          changeSub.dispose();\n        }\n      };\n    } else {\n      return target.subscribe(this.evaluatePossiblyAsync, this);\n    }\n  },\n  evaluatePossiblyAsync: function evaluatePossiblyAsync() {\n    var computedObservable = this,\n        throttleEvaluationTimeout = computedObservable.throttleEvaluation;\n    if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n      clearTimeout(this[computedState].evaluationTimeoutInstance);\n      this[computedState].evaluationTimeoutInstance = (0, _tkoUtils.safeSetTimeout)(function () {\n        computedObservable.evaluateImmediate(true /* notifyChange */);\n      }, throttleEvaluationTimeout);\n    } else if (computedObservable._evalDelayed) {\n      computedObservable._evalDelayed();\n    } else {\n      computedObservable.evaluateImmediate(true /* notifyChange */);\n    }\n  },\n  evaluateImmediate: function evaluateImmediate(notifyChange) {\n    var computedObservable = this,\n        state = computedObservable[computedState],\n        disposeWhen = state.disposeWhen;\n\n    if (state.isBeingEvaluated) {\n      // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n      // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n      // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n      // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n      return;\n    }\n\n    // Do not evaluate (and possibly capture new dependencies) if disposed\n    if (state.isDisposed) {\n      return;\n    }\n\n    // It just did return false, so we can stop suppressing now\n    state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n\n    state.isBeingEvaluated = true;\n    try {\n      this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n    } finally {\n      state.isBeingEvaluated = false;\n    }\n\n    if (!state.dependenciesCount) {\n      computedObservable.dispose();\n    }\n  },\n  evaluateImmediate_CallReadWithDependencyDetection: function evaluateImmediate_CallReadWithDependencyDetection(notifyChange) {\n    // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n    // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n    // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n    var computedObservable = this,\n        state = computedObservable[computedState];\n\n    // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n    // Then, during evaluation, we cross off any that are in fact still being used.\n    var isInitial = state.pure ? undefined : !state.dependenciesCount,\n        // If we're evaluating when there are no previous dependencies, it must be the first time\n    dependencyDetectionContext = {\n      computedObservable: computedObservable,\n      disposalCandidates: state.dependencyTracking,\n      disposalCount: state.dependenciesCount\n    };\n\n    _tkoObservable.dependencyDetection.begin({\n      callbackTarget: dependencyDetectionContext,\n      callback: computedBeginDependencyDetectionCallback,\n      computed: computedObservable,\n      isInitial: isInitial\n    });\n\n    state.dependencyTracking = {};\n    state.dependenciesCount = 0;\n\n    var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n    if (computedObservable.isDifferent(state.latestValue, newValue)) {\n      if (!state.isSleeping) {\n        computedObservable.notifySubscribers(state.latestValue, 'beforeChange');\n      }\n\n      state.latestValue = newValue;\n\n      if (state.isSleeping) {\n        computedObservable.updateVersion();\n      } else if (notifyChange) {\n        computedObservable.notifySubscribers(state.latestValue);\n      }\n    }\n\n    if (isInitial) {\n      computedObservable.notifySubscribers(state.latestValue, 'awake');\n    }\n  },\n  evaluateImmediate_CallReadThenEndDependencyDetection: function evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext) {\n    // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n    // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n    // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n    // overhead of computed evaluation (on V8 at least).\n\n    try {\n      var readFunction = state.readFunction;\n      return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();\n    } finally {\n      _tkoObservable.dependencyDetection.end();\n\n      // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n      if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n        (0, _tkoUtils.objectForEach)(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n      }\n\n      state.isStale = false;\n    }\n  },\n  peek: function peek() {\n    // Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when \"deferEvaluation\" is set.\n    var state = this[computedState];\n    if (state.isStale && !state.dependenciesCount || state.isSleeping && this.haveDependenciesChanged()) {\n      this.evaluateImmediate();\n    }\n    return state.latestValue;\n  },\n  limit: function limit(limitFunction) {\n    // Override the limit function with one that delays evaluation as well\n    _tkoObservable.subscribable.fn.limit.call(this, limitFunction);\n    this._evalDelayed = function () {\n      this._limitBeforeChange(this[computedState].latestValue);\n\n      this[computedState].isStale = true; // Mark as dirty\n\n      // Pass the observable to the \"limit\" code, which will access it when\n      // it's time to do the notification.\n      this._limitChange(this);\n    };\n  },\n  dispose: function dispose() {\n    var state = this[computedState];\n    if (!state.isSleeping && state.dependencyTracking) {\n      (0, _tkoUtils.objectForEach)(state.dependencyTracking, function (id, dependency) {\n        if (dependency.dispose) {\n          dependency.dispose();\n        }\n      });\n    }\n    state.dependencyTracking = null;\n    state.dependenciesCount = 0;\n    state.isDisposed = true;\n    state.isStale = false;\n    state.isSleeping = false;\n    state.disposeWhenNodeIsRemoved = null;\n    state.readFunction = null;\n    if (_tkoUtils.options.debug) {\n      this._options = null;\n    }\n  }\n};\n\nvar pureComputedOverrides = {\n  beforeSubscriptionAdd: function beforeSubscriptionAdd(event) {\n    // If asleep, wake up the computed by subscribing to any dependencies.\n    var computedObservable = this,\n        state = computedObservable[computedState];\n    if (!state.isDisposed && state.isSleeping && event == 'change') {\n      state.isSleeping = false;\n      if (state.isStale || computedObservable.haveDependenciesChanged()) {\n        state.dependencyTracking = null;\n        state.dependenciesCount = 0;\n        state.isStale = true;\n        computedObservable.evaluateImmediate();\n      } else {\n        // First put the dependencies in order\n        var dependeciesOrder = [];\n        (0, _tkoUtils.objectForEach)(state.dependencyTracking, function (id, dependency) {\n          dependeciesOrder[dependency._order] = id;\n        });\n        // Next, subscribe to each one\n        (0, _tkoUtils.arrayForEach)(dependeciesOrder, function (id, order) {\n          var dependency = state.dependencyTracking[id],\n              subscription = computedObservable.subscribeToDependency(dependency._target);\n          subscription._order = order;\n          subscription._version = dependency._version;\n          state.dependencyTracking[id] = subscription;\n        });\n      }\n      if (!state.isDisposed) {\n        // test since evaluating could trigger disposal\n        computedObservable.notifySubscribers(state.latestValue, 'awake');\n      }\n    }\n  },\n  afterSubscriptionRemove: function afterSubscriptionRemove(event) {\n    var state = this[computedState];\n    if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {\n      (0, _tkoUtils.objectForEach)(state.dependencyTracking, function (id, dependency) {\n        if (dependency.dispose) {\n          state.dependencyTracking[id] = {\n            _target: dependency._target,\n            _order: dependency._order,\n            _version: dependency._version\n          };\n          dependency.dispose();\n        }\n      });\n      state.isSleeping = true;\n      this.notifySubscribers(undefined, 'asleep');\n    }\n  },\n  getVersion: function getVersion() {\n    // Because a pure computed is not automatically updated while it is sleeping, we can't\n    // simply return the version number. Instead, we check if any of the dependencies have\n    // changed and conditionally re-evaluate the computed observable.\n    var state = this[computedState];\n    if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n      this.evaluateImmediate();\n    }\n    return _tkoObservable.subscribable.fn.getVersion.call(this);\n  }\n};\n\nvar deferEvaluationOverrides = {\n  beforeSubscriptionAdd: function beforeSubscriptionAdd(event) {\n    // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n    if (event == 'change' || event == 'beforeChange') {\n      this.peek();\n    }\n  }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.computed constructor\nif (_tkoUtils.canSetPrototype) {\n  (0, _tkoUtils.setPrototypeOf)(computed.fn, _tkoObservable.subscribable.fn);\n}\n\n// Set the proto chain values for ko.hasPrototype\nvar protoProp = _tkoObservable.observable.protoProperty; // == \"__ko_proto__\"\ncomputed[protoProp] = _tkoObservable.observable;\ncomputed.fn[protoProp] = computed;\n\nfunction isComputed(instance) {\n  return (0, _tkoUtils.hasPrototype)(instance, computed);\n}\n\nfunction isPureComputed(instance) {\n  return (0, _tkoUtils.hasPrototype)(instance, computed) && instance[computedState] && instance[computedState].pure;\n}\n\nfunction pureComputed(evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n  if (typeof evaluatorFunctionOrOptions === 'function') {\n    return computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, { 'pure': true });\n  } else {\n    evaluatorFunctionOrOptions = (0, _tkoUtils.extend)({}, evaluatorFunctionOrOptions); // make a copy of the parameter object\n    evaluatorFunctionOrOptions.pure = true;\n    return computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);\n  }\n}\n\nfunction throttleExtender(target, timeout) {\n  // Throttling means two things:\n\n  // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n  //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n  target.throttleEvaluation = timeout;\n\n  // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n  //     so the target cannot change value synchronously or faster than a certain rate\n  var writeTimeoutInstance = null;\n  return computed({\n    read: target,\n    write: function write(value) {\n      clearTimeout(writeTimeoutInstance);\n      writeTimeoutInstance = setTimeout(function () {\n        target(value);\n      }, timeout);\n    }\n  });\n}\n\n_tkoObservable.extenders.throttle = throttleExtender;\n\n//\n// tko.computed - Exports\n//\n// knockout -> tko changes:\n//      Deprecates `dependentObservable` (use `computed`)\n//\n\nexports.computed = computed;\nexports.isComputed = isComputed;\nexports.isPureComputed = isPureComputed;\nexports.pureComputed = pureComputed;\nexports.throttleExtender = throttleExtender;\n//# sourceMappingURL=tko.computed.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28uY29tcHV0ZWQuanM/NTJjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcnJheUZvckVhY2gsIGNhblNldFByb3RvdHlwZSwgY3JlYXRlU3ltYm9sT3JTdHJpbmcsIGV4dGVuZCwgaGFzUHJvdG90eXBlLCBvYmplY3RGb3JFYWNoLCBvcHRpb25zLCBzYWZlU2V0VGltZW91dCwgc2V0UHJvdG90eXBlT2YsIHNldFByb3RvdHlwZU9mT3JFeHRlbmQgfSBmcm9tICcuL3Rrby51dGlscy5qcyc7XG5pbXBvcnQgeyBkZXBlbmRlbmN5RGV0ZWN0aW9uLCBleHRlbmRlcnMsIG9ic2VydmFibGUsIHN1YnNjcmliYWJsZSwgdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwgfSBmcm9tICcuL3Rrby5vYnNlcnZhYmxlLmpzJztcblxuLy9cbi8vIENvbXB1dGVkIE9ic2VydmFibGUgVmFsdWVzXG4vL1xuLy8gKGJlZm9yZSB0a28sIGBjb21wdXRlZGAgd2FzIGFsc28ga25vd24gYXMgYGRlcGVuZGVudE9ic2VydmFibGVgKVxuLy9cbnZhciBjb21wdXRlZFN0YXRlID0gY3JlYXRlU3ltYm9sT3JTdHJpbmcoJ19zdGF0ZScpO1xuXG5mdW5jdGlvbiBjb21wdXRlZCAoZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMsIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0LCBvcHRpb25zJCQxKSB7XG4gIGlmICh0eXBlb2YgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFNpbmdsZS1wYXJhbWV0ZXIgc3ludGF4IC0gZXZlcnl0aGluZyBpcyBvbiB0aGlzIFwib3B0aW9uc1wiIHBhcmFtXG4gICAgb3B0aW9ucyQkMSA9IGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgICAgICAvLyBNdWx0aS1wYXJhbWV0ZXIgc3ludGF4IC0gY29uc3RydWN0IHRoZSBvcHRpb25zIGFjY29yZGluZyB0byB0aGUgcGFyYW1zIHBhc3NlZFxuICAgIG9wdGlvbnMkJDEgPSBvcHRpb25zJCQxIHx8IHt9O1xuICAgIGlmIChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucykge1xuICAgICAgb3B0aW9ucyQkMS5yZWFkID0gZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnM7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyQkMS5yZWFkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1Bhc3MgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjb21wdXRlZCcpXG4gIH1cblxuICB2YXIgd3JpdGVGdW5jdGlvbiA9IG9wdGlvbnMkJDEud3JpdGU7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBsYXRlc3RWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGlzU3RhbGU6IHRydWUsXG4gICAgaXNCZWluZ0V2YWx1YXRlZDogZmFsc2UsXG4gICAgc3VwcHJlc3NEaXNwb3NhbFVudGlsRGlzcG9zZVdoZW5SZXR1cm5zRmFsc2U6IGZhbHNlLFxuICAgIGlzRGlzcG9zZWQ6IGZhbHNlLFxuICAgIHB1cmU6IGZhbHNlLFxuICAgIGlzU2xlZXBpbmc6IGZhbHNlLFxuICAgIHJlYWRGdW5jdGlvbjogb3B0aW9ucyQkMS5yZWFkLFxuICAgIGV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0OiBldmFsdWF0b3JGdW5jdGlvblRhcmdldCB8fCBvcHRpb25zJCQxLm93bmVyLFxuICAgIGRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZDogb3B0aW9ucyQkMS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgfHwgb3B0aW9ucyQkMS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQgfHwgbnVsbCxcbiAgICBkaXNwb3NlV2hlbjogb3B0aW9ucyQkMS5kaXNwb3NlV2hlbiB8fCBvcHRpb25zJCQxLmRpc3Bvc2VXaGVuLFxuICAgIGRvbU5vZGVEaXNwb3NhbENhbGxiYWNrOiBudWxsLFxuICAgIGRlcGVuZGVuY3lUcmFja2luZzoge30sXG4gICAgZGVwZW5kZW5jaWVzQ291bnQ6IDAsXG4gICAgZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZTogbnVsbFxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbXB1dGVkT2JzZXJ2YWJsZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIHdyaXRlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBXcml0aW5nIGEgdmFsdWVcbiAgICAgICAgd3JpdGVGdW5jdGlvbi5hcHBseShzdGF0ZS5ldmFsdWF0b3JGdW5jdGlvblRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSBhIHZhbHVlIHRvIGEgY29tcHV0ZWQgdW5sZXNzIHlvdSBzcGVjaWZ5IGEgJ3dyaXRlJyBvcHRpb24uIElmIHlvdSB3aXNoIHRvIHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUsIGRvbid0IHBhc3MgYW55IHBhcmFtZXRlcnMuXCIpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcyAvLyBQZXJtaXRzIGNoYWluZWQgYXNzaWdubWVudHNcbiAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVhZGluZyB0aGUgdmFsdWVcbiAgICAgIGRlcGVuZGVuY3lEZXRlY3Rpb24ucmVnaXN0ZXJEZXBlbmRlbmN5KGNvbXB1dGVkT2JzZXJ2YWJsZSk7XG4gICAgICBpZiAoc3RhdGUuaXNTdGFsZSB8fCAoc3RhdGUuaXNTbGVlcGluZyAmJiBjb21wdXRlZE9ic2VydmFibGUuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubGF0ZXN0VmFsdWVcbiAgICB9XG4gIH1cblxuICBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV0gPSBzdGF0ZTtcbiAgY29tcHV0ZWRPYnNlcnZhYmxlLmhhc1dyaXRlRnVuY3Rpb24gPSB0eXBlb2Ygd3JpdGVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIC8vIEluaGVyaXQgZnJvbSAnc3Vic2NyaWJhYmxlJ1xuICBpZiAoIWNhblNldFByb3RvdHlwZSkge1xuICAgICAgICAvLyAnc3Vic2NyaWJhYmxlJyB3b24ndCBiZSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIHVubGVzcyB3ZSBwdXQgaXQgdGhlcmUgZGlyZWN0bHlcbiAgICBleHRlbmQoY29tcHV0ZWRPYnNlcnZhYmxlLCBzdWJzY3JpYmFibGUuZm4pO1xuICB9XG4gIHN1YnNjcmliYWJsZS5mbi5pbml0KGNvbXB1dGVkT2JzZXJ2YWJsZSk7XG5cbiAgICAvLyBJbmhlcml0IGZyb20gJ2NvbXB1dGVkJ1xuICBzZXRQcm90b3R5cGVPZk9yRXh0ZW5kKGNvbXB1dGVkT2JzZXJ2YWJsZSwgY29tcHV0ZWQuZm4pO1xuXG4gIGlmIChvcHRpb25zJCQxLnB1cmUpIHtcbiAgICBzdGF0ZS5wdXJlID0gdHJ1ZTtcbiAgICBzdGF0ZS5pc1NsZWVwaW5nID0gdHJ1ZTsgICAgIC8vIFN0YXJ0cyBvZmYgc2xlZXBpbmc7IHdpbGwgYXdha2Ugb24gdGhlIGZpcnN0IHN1YnNjcmlwdGlvblxuICAgIGV4dGVuZChjb21wdXRlZE9ic2VydmFibGUsIHB1cmVDb21wdXRlZE92ZXJyaWRlcyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyQkMS5kZWZlckV2YWx1YXRpb24pIHtcbiAgICBleHRlbmQoY29tcHV0ZWRPYnNlcnZhYmxlLCBkZWZlckV2YWx1YXRpb25PdmVycmlkZXMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZGVmZXJVcGRhdGVzKSB7XG4gICAgZXh0ZW5kZXJzLmRlZmVycmVkKGNvbXB1dGVkT2JzZXJ2YWJsZSwgdHJ1ZSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAvLyAjMTczMSAtIEFpZCBkZWJ1Z2dpbmcgYnkgZXhwb3NpbmcgdGhlIGNvbXB1dGVkJ3Mgb3B0aW9uc1xuICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5fb3B0aW9ucyA9IG9wdGlvbnMkJDE7XG4gIH1cblxuICBpZiAoc3RhdGUuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgY29tcHV0ZWQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgRE9NIG5vZGUsIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc3Bvc2UgdGhlIGNvbXB1dGVkXG4gICAgICAgIC8vIHVudGlsIHRoZSBET00gbm9kZSBpcyAqcmVtb3ZlZCogZnJvbSB0aGUgZG9jdW1lbnQgKGFzIG9wcG9zZWQgdG8gbmV2ZXIgaGF2aW5nIGJlZW4gaW4gdGhlIGRvY3VtZW50KSxcbiAgICAgICAgLy8gd2UnbGwgcHJldmVudCBkaXNwb3NhbCB1bnRpbCBcImRpc3Bvc2VXaGVuXCIgZmlyc3QgcmV0dXJucyBmYWxzZS5cbiAgICBzdGF0ZS5zdXBwcmVzc0Rpc3Bvc2FsVW50aWxEaXNwb3NlV2hlblJldHVybnNGYWxzZSA9IHRydWU7XG5cbiAgICAgICAgLy8gZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkOiB0cnVlIGNhbiBiZSB1c2VkIHRvIG9wdCBpbnRvIHRoZSBcIm9ubHkgZGlzcG9zZSBhZnRlciBmaXJzdCBmYWxzZSByZXN1bHRcIlxuICAgICAgICAvLyBiZWhhdmlvdXIgZXZlbiBpZiB0aGVyZSdzIG5vIHNwZWNpZmljIG5vZGUgdG8gd2F0Y2guIEluIHRoYXQgY2FzZSwgY2xlYXIgdGhlIG9wdGlvbiBzbyB3ZSBkb24ndCB0cnlcbiAgICAgICAgLy8gdG8gd2F0Y2ggZm9yIGEgbm9uLW5vZGUncyBkaXNwb3NhbC4gVGhpcyB0ZWNobmlxdWUgaXMgaW50ZW5kZWQgZm9yIEtPJ3MgaW50ZXJuYWwgdXNlIG9ubHkgYW5kIHNob3VsZG4ndFxuICAgICAgICAvLyBiZSBkb2N1bWVudGVkIG9yIHVzZWQgYnkgYXBwbGljYXRpb24gY29kZSwgYXMgaXQncyBsaWtlbHkgdG8gY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgS08uXG4gICAgaWYgKCFzdGF0ZS5kaXNwb3NlV2hlbk5vZGVJc1JlbW92ZWQubm9kZVR5cGUpIHtcbiAgICAgIHN0YXRlLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgICAvLyBFdmFsdWF0ZSwgdW5sZXNzIHNsZWVwaW5nIG9yIGRlZmVyRXZhbHVhdGlvbiBpcyB0cnVlXG4gIGlmICghc3RhdGUuaXNTbGVlcGluZyAmJiAhb3B0aW9ucyQkMS5kZWZlckV2YWx1YXRpb24pIHtcbiAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgfVxuXG4gIHJldHVybiBjb21wdXRlZE9ic2VydmFibGVcbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGRpc3Bvc2VzIGEgZ2l2ZW4gZGVwZW5kZW5jeVRyYWNraW5nIGVudHJ5XG5mdW5jdGlvbiBjb21wdXRlZERpc3Bvc2VEZXBlbmRlbmN5Q2FsbGJhY2sgKGlkLCBlbnRyeVRvRGlzcG9zZSkge1xuICBpZiAoZW50cnlUb0Rpc3Bvc2UgIT09IG51bGwgJiYgZW50cnlUb0Rpc3Bvc2UuZGlzcG9zZSkge1xuICAgIGVudHJ5VG9EaXNwb3NlLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGVhY2ggdGltZSBhIGRlcGVuZGVuY3kgaXMgZGV0ZWN0ZWQgd2hpbGUgZXZhbHVhdGluZyBhIGNvbXB1dGVkLlxuLy8gSXQncyBmYWN0b3JlZCBvdXQgYXMgYSBzaGFyZWQgZnVuY3Rpb24gdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3NhcnkgZnVuY3Rpb24gaW5zdGFuY2VzIGR1cmluZyBldmFsdWF0aW9uLlxuZnVuY3Rpb24gY29tcHV0ZWRCZWdpbkRlcGVuZGVuY3lEZXRlY3Rpb25DYWxsYmFjayAoc3Vic2NyaWJhYmxlJCQxLCBpZCkge1xuICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcy5jb21wdXRlZE9ic2VydmFibGUsXG4gICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV07XG4gIGlmICghc3RhdGUuaXNEaXNwb3NlZCkge1xuICAgIGlmICh0aGlzLmRpc3Bvc2FsQ291bnQgJiYgdGhpcy5kaXNwb3NhbENhbmRpZGF0ZXNbaWRdKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB3YW50IHRvIGRpc3Bvc2UgdGhpcyBzdWJzY3JpcHRpb24sIGFzIGl0J3Mgc3RpbGwgYmVpbmcgdXNlZFxuICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmFkZERlcGVuZGVuY3lUcmFja2luZyhpZCwgc3Vic2NyaWJhYmxlJCQxLCB0aGlzLmRpc3Bvc2FsQ2FuZGlkYXRlc1tpZF0pO1xuICAgICAgdGhpcy5kaXNwb3NhbENhbmRpZGF0ZXNbaWRdID0gbnVsbDsgLy8gTm8gbmVlZCB0byBhY3R1YWxseSBkZWxldGUgdGhlIHByb3BlcnR5IC0gZGlzcG9zYWxDYW5kaWRhdGVzIGlzIGEgdHJhbnNpZW50IG9iamVjdCBhbnl3YXlcbiAgICAgIC0tdGhpcy5kaXNwb3NhbENvdW50O1xuICAgIH0gZWxzZSBpZiAoIXN0YXRlLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0pIHtcbiAgICAgICAgICAgIC8vIEJyYW5kIG5ldyBzdWJzY3JpcHRpb24gLSBhZGQgaXRcbiAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5hZGREZXBlbmRlbmN5VHJhY2tpbmcoaWQsIHN1YnNjcmliYWJsZSQkMSwgc3RhdGUuaXNTbGVlcGluZyA/IHsgX3RhcmdldDogc3Vic2NyaWJhYmxlJCQxIH0gOiBjb21wdXRlZE9ic2VydmFibGUuc3Vic2NyaWJlVG9EZXBlbmRlbmN5KHN1YnNjcmliYWJsZSQkMSkpO1xuICAgIH1cbiAgfVxufVxuXG5jb21wdXRlZC5mbiA9IHtcbiAgZXF1YWxpdHlDb21wYXJlcjogdmFsdWVzQXJlUHJpbWl0aXZlQW5kRXF1YWwsXG4gIGdldERlcGVuZGVuY2llc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbY29tcHV0ZWRTdGF0ZV0uZGVwZW5kZW5jaWVzQ291bnRcbiAgfSxcbiAgYWRkRGVwZW5kZW5jeVRyYWNraW5nOiBmdW5jdGlvbiAoaWQsIHRhcmdldCwgdHJhY2tpbmdPYmopIHtcbiAgICBpZiAodGhpc1tjb21wdXRlZFN0YXRlXS5wdXJlICYmIHRhcmdldCA9PT0gdGhpcykge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBICdwdXJlJyBjb21wdXRlZCBtdXN0IG5vdCBiZSBjYWxsZWQgcmVjdXJzaXZlbHlcIilcbiAgICB9XG5cbiAgICB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSB0cmFja2luZ09iajtcbiAgICB0cmFja2luZ09iai5fb3JkZXIgPSB0aGlzW2NvbXB1dGVkU3RhdGVdLmRlcGVuZGVuY2llc0NvdW50Kys7XG4gICAgdHJhY2tpbmdPYmouX3ZlcnNpb24gPSB0YXJnZXQuZ2V0VmVyc2lvbigpO1xuICB9LFxuICBoYXZlRGVwZW5kZW5jaWVzQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCwgZGVwZW5kZW5jeSwgZGVwZW5kZW5jeVRyYWNraW5nID0gdGhpc1tjb21wdXRlZFN0YXRlXS5kZXBlbmRlbmN5VHJhY2tpbmc7XG4gICAgZm9yIChpZCBpbiBkZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5VHJhY2tpbmcuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5VHJhY2tpbmdbaWRdO1xuICAgICAgICBpZiAoZGVwZW5kZW5jeS5fdGFyZ2V0Lmhhc0NoYW5nZWQoZGVwZW5kZW5jeS5fdmVyc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtYXJrRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJvY2VzcyBcImRpcnR5XCIgZXZlbnRzIGlmIHdlIGNhbiBoYW5kbGUgZGVsYXllZCBub3RpZmljYXRpb25zXG4gICAgaWYgKHRoaXMuX2V2YWxEZWxheWVkICYmICF0aGlzW2NvbXB1dGVkU3RhdGVdLmlzQmVpbmdFdmFsdWF0ZWQpIHtcbiAgICAgIHRoaXMuX2V2YWxEZWxheWVkKCk7XG4gICAgfVxuICB9LFxuICBpc0FjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW2NvbXB1dGVkU3RhdGVdLmlzU3RhbGUgfHwgdGhpc1tjb21wdXRlZFN0YXRlXS5kZXBlbmRlbmNpZXNDb3VudCA+IDBcbiAgfSxcbiAgcmVzcG9uZFRvQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElnbm9yZSBcImNoYW5nZVwiIGV2ZW50cyBpZiB3ZSd2ZSBhbHJlYWR5IHNjaGVkdWxlZCBhIGRlbGF5ZWQgbm90aWZpY2F0aW9uXG4gICAgaWYgKCF0aGlzLl9ub3RpZmljYXRpb25Jc1BlbmRpbmcpIHtcbiAgICAgIHRoaXMuZXZhbHVhdGVQb3NzaWJseUFzeW5jKCk7XG4gICAgfVxuICB9LFxuICBzdWJzY3JpYmVUb0RlcGVuZGVuY3k6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Ll9kZWZlclVwZGF0ZXMgJiYgIXRoaXNbY29tcHV0ZWRTdGF0ZV0uZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkKSB7XG4gICAgICB2YXIgZGlydHlTdWIgPSB0YXJnZXQuc3Vic2NyaWJlKHRoaXMubWFya0RpcnR5LCB0aGlzLCAnZGlydHknKSxcbiAgICAgICAgY2hhbmdlU3ViID0gdGFyZ2V0LnN1YnNjcmliZSh0aGlzLnJlc3BvbmRUb0NoYW5nZSwgdGhpcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJ0eVN1Yi5kaXNwb3NlKCk7XG4gICAgICAgICAgY2hhbmdlU3ViLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LnN1YnNjcmliZSh0aGlzLmV2YWx1YXRlUG9zc2libHlBc3luYywgdGhpcylcbiAgICB9XG4gIH0sXG4gIGV2YWx1YXRlUG9zc2libHlBc3luYzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgdGhyb3R0bGVFdmFsdWF0aW9uVGltZW91dCA9IGNvbXB1dGVkT2JzZXJ2YWJsZS50aHJvdHRsZUV2YWx1YXRpb247XG4gICAgaWYgKHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQgJiYgdGhyb3R0bGVFdmFsdWF0aW9uVGltZW91dCA+PSAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpc1tjb21wdXRlZFN0YXRlXS5ldmFsdWF0aW9uVGltZW91dEluc3RhbmNlKTtcbiAgICAgIHRoaXNbY29tcHV0ZWRTdGF0ZV0uZXZhbHVhdGlvblRpbWVvdXRJbnN0YW5jZSA9IHNhZmVTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLmV2YWx1YXRlSW1tZWRpYXRlKHRydWUgLyogbm90aWZ5Q2hhbmdlICovKTtcbiAgICAgIH0sIHRocm90dGxlRXZhbHVhdGlvblRpbWVvdXQpO1xuICAgIH0gZWxzZSBpZiAoY29tcHV0ZWRPYnNlcnZhYmxlLl9ldmFsRGVsYXllZCkge1xuICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLl9ldmFsRGVsYXllZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUodHJ1ZSAvKiBub3RpZnlDaGFuZ2UgKi8pO1xuICAgIH1cbiAgfSxcbiAgZXZhbHVhdGVJbW1lZGlhdGU6IGZ1bmN0aW9uIChub3RpZnlDaGFuZ2UpIHtcbiAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdLFxuICAgICAgZGlzcG9zZVdoZW4gPSBzdGF0ZS5kaXNwb3NlV2hlbjtcblxuICAgIGlmIChzdGF0ZS5pc0JlaW5nRXZhbHVhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXZhbHVhdGlvbiBvZiBhIGtvLmNvbXB1dGVkIGNhdXNlcyBzaWRlIGVmZmVjdHMsIGl0J3MgcG9zc2libGUgdGhhdCBpdCB3aWxsIHRyaWdnZXIgaXRzIG93biByZS1ldmFsdWF0aW9uLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgZGVzaXJhYmxlIChpdCdzIGhhcmQgZm9yIGEgZGV2ZWxvcGVyIHRvIHJlYWxpc2UgYSBjaGFpbiBvZiBkZXBlbmRlbmNpZXMgbWlnaHQgY2F1c2UgdGhpcywgYW5kIHRoZXkgYWxtb3N0XG4gICAgICAgICAgICAvLyBjZXJ0YWlubHkgZGlkbid0IGludGVuZCBpbmZpbml0ZSByZS1ldmFsdWF0aW9ucykuIFNvLCBmb3IgcHJlZGljdGFiaWxpdHksIHdlIHNpbXBseSBwcmV2ZW50IGtvLmNvbXB1dGVkcyBmcm9tIGNhdXNpbmdcbiAgICAgICAgICAgIC8vIHRoZWlyIG93biByZS1ldmFsdWF0aW9uLiBGdXJ0aGVyIGRpc2N1c3Npb24gYXQgaHR0cHM6Ly9naXRodWIuY29tL1N0ZXZlU2FuZGVyc29uL2tub2Nrb3V0L3B1bGwvMzg3XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGV2YWx1YXRlIChhbmQgcG9zc2libHkgY2FwdHVyZSBuZXcgZGVwZW5kZW5jaWVzKSBpZiBkaXNwb3NlZFxuICAgIGlmIChzdGF0ZS5pc0Rpc3Bvc2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJdCBqdXN0IGRpZCByZXR1cm4gZmFsc2UsIHNvIHdlIGNhbiBzdG9wIHN1cHByZXNzaW5nIG5vd1xuICAgIHN0YXRlLnN1cHByZXNzRGlzcG9zYWxVbnRpbERpc3Bvc2VXaGVuUmV0dXJuc0ZhbHNlID0gZmFsc2U7XG5cbiAgICBzdGF0ZS5pc0JlaW5nRXZhbHVhdGVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5ldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFdpdGhEZXBlbmRlbmN5RGV0ZWN0aW9uKG5vdGlmeUNoYW5nZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHN0YXRlLmlzQmVpbmdFdmFsdWF0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLmRlcGVuZGVuY2llc0NvdW50KSB7XG4gICAgICBjb21wdXRlZE9ic2VydmFibGUuZGlzcG9zZSgpO1xuICAgIH1cbiAgfSxcbiAgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvbjogZnVuY3Rpb24gKG5vdGlmeUNoYW5nZSkge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlYWxseSBqdXN0IHBhcnQgb2YgdGhlIGV2YWx1YXRlSW1tZWRpYXRlIGxvZ2ljLiBZb3Ugd291bGQgbmV2ZXIgY2FsbCBpdCBmcm9tIGFueXdoZXJlIGVsc2UuXG4gICAgICAgIC8vIEZhY3RvcmluZyBpdCBvdXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIG1lYW5zIGl0IGNhbiBiZSBpbmRlcGVuZGVudCBvZiB0aGUgdHJ5L2NhdGNoIGJsb2NrIGluIGV2YWx1YXRlSW1tZWRpYXRlLFxuICAgICAgICAvLyB3aGljaCBjb250cmlidXRlcyB0byBzYXZpbmcgYWJvdXQgNDAlIG9mZiB0aGUgQ1BVIG92ZXJoZWFkIG9mIGNvbXB1dGVkIGV2YWx1YXRpb24gKG9uIFY4IGF0IGxlYXN0KS5cblxuICAgIHZhciBjb21wdXRlZE9ic2VydmFibGUgPSB0aGlzLFxuICAgICAgc3RhdGUgPSBjb21wdXRlZE9ic2VydmFibGVbY29tcHV0ZWRTdGF0ZV07XG5cbiAgICAgICAgLy8gSW5pdGlhbGx5LCB3ZSBhc3N1bWUgdGhhdCBub25lIG9mIHRoZSBzdWJzY3JpcHRpb25zIGFyZSBzdGlsbCBiZWluZyB1c2VkIChpLmUuLCBhbGwgYXJlIGNhbmRpZGF0ZXMgZm9yIGRpc3Bvc2FsKS5cbiAgICAgICAgLy8gVGhlbiwgZHVyaW5nIGV2YWx1YXRpb24sIHdlIGNyb3NzIG9mZiBhbnkgdGhhdCBhcmUgaW4gZmFjdCBzdGlsbCBiZWluZyB1c2VkLlxuICAgIHZhciBpc0luaXRpYWwgPSBzdGF0ZS5wdXJlID8gdW5kZWZpbmVkIDogIXN0YXRlLmRlcGVuZGVuY2llc0NvdW50LCAgIC8vIElmIHdlJ3JlIGV2YWx1YXRpbmcgd2hlbiB0aGVyZSBhcmUgbm8gcHJldmlvdXMgZGVwZW5kZW5jaWVzLCBpdCBtdXN0IGJlIHRoZSBmaXJzdCB0aW1lXG4gICAgICBkZXBlbmRlbmN5RGV0ZWN0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlOiBjb21wdXRlZE9ic2VydmFibGUsXG4gICAgICAgIGRpc3Bvc2FsQ2FuZGlkYXRlczogc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nLFxuICAgICAgICBkaXNwb3NhbENvdW50OiBzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudFxuICAgICAgfTtcblxuICAgIGRlcGVuZGVuY3lEZXRlY3Rpb24uYmVnaW4oe1xuICAgICAgY2FsbGJhY2tUYXJnZXQ6IGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0LFxuICAgICAgY2FsbGJhY2s6IGNvbXB1dGVkQmVnaW5EZXBlbmRlbmN5RGV0ZWN0aW9uQ2FsbGJhY2ssXG4gICAgICBjb21wdXRlZDogY29tcHV0ZWRPYnNlcnZhYmxlLFxuICAgICAgaXNJbml0aWFsOiBpc0luaXRpYWxcbiAgICB9KTtcblxuICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xuICAgIHN0YXRlLmRlcGVuZGVuY2llc0NvdW50ID0gMDtcblxuICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRUaGVuRW5kRGVwZW5kZW5jeURldGVjdGlvbihzdGF0ZSwgZGVwZW5kZW5jeURldGVjdGlvbkNvbnRleHQpO1xuXG4gICAgaWYgKGNvbXB1dGVkT2JzZXJ2YWJsZS5pc0RpZmZlcmVudChzdGF0ZS5sYXRlc3RWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICBpZiAoIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHN0YXRlLmxhdGVzdFZhbHVlLCAnYmVmb3JlQ2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmxhdGVzdFZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIGlmIChzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS51cGRhdGVWZXJzaW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKG5vdGlmeUNoYW5nZSkge1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUubm90aWZ5U3Vic2NyaWJlcnMoc3RhdGUubGF0ZXN0VmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0luaXRpYWwpIHtcbiAgICAgIGNvbXB1dGVkT2JzZXJ2YWJsZS5ub3RpZnlTdWJzY3JpYmVycyhzdGF0ZS5sYXRlc3RWYWx1ZSwgJ2F3YWtlJyk7XG4gICAgfVxuICB9LFxuICBldmFsdWF0ZUltbWVkaWF0ZV9DYWxsUmVhZFRoZW5FbmREZXBlbmRlbmN5RGV0ZWN0aW9uOiBmdW5jdGlvbiAoc3RhdGUsIGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgcmVhbGx5IHBhcnQgb2YgdGhlIGV2YWx1YXRlSW1tZWRpYXRlX0NhbGxSZWFkV2l0aERlcGVuZGVuY3lEZXRlY3Rpb24gbG9naWMuXG4gICAgICAgIC8vIFlvdSdkIG5ldmVyIGNhbGwgaXQgZnJvbSBhbnl3aGVyZSBlbHNlLiBGYWN0b3JpbmcgaXQgb3V0IG1lYW5zIHRoYXQgZXZhbHVhdGVJbW1lZGlhdGVfQ2FsbFJlYWRXaXRoRGVwZW5kZW5jeURldGVjdGlvblxuICAgICAgICAvLyBjYW4gYmUgaW5kZXBlbmRlbnQgb2YgdHJ5L2ZpbmFsbHkgYmxvY2tzLCB3aGljaCBjb250cmlidXRlcyB0byBzYXZpbmcgYWJvdXQgNDAlIG9mZiB0aGUgQ1BVXG4gICAgICAgIC8vIG92ZXJoZWFkIG9mIGNvbXB1dGVkIGV2YWx1YXRpb24gKG9uIFY4IGF0IGxlYXN0KS5cblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVhZEZ1bmN0aW9uID0gc3RhdGUucmVhZEZ1bmN0aW9uO1xuICAgICAgcmV0dXJuIHN0YXRlLmV2YWx1YXRvckZ1bmN0aW9uVGFyZ2V0ID8gcmVhZEZ1bmN0aW9uLmNhbGwoc3RhdGUuZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQpIDogcmVhZEZ1bmN0aW9uKClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggc3Vic2NyaXB0aW9uIG5vIGxvbmdlciBiZWluZyB1c2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgYWN0aXZlIHN1YnNjcmlwdGlvbnMgbGlzdCBhbmQgZGlzcG9zZSBpdFxuICAgICAgaWYgKGRlcGVuZGVuY3lEZXRlY3Rpb25Db250ZXh0LmRpc3Bvc2FsQ291bnQgJiYgIXN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgb2JqZWN0Rm9yRWFjaChkZXBlbmRlbmN5RGV0ZWN0aW9uQ29udGV4dC5kaXNwb3NhbENhbmRpZGF0ZXMsIGNvbXB1dGVkRGlzcG9zZURlcGVuZGVuY3lDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmlzU3RhbGUgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIHBlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGVlayB3b24ndCByZS1ldmFsdWF0ZSwgZXhjZXB0IHdoaWxlIHRoZSBjb21wdXRlZCBpcyBzbGVlcGluZyBvciB0byBnZXQgdGhlIGluaXRpYWwgdmFsdWUgd2hlbiBcImRlZmVyRXZhbHVhdGlvblwiIGlzIHNldC5cbiAgICB2YXIgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgIGlmICgoc3RhdGUuaXNTdGFsZSAmJiAhc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQpIHx8IChzdGF0ZS5pc1NsZWVwaW5nICYmIHRoaXMuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkpIHtcbiAgICAgIHRoaXMuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhdGVzdFZhbHVlXG4gIH0sXG4gIGxpbWl0OiBmdW5jdGlvbiAobGltaXRGdW5jdGlvbikge1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgbGltaXQgZnVuY3Rpb24gd2l0aCBvbmUgdGhhdCBkZWxheXMgZXZhbHVhdGlvbiBhcyB3ZWxsXG4gICAgc3Vic2NyaWJhYmxlLmZuLmxpbWl0LmNhbGwodGhpcywgbGltaXRGdW5jdGlvbik7XG4gICAgdGhpcy5fZXZhbERlbGF5ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9saW1pdEJlZm9yZUNoYW5nZSh0aGlzW2NvbXB1dGVkU3RhdGVdLmxhdGVzdFZhbHVlKTtcblxuICAgICAgdGhpc1tjb21wdXRlZFN0YXRlXS5pc1N0YWxlID0gdHJ1ZTsgLy8gTWFyayBhcyBkaXJ0eVxuXG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBvYnNlcnZhYmxlIHRvIHRoZSBcImxpbWl0XCIgY29kZSwgd2hpY2ggd2lsbCBhY2Nlc3MgaXQgd2hlblxuICAgICAgICAgICAgLy8gaXQncyB0aW1lIHRvIGRvIHRoZSBub3RpZmljYXRpb24uXG4gICAgICB0aGlzLl9saW1pdENoYW5nZSh0aGlzKTtcbiAgICB9O1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICBpZiAoIXN0YXRlLmlzU2xlZXBpbmcgJiYgc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nKSB7XG4gICAgICBvYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmRpc3Bvc2UpIHtcbiAgICAgICAgICBkZXBlbmRlbmN5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZyA9IG51bGw7XG4gICAgc3RhdGUuZGVwZW5kZW5jaWVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIHN0YXRlLmlzU3RhbGUgPSBmYWxzZTtcbiAgICBzdGF0ZS5pc1NsZWVwaW5nID0gZmFsc2U7XG4gICAgc3RhdGUuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkID0gbnVsbDtcbiAgICBzdGF0ZS5yZWFkRnVuY3Rpb24gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwdXJlQ29tcHV0ZWRPdmVycmlkZXMgPSB7XG4gIGJlZm9yZVN1YnNjcmlwdGlvbkFkZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIGFzbGVlcCwgd2FrZSB1cCB0aGUgY29tcHV0ZWQgYnkgc3Vic2NyaWJpbmcgdG8gYW55IGRlcGVuZGVuY2llcy5cbiAgICB2YXIgY29tcHV0ZWRPYnNlcnZhYmxlID0gdGhpcyxcbiAgICAgIHN0YXRlID0gY29tcHV0ZWRPYnNlcnZhYmxlW2NvbXB1dGVkU3RhdGVdO1xuICAgIGlmICghc3RhdGUuaXNEaXNwb3NlZCAmJiBzdGF0ZS5pc1NsZWVwaW5nICYmIGV2ZW50ID09ICdjaGFuZ2UnKSB7XG4gICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUuaXNTdGFsZSB8fCBjb21wdXRlZE9ic2VydmFibGUuaGF2ZURlcGVuZGVuY2llc0NoYW5nZWQoKSkge1xuICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcgPSBudWxsO1xuICAgICAgICBzdGF0ZS5kZXBlbmRlbmNpZXNDb3VudCA9IDA7XG4gICAgICAgIHN0YXRlLmlzU3RhbGUgPSB0cnVlO1xuICAgICAgICBjb21wdXRlZE9ic2VydmFibGUuZXZhbHVhdGVJbW1lZGlhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgcHV0IHRoZSBkZXBlbmRlbmNpZXMgaW4gb3JkZXJcbiAgICAgICAgdmFyIGRlcGVuZGVjaWVzT3JkZXIgPSBbXTtcbiAgICAgICAgb2JqZWN0Rm9yRWFjaChzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmcsIGZ1bmN0aW9uIChpZCwgZGVwZW5kZW5jeSkge1xuICAgICAgICAgIGRlcGVuZGVjaWVzT3JkZXJbZGVwZW5kZW5jeS5fb3JkZXJdID0gaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5leHQsIHN1YnNjcmliZSB0byBlYWNoIG9uZVxuICAgICAgICBhcnJheUZvckVhY2goZGVwZW5kZWNpZXNPcmRlciwgZnVuY3Rpb24gKGlkLCBvcmRlcikge1xuICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gc3RhdGUuZGVwZW5kZW5jeVRyYWNraW5nW2lkXSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGNvbXB1dGVkT2JzZXJ2YWJsZS5zdWJzY3JpYmVUb0RlcGVuZGVuY3koZGVwZW5kZW5jeS5fdGFyZ2V0KTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24uX29yZGVyID0gb3JkZXI7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLl92ZXJzaW9uID0gZGVwZW5kZW5jeS5fdmVyc2lvbjtcbiAgICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdGUuaXNEaXNwb3NlZCkgeyAgICAgLy8gdGVzdCBzaW5jZSBldmFsdWF0aW5nIGNvdWxkIHRyaWdnZXIgZGlzcG9zYWxcbiAgICAgICAgY29tcHV0ZWRPYnNlcnZhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHN0YXRlLmxhdGVzdFZhbHVlLCAnYXdha2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFmdGVyU3Vic2NyaXB0aW9uUmVtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzW2NvbXB1dGVkU3RhdGVdO1xuICAgIGlmICghc3RhdGUuaXNEaXNwb3NlZCAmJiBldmVudCA9PSAnY2hhbmdlJyAmJiAhdGhpcy5oYXNTdWJzY3JpcHRpb25zRm9yRXZlbnQoJ2NoYW5nZScpKSB7XG4gICAgICBvYmplY3RGb3JFYWNoKHN0YXRlLmRlcGVuZGVuY3lUcmFja2luZywgZnVuY3Rpb24gKGlkLCBkZXBlbmRlbmN5KSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmRpc3Bvc2UpIHtcbiAgICAgICAgICBzdGF0ZS5kZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0ge1xuICAgICAgICAgICAgX3RhcmdldDogZGVwZW5kZW5jeS5fdGFyZ2V0LFxuICAgICAgICAgICAgX29yZGVyOiBkZXBlbmRlbmN5Ll9vcmRlcixcbiAgICAgICAgICAgIF92ZXJzaW9uOiBkZXBlbmRlbmN5Ll92ZXJzaW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZXBlbmRlbmN5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzdGF0ZS5pc1NsZWVwaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMubm90aWZ5U3Vic2NyaWJlcnModW5kZWZpbmVkLCAnYXNsZWVwJyk7XG4gICAgfVxuICB9LFxuICBnZXRWZXJzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJlY2F1c2UgYSBwdXJlIGNvbXB1dGVkIGlzIG5vdCBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgd2hpbGUgaXQgaXMgc2xlZXBpbmcsIHdlIGNhbid0XG4gICAgICAgIC8vIHNpbXBseSByZXR1cm4gdGhlIHZlcnNpb24gbnVtYmVyLiBJbnN0ZWFkLCB3ZSBjaGVjayBpZiBhbnkgb2YgdGhlIGRlcGVuZGVuY2llcyBoYXZlXG4gICAgICAgIC8vIGNoYW5nZWQgYW5kIGNvbmRpdGlvbmFsbHkgcmUtZXZhbHVhdGUgdGhlIGNvbXB1dGVkIG9ic2VydmFibGUuXG4gICAgdmFyIHN0YXRlID0gdGhpc1tjb21wdXRlZFN0YXRlXTtcbiAgICBpZiAoc3RhdGUuaXNTbGVlcGluZyAmJiAoc3RhdGUuaXNTdGFsZSB8fCB0aGlzLmhhdmVEZXBlbmRlbmNpZXNDaGFuZ2VkKCkpKSB7XG4gICAgICB0aGlzLmV2YWx1YXRlSW1tZWRpYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpYmFibGUuZm4uZ2V0VmVyc2lvbi5jYWxsKHRoaXMpXG4gIH1cbn07XG5cbnZhciBkZWZlckV2YWx1YXRpb25PdmVycmlkZXMgPSB7XG4gIGJlZm9yZVN1YnNjcmlwdGlvbkFkZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBmb3JjZSBhIGNvbXB1dGVkIHdpdGggZGVmZXJFdmFsdWF0aW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiBpcyByZWdpc3RlcmVkLlxuICAgIGlmIChldmVudCA9PSAnY2hhbmdlJyB8fCBldmVudCA9PSAnYmVmb3JlQ2hhbmdlJykge1xuICAgICAgdGhpcy5wZWVrKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBOb3RlIHRoYXQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwcm90byBhc3NpZ25tZW50LCB0aGVcbi8vIGluaGVyaXRhbmNlIGNoYWluIGlzIGNyZWF0ZWQgbWFudWFsbHkgaW4gdGhlIGtvLmNvbXB1dGVkIGNvbnN0cnVjdG9yXG5pZiAoY2FuU2V0UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKGNvbXB1dGVkLmZuLCBzdWJzY3JpYmFibGUuZm4pO1xufVxuXG4vLyBTZXQgdGhlIHByb3RvIGNoYWluIHZhbHVlcyBmb3Iga28uaGFzUHJvdG90eXBlXG52YXIgcHJvdG9Qcm9wID0gb2JzZXJ2YWJsZS5wcm90b1Byb3BlcnR5OyAvLyA9PSBcIl9fa29fcHJvdG9fX1wiXG5jb21wdXRlZFtwcm90b1Byb3BdID0gb2JzZXJ2YWJsZTtcbmNvbXB1dGVkLmZuW3Byb3RvUHJvcF0gPSBjb21wdXRlZDtcblxuZnVuY3Rpb24gaXNDb21wdXRlZCAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGhhc1Byb3RvdHlwZShpbnN0YW5jZSwgY29tcHV0ZWQpXG59XG5cbmZ1bmN0aW9uIGlzUHVyZUNvbXB1dGVkIChpbnN0YW5jZSkge1xuICByZXR1cm4gaGFzUHJvdG90eXBlKGluc3RhbmNlLCBjb21wdXRlZClcbiAgICAgICAgJiYgaW5zdGFuY2VbY29tcHV0ZWRTdGF0ZV0gJiYgaW5zdGFuY2VbY29tcHV0ZWRTdGF0ZV0ucHVyZVxufVxuXG5mdW5jdGlvbiBwdXJlQ29tcHV0ZWQgKGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLCBldmFsdWF0b3JGdW5jdGlvblRhcmdldCkge1xuICBpZiAodHlwZW9mIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkKGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLCBldmFsdWF0b3JGdW5jdGlvblRhcmdldCwgeydwdXJlJzogdHJ1ZX0pXG4gIH0gZWxzZSB7XG4gICAgZXZhbHVhdG9yRnVuY3Rpb25Pck9wdGlvbnMgPSBleHRlbmQoe30sIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zKTsgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgcGFyYW1ldGVyIG9iamVjdFxuICAgIGV2YWx1YXRvckZ1bmN0aW9uT3JPcHRpb25zLnB1cmUgPSB0cnVlO1xuICAgIHJldHVybiBjb21wdXRlZChldmFsdWF0b3JGdW5jdGlvbk9yT3B0aW9ucywgZXZhbHVhdG9yRnVuY3Rpb25UYXJnZXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3R0bGVFeHRlbmRlcih0YXJnZXQsIHRpbWVvdXQpIHtcbiAgICAvLyBUaHJvdHRsaW5nIG1lYW5zIHR3byB0aGluZ3M6XG5cbiAgICAvLyAoMSkgRm9yIGRlcGVuZGVudCBvYnNlcnZhYmxlcywgd2UgdGhyb3R0bGUgKmV2YWx1YXRpb25zKiBzbyB0aGF0LCBubyBtYXR0ZXIgaG93IGZhc3QgaXRzIGRlcGVuZGVuY2llc1xuICAgIC8vICAgICBub3RpZnkgdXBkYXRlcywgdGhlIHRhcmdldCBkb2Vzbid0IHJlLWV2YWx1YXRlIChhbmQgaGVuY2UgZG9lc24ndCBub3RpZnkpIGZhc3RlciB0aGFuIGEgY2VydGFpbiByYXRlXG4gICAgdGFyZ2V0LnRocm90dGxlRXZhbHVhdGlvbiA9IHRpbWVvdXQ7XG5cbiAgICAvLyAoMikgRm9yIHdyaXRhYmxlIHRhcmdldHMgKG9ic2VydmFibGVzLCBvciB3cml0YWJsZSBkZXBlbmRlbnQgb2JzZXJ2YWJsZXMpLCB3ZSB0aHJvdHRsZSAqd3JpdGVzKlxuICAgIC8vICAgICBzbyB0aGUgdGFyZ2V0IGNhbm5vdCBjaGFuZ2UgdmFsdWUgc3luY2hyb25vdXNseSBvciBmYXN0ZXIgdGhhbiBhIGNlcnRhaW4gcmF0ZVxuICAgIHZhciB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IG51bGw7XG4gICAgcmV0dXJuIGNvbXB1dGVkKHtcbiAgICAgICAgcmVhZDogdGFyZ2V0LFxuICAgICAgICB3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3cml0ZVRpbWVvdXRJbnN0YW5jZSk7XG4gICAgICAgICAgICB3cml0ZVRpbWVvdXRJbnN0YW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblxuZXh0ZW5kZXJzLnRocm90dGxlID0gdGhyb3R0bGVFeHRlbmRlcjtcblxuLy9cbi8vIHRrby5jb21wdXRlZCAtIEV4cG9ydHNcbi8vXG4vLyBrbm9ja291dCAtPiB0a28gY2hhbmdlczpcbi8vICAgICAgRGVwcmVjYXRlcyBgZGVwZW5kZW50T2JzZXJ2YWJsZWAgKHVzZSBgY29tcHV0ZWRgKVxuLy9cblxuZXhwb3J0IHsgY29tcHV0ZWQsIGlzQ29tcHV0ZWQsIGlzUHVyZUNvbXB1dGVkLCBwdXJlQ29tcHV0ZWQsIHRocm90dGxlRXh0ZW5kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRrby5jb21wdXRlZC5qcy5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3Rrby90a28uY29tcHV0ZWQuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoTkE7QUFDQTtBQWtOQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExREE7QUFDQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*******************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/renderCtx.js ***!
  \*******************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.createStamp = exports.insertNode = exports.duplicateCtx = exports.createCtx = exports.renderCtx = undefined;\n\nvar _tkoUtils = __webpack_require__(/*! ./tko/tko.utils.js */ 1);\n\nvar _tkoObservable = __webpack_require__(/*! ./tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ./tko/tko.computed.js */ 2);\n\nvar _blockComponent = __webpack_require__(/*! ./blocks/blockComponent.js */ 5);\n\nvar _blockComponent2 = _interopRequireDefault(_blockComponent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction renderCtx(parentEl, tpl, ctx, level) {\n\tif (Array.isArray(tpl)) {\n\t\tfor (var i = 0; i < tpl.length; i++) {\n\t\t\trenderCtx(parentEl, tpl[i], ctx, level);\n\t\t}\n\t} else if (tpl.block) {\n\t\tvar blockFn = renderCtx.blocks[tpl.block];\n\t\tif (blockFn && blockFn.call) {\n\t\t\tblockFn(parentEl, tpl, ctx, level, renderCtx);\n\t\t} else {\n\t\t\ttpl.attrs._name = function () {\n\t\t\t\treturn tpl.block;\n\t\t\t};\n\t\t\t(0, _blockComponent2.default)(parentEl, tpl, ctx, level, renderCtx);\n\t\t}\n\t} else if (tpl.tag) {\n\t\tvar el = document.createElement(tpl.tag);\n\t\tif (level == 0) ctx.rootNodes.push(el);\n\t\tfor (var key in tpl.attrs) {\n\t\t\tvar val = tpl.attrs[key];\n\t\t\tif (typeof val == \"function\") {\n\t\t\t\tattrExpr(el, key, val, ctx);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(key, val);\n\t\t\t}\n\t\t}\n\t\tinsertNode(parentEl, el);\n\t\tif (tpl.children) (0, _tkoUtils.arrayForEach)(tpl.children, function (x) {\n\t\t\trenderCtx(el, x, ctx, level + 1);\n\t\t});\n\t} else if (tpl && typeof tpl == \"function\") {\n\t\tvar n = document.createTextNode(\"\");\n\t\tif (level == 0) ctx.rootNodes.push(n);\n\t\tinsertNode(parentEl, n);\n\t\ttextExpr(n, tpl, ctx, level);\n\t} else if (tpl !== undefined || tpl !== null) {\n\t\tvar n = document.createTextNode(\"\" + tpl);\n\t\tif (level == 0) ctx.rootNodes.push(n);\n\t\tinsertNode(parentEl, n);\n\t}\n}\n\nfunction insertNode(parentEl, n) {\n\tif (parentEl.nodeType) {\n\t\tparentEl.appendChild(n);\n\t} else {\n\t\tparentEl[0].insertBefore(n, parentEl[1]);\n\t}\n}\n\nfunction createStamp(parentEl, name) {\n\tvar stamp = document.createComment(name);\n\tif (parentEl.nodeType) {\n\t\tparentEl.appendChild(stamp);\n\t\treturn [parentEl, stamp];\n\t} else {\n\t\tparentEl[0].insertBefore(stamp, parentEl[1]);\n\t\treturn [parentEl[0], stamp];\n\t}\n}\n\nfunction attrExpr(el, key, val, ctx) {\n\tvar binding = renderCtx.bindingHandlers[key];\n\tif (binding) {\n\t\tif (binding.init) {\n\t\t\tvar val2 = val(ctx.model, ctx);\n\t\t\tbinding.init(el, val2, ctx);\n\t\t}\n\t\tif (binding.update) {\n\t\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\t\tvar val2 = val(ctx.model, ctx);\n\t\t\t\tbinding.update(el, val2, ctx);\n\t\t\t}, this);\n\t\t\tkv.extend({ notify: 'always' });\n\t\t\tkv();\n\t\t\tctx.subscribers.push(kv);\n\t\t}\n\t\tif (binding.dispose && binding.dispose.call) {\n\t\t\tvar obj = {};\n\t\t\tobj.dispose = function () {\n\t\t\t\tbinding.dispose(el, ctx);\n\t\t\t};\n\t\t\tctx.subscribers.push(obj);\n\t\t}\n\t} else {\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = val(ctx.model, ctx);\n\t\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\t\tel.setAttribute(key, val2);\n\t\t}, this);\n\t\tkv.extend({ notify: 'always' });\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n};\n\nfunction textExpr(n, val, ctx, level) {\n\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\tvar val2 = val(ctx.model, ctx);\n\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\tn.nodeValue = \"\" + val2;\n\t\treturn val2;\n\t}, this);\n\tkv.extend({ notify: 'always' });\n\tkv();\n\tif (kv.getDependenciesCount() > 0) {\n\t\tctx.subscribers.push(kv);\n\t} else {\n\t\tkv.dispose();\n\t}\n};\n\nrenderCtx.blocks = {};\n\nrenderCtx.bindingHandlers = {};\n\nfunction createCtx(model, parentCtx, component) {\n\tvar ctx = {};\n\tctx.model = model;\n\tctx.componet = component ? component : parentCtx ? parentCtx.conponent : null;\n\tctx.root = parentCtx ? parentCtx.root : model;\n\tctx.parent = function (index) {\n\t\tif (index < 0) {\n\t\t\treturn ctx.root;\n\t\t}\n\t\tif (index == 0) {\n\t\t\treturn ctx.model;\n\t\t}\n\t\tvar parent1 = ctx;\n\t\twhile (index-- > 0) {\n\t\t\tif (!parent1.parentCtx) return parent1.model;\n\t\t\tparent1 = parent1.parentCtx;\n\t\t}\n\t\treturn parent1.model;\n\t};\n\tctx.parentCtx = parentCtx;\n\tctx.rootNodes = [];\n\tctx.subscribers = [];\n\tctx.dispose = function (removeNodes) {\n\t\t(0, _tkoUtils.arrayForEach)(ctx.subscribers, function (e) {\n\t\t\tif (e.dispose) e.dispose();\n\t\t});\n\t\tctx.subscribers = [];\n\t\tif (!(removeNodes === false)) (0, _tkoUtils.arrayForEach)(ctx.rootNodes, function (n) {\n\t\t\tif (n.parentNode) n.parentNode.removeChild(n);\n\t\t});\n\t\tctx.rootNodes = [];\n\t};\n\n\treturn ctx;\n}\n\nfunction duplicateCtx(ctx) {\n\n\tvar ctx0 = {};\n\tfor (var attr in ctx) {\n\t\tif (ctx.hasOwnProperty(attr)) ctx0[attr] = ctx[attr];\n\t}ctx0.subscribers = [];\n\tctx0.rootNodes = [];\n\tctx0.dispose = function () {\n\t\t(0, _tkoUtils.arrayForEach)(ctx0.subscribers, function (e) {\n\t\t\tif (e.dispose) e.dispose();\n\t\t});\n\t\tctx0.subscribers = [];\n\t\t(0, _tkoUtils.arrayForEach)(ctx0.rootNodes, function (n) {\n\t\t\tif (n.parentNode) n.parentNode.removeChild(n);\n\t\t});\n\t\tctx0.rootNodes = [];\n\t};\n\treturn ctx0;\n}\n\nexports.renderCtx = renderCtx;\nexports.createCtx = createCtx;\nexports.duplicateCtx = duplicateCtx;\nexports.insertNode = insertNode;\nexports.createStamp = createStamp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3JlbmRlckN0eC5qcz9kOGYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycmF5Rm9yRWFjaCB9ICBmcm9tICcuL3Rrby90a28udXRpbHMuanMnO1xyXG5pbXBvcnQgeyB1bndyYXAgfSAgZnJvbSAnLi90a28vdGtvLm9ic2VydmFibGUuanMnO1xyXG5pbXBvcnQgeyBjb21wdXRlZCB9ICBmcm9tICcuL3Rrby90a28uY29tcHV0ZWQuanMnO1xyXG5cclxuaW1wb3J0IGJsb2NrQ29tcG9uZW50ICBmcm9tICcuL2Jsb2Nrcy9ibG9ja0NvbXBvbmVudC5qcyc7XHJcblxyXG5mdW5jdGlvbiByZW5kZXJDdHgocGFyZW50RWwsIHRwbCwgY3R4LCBsZXZlbCl7XHJcblx0aWYoQXJyYXkuaXNBcnJheSh0cGwpKXtcclxuXHRcdGZvcih2YXIgaT0wOyBpPHRwbC5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdHJlbmRlckN0eChwYXJlbnRFbCwgdHBsW2ldLCBjdHgsIGxldmVsKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYodHBsLmJsb2NrKXtcclxuXHRcdHZhciBibG9ja0ZuID0gcmVuZGVyQ3R4LmJsb2Nrc1t0cGwuYmxvY2tdO1xyXG5cdFx0aWYoYmxvY2tGbiAmJiBibG9ja0ZuLmNhbGwpe1xyXG5cdFx0XHRibG9ja0ZuKHBhcmVudEVsLCB0cGwsIGN0eCwgbGV2ZWwsIHJlbmRlckN0eCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0cGwuYXR0cnMuX25hbWUgPSAoKSA9PiB0cGwuYmxvY2s7XHJcblx0XHRcdGJsb2NrQ29tcG9uZW50KHBhcmVudEVsLCB0cGwsIGN0eCwgbGV2ZWwsIHJlbmRlckN0eCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmKHRwbC50YWcpe1xyXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0cGwudGFnKTtcclxuXHRcdGlmKGxldmVsPT0wKSBjdHgucm9vdE5vZGVzLnB1c2goZWwpO1xyXG5cdFx0Zm9yICh2YXIga2V5IGluIHRwbC5hdHRycykge1xyXG5cdFx0XHR2YXIgdmFsID0gdHBsLmF0dHJzW2tleV07XHJcblx0XHRcdGlmKHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdFx0XHRhdHRyRXhwcihlbCwga2V5LCB2YWwsIGN0eCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnRFbCwgZWwpO1xyXG5cdFx0aWYodHBsLmNoaWxkcmVuKSBhcnJheUZvckVhY2godHBsLmNoaWxkcmVuLCBmdW5jdGlvbih4KXsgcmVuZGVyQ3R4KGVsLCB4LCBjdHgsIGxldmVsKzEpOyB9KTtcclxuXHR9IGVsc2UgaWYodHBsICYmIHR5cGVvZiB0cGwgPT0gXCJmdW5jdGlvblwiKXtcclxuXHRcdHZhciBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XHJcblx0XHRpZihsZXZlbD09MCkgY3R4LnJvb3ROb2Rlcy5wdXNoKG4pO1xyXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnRFbCwgbik7XHJcblx0XHR0ZXh0RXhwcihuLCB0cGwsIGN0eCwgbGV2ZWwpO1xyXG5cdH0gZWxzZSBpZih0cGwgIT09IHVuZGVmaW5lZCB8fCB0cGwgIT09IG51bGwpe1xyXG5cdFx0dmFyIG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiK3RwbCk7XHJcblx0XHRpZihsZXZlbD09MCkgY3R4LnJvb3ROb2Rlcy5wdXNoKG4pO1xyXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnRFbCwgbik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudEVsLCBuKSB7XHJcblx0aWYocGFyZW50RWwubm9kZVR5cGUpIHtcclxuXHRcdHBhcmVudEVsLmFwcGVuZENoaWxkKG4pO1xyXG5cdH0gZWxzZXtcclxuXHRcdHBhcmVudEVsWzBdLmluc2VydEJlZm9yZShuLCBwYXJlbnRFbFsxXSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdGFtcChwYXJlbnRFbCwgbmFtZSl7XHJcblx0dmFyIHN0YW1wID1cdGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQobmFtZSk7XHJcblx0aWYocGFyZW50RWwubm9kZVR5cGUpIHtcclxuXHRcdHBhcmVudEVsLmFwcGVuZENoaWxkKHN0YW1wKTtcclxuXHRcdHJldHVybiBbcGFyZW50RWwsIHN0YW1wXTtcclxuXHR9IGVsc2V7XHJcblx0XHRwYXJlbnRFbFswXS5pbnNlcnRCZWZvcmUoc3RhbXAsIHBhcmVudEVsWzFdKTtcclxuXHRcdHJldHVybiBbcGFyZW50RWxbMF0sIHN0YW1wXTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF0dHJFeHByKGVsLCBrZXksIHZhbCwgY3R4KXtcclxuXHR2YXIgYmluZGluZyA9IHJlbmRlckN0eC5iaW5kaW5nSGFuZGxlcnNba2V5XTtcclxuXHRpZihiaW5kaW5nKXtcclxuXHRcdGlmKGJpbmRpbmcuaW5pdCl7XHJcblx0XHRcdHZhciB2YWwyID0gdmFsKGN0eC5tb2RlbCwgY3R4KTtcclxuXHRcdFx0YmluZGluZy5pbml0KGVsLCB2YWwyLCBjdHgpO1xyXG5cdFx0fVxyXG5cdFx0aWYoYmluZGluZy51cGRhdGUpe1xyXG5cdFx0XHR2YXIga3YgPSBjb21wdXRlZChmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHZhciB2YWwyID0gdmFsKGN0eC5tb2RlbCwgY3R4KTtcclxuXHRcdFx0XHRiaW5kaW5nLnVwZGF0ZShlbCwgdmFsMiwgY3R4KTtcclxuXHRcdFx0fSx0aGlzKTtcclxuXHRcdFx0a3YuZXh0ZW5kKHsgbm90aWZ5OiAnYWx3YXlzJyB9KTtcclxuXHRcdFx0a3YoKTtcclxuXHRcdFx0Y3R4LnN1YnNjcmliZXJzLnB1c2goa3YpO1xyXG5cdFx0fVxyXG5cdFx0aWYoYmluZGluZy5kaXNwb3NlICYmIGJpbmRpbmcuZGlzcG9zZS5jYWxsKXtcclxuXHRcdFx0dmFyIG9iaiA9IHt9O1xyXG5cdFx0XHRvYmouZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0YmluZGluZy5kaXNwb3NlKGVsLCBjdHgpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChvYmopO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIga3YgPSBjb21wdXRlZChmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgdmFsMiA9IHZhbChjdHgubW9kZWwsIGN0eCk7XHJcblx0XHRcdHZhbDIgPSB1bndyYXAodmFsMik7XHJcblx0XHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbDIpO1xyXG5cdFx0fSx0aGlzKTtcclxuXHRcdGt2LmV4dGVuZCh7IG5vdGlmeTogJ2Fsd2F5cycgfSk7XHJcblx0XHRrdigpO1xyXG5cdFx0aWYoa3YuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKT4wKXtcclxuXHRcdFx0Y3R4LnN1YnNjcmliZXJzLnB1c2goa3YpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0a3YuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIHRleHRFeHByKG4sIHZhbCwgY3R4LCBsZXZlbCl7XHJcblx0dmFyIGt2ID0gY29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuXHRcdHZhciB2YWwyID0gdmFsKGN0eC5tb2RlbCwgY3R4KTtcclxuXHRcdHZhbDIgPSB1bndyYXAodmFsMik7XHJcblx0XHRuLm5vZGVWYWx1ZSA9IFwiXCIrdmFsMjtcclxuXHRcdHJldHVybiB2YWwyO1xyXG5cdH0sIHRoaXMpO1xyXG5cdGt2LmV4dGVuZCh7IG5vdGlmeTogJ2Fsd2F5cycgfSk7XHJcblx0a3YoKTtcclxuXHRpZihrdi5nZXREZXBlbmRlbmNpZXNDb3VudCgpPjApe1xyXG5cdFx0Y3R4LnN1YnNjcmliZXJzLnB1c2goa3YpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRrdi5kaXNwb3NlKCk7XHJcblx0fVxyXG59O1xyXG5cclxucmVuZGVyQ3R4LmJsb2NrcyA9IHtcclxufTtcclxuXHJcbnJlbmRlckN0eC5iaW5kaW5nSGFuZGxlcnMgPSB7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDdHgobW9kZWwsIHBhcmVudEN0eCwgY29tcG9uZW50KXtcclxuXHR2YXIgY3R4ID0ge307XHJcblx0Y3R4Lm1vZGVsID0gbW9kZWw7XHJcblx0Y3R4LmNvbXBvbmV0ID0gY29tcG9uZW50ID8gY29tcG9uZW50IDogcGFyZW50Q3R4ID8gcGFyZW50Q3R4LmNvbnBvbmVudCA6IG51bGw7XHJcblx0Y3R4LnJvb3QgPSBwYXJlbnRDdHggPyBwYXJlbnRDdHgucm9vdCA6IG1vZGVsO1xyXG5cdGN0eC5wYXJlbnQgPSBmdW5jdGlvbihpbmRleCl7XHJcblx0XHRpZihpbmRleDwwKXtcclxuXHRcdFx0cmV0dXJuIGN0eC5yb290O1xyXG5cdFx0fVxyXG5cdFx0aWYoaW5kZXg9PTApe1xyXG5cdFx0XHRyZXR1cm4gY3R4Lm1vZGVsO1x0XHJcblx0XHR9XHJcblx0XHR2YXIgcGFyZW50MSA9IGN0eDtcclxuXHRcdHdoaWxlKGluZGV4LS0+MCl7XHJcblx0XHRcdGlmKCFwYXJlbnQxLnBhcmVudEN0eCkgcmV0dXJuIHBhcmVudDEubW9kZWw7XHJcblx0XHRcdHBhcmVudDEgPSBwYXJlbnQxLnBhcmVudEN0eDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBwYXJlbnQxLm1vZGVsO1xyXG5cdH07XHJcblx0Y3R4LnBhcmVudEN0eCA9IHBhcmVudEN0eDtcclxuXHRjdHgucm9vdE5vZGVzID0gW107XHJcblx0Y3R4LnN1YnNjcmliZXJzID0gW107XHJcblx0Y3R4LmRpc3Bvc2UgPSBmdW5jdGlvbihyZW1vdmVOb2Rlcykge1xyXG5cdFx0YXJyYXlGb3JFYWNoKGN0eC5zdWJzY3JpYmVycywgZnVuY3Rpb24oZSkgeyBpZihlLmRpc3Bvc2UpIGUuZGlzcG9zZSgpOyB9ICk7XHJcblx0XHRjdHguc3Vic2NyaWJlcnMgPSBbXTtcclxuXHRcdGlmKCEocmVtb3ZlTm9kZXM9PT1mYWxzZSkpIGFycmF5Rm9yRWFjaChjdHgucm9vdE5vZGVzLCBmdW5jdGlvbihuKSB7IGlmKG4ucGFyZW50Tm9kZSkgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pOyB9KTtcclxuXHRcdGN0eC5yb290Tm9kZXMgPSBbXTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gY3R4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkdXBsaWNhdGVDdHgoY3R4KXtcclxuXHRcclxuXHR2YXIgY3R4MCA9IHt9O1xyXG5cdGZvciAodmFyIGF0dHIgaW4gY3R4KSBpZiAoY3R4Lmhhc093blByb3BlcnR5KGF0dHIpKSBjdHgwW2F0dHJdID0gY3R4W2F0dHJdO1xyXG5cdGN0eDAuc3Vic2NyaWJlcnMgPSBbXTtcclxuXHRjdHgwLnJvb3ROb2RlcyA9IFtdO1xyXG5cdGN0eDAuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0YXJyYXlGb3JFYWNoKGN0eDAuc3Vic2NyaWJlcnMsIGZ1bmN0aW9uKGUpIHsgaWYoZS5kaXNwb3NlKSBlLmRpc3Bvc2UoKTsgfSApO1xyXG5cdFx0Y3R4MC5zdWJzY3JpYmVycyA9IFtdO1xyXG5cdFx0YXJyYXlGb3JFYWNoKGN0eDAucm9vdE5vZGVzLCBmdW5jdGlvbihuKSB7IGlmKG4ucGFyZW50Tm9kZSkgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pOyB9KTtcclxuXHRcdGN0eDAucm9vdE5vZGVzID0gW107XHJcblx0fTtcclxuXHRyZXR1cm4gY3R4MDtcclxufVxyXG5cclxuZXhwb3J0IHtcclxuXHRyZW5kZXJDdHgsXHJcblx0Y3JlYXRlQ3R4LFxyXG5cdGR1cGxpY2F0ZUN0eCxcclxuXHRpbnNlcnROb2RlLFxyXG5cdGNyZWF0ZVN0YW1wXHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvcmVuZGVyQ3R4LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/*!*************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/compat.js ***!
  \*************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.stringIncludes = stringIncludes;\nexports.isRealNaN = isRealNaN;\nexports.arrayIncludes = arrayIncludes;\n/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\n\nfunction startsWith(str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString;\n}\n\nfunction endsWith(str, searchString, position) {\n  var index = (position || str.length) - searchString.length;\n  var lastIndex = str.lastIndexOf(searchString, index);\n  return lastIndex !== -1 && lastIndex === index;\n}\n\nfunction stringIncludes(str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1;\n}\n\nfunction isRealNaN(x) {\n  return typeof x === 'number' && isNaN(x);\n}\n\nfunction arrayIncludes(array, searchElement, position) {\n  var len = array.length;\n  if (len === 0) return false;\n\n  var lookupIndex = position | 0;\n  var isNaNElement = isRealNaN(searchElement);\n  var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;\n  while (searchIndex < len) {\n    var element = array[searchIndex++];\n    if (element === searchElement) return true;\n    if (isNaNElement && isRealNaN(element)) return true;\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2hpbWFsYXlhL2NvbXBhdC5qcz85Y2QzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZSBiYWJlbC1wb2x5ZmlsbCBpbiBvdXIgcHJvamVjdC5cbiAgICAtIExpYnJhcnkgYXV0aG9ycyBzaG91bGQgYmUgdXNpbmcgYmFiZWwtcnVudGltZSBmb3Igbm9uLWdsb2JhbCBwb2x5ZmlsbGluZ1xuICAgIC0gQWRkaW5nIGJhYmVsLXBvbHlmaWxsLy1ydW50aW1lIGluY3JlYXNlcyBidW5kbGUgc2l6ZSBzaWduaWZpY2FudGx5XG5cbiAgV2Ugd2lsbCBpbmNsdWRlIG91ciBwb2x5ZmlsbCBpbnN0YW5jZSBtZXRob2RzIGFzIHJlZ3VsYXIgZnVuY3Rpb25zLlxuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0c1dpdGggKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICByZXR1cm4gc3RyLnN1YnN0cihwb3NpdGlvbiB8fCAwLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmRzV2l0aCAoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGluZGV4ID0gKHBvc2l0aW9uIHx8IHN0ci5sZW5ndGgpIC0gc2VhcmNoU3RyaW5nLmxlbmd0aFxuICBjb25zdCBsYXN0SW5kZXggPSBzdHIubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCBpbmRleClcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBpbmRleFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nSW5jbHVkZXMgKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiB8fCAwKSAhPT0gLTFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhbE5hTiAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzTmFOKHgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUluY2x1ZGVzIChhcnJheSwgc2VhcmNoRWxlbWVudCwgcG9zaXRpb24pIHtcbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGxvb2t1cEluZGV4ID0gcG9zaXRpb24gfCAwXG4gIGNvbnN0IGlzTmFORWxlbWVudCA9IGlzUmVhbE5hTihzZWFyY2hFbGVtZW50KVxuICBsZXQgc2VhcmNoSW5kZXggPSBsb29rdXBJbmRleCA+PSAwID8gbG9va3VwSW5kZXggOiBsZW4gKyBsb29rdXBJbmRleFxuICB3aGlsZSAoc2VhcmNoSW5kZXggPCBsZW4pIHtcbiAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbc2VhcmNoSW5kZXgrK11cbiAgICBpZiAoZWxlbWVudCA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIHRydWVcbiAgICBpZiAoaXNOYU5FbGVtZW50ICYmIGlzUmVhbE5hTihlbGVtZW50KSkgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvaGltYWxheWEvY29tcGF0LmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQVFBO0FBSUE7QUFNQTtBQUlBO0FBSUE7QUExQkE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/*!*******************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockComponent.js ***!
  \*******************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockComponent;\n\nvar _tkoUtils = __webpack_require__(/*! ../tko/tko.utils.js */ 1);\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 2);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 3);\n\nfunction blockComponent(parent, tpl, ctx, level) {\n\n\tif (tpl.children && tpl.children.length > 0 && tpl.attrs && tpl.attrs['_name']) {\n\n\t\tvar _name = tpl.attrs['_name'];\n\t\tvar stamp = (0, _renderCtx.createStamp)(parent, 'component');\n\t\tif (level == 0) ctx.rootNodes.push(stamp[1]);\n\n\t\tvar lastName = '';\n\t\tvar lastCtx = null;\n\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = value(ctx.model, ctx);\n\n\t\t\tif (val2 == lastVal) return;\n\t\t\tlastVal = val2;\n\n\t\t\t//remove old componet\n\t\t\tif (lastCtx && lastCtx.dispose) {\n\t\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\t\tlastCtx.dispose();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (val2) {\n\t\t\t\t//render children tpl\n\t\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\t\t(0, _renderCtx.renderCtx)(stamp, tpl.children, ctx0, 0);\n\t\t\t\t});\n\t\t\t} else {}\n\t\t}, this);\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n}\n\nfunction renderComponent(parent, tpl, ctx, level, componentDef) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2Jsb2Nrcy9ibG9ja0NvbXBvbmVudC5qcz9mMjRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycmF5Rm9yRWFjaCB9ICBmcm9tICcuLi90a28vdGtvLnV0aWxzLmpzJztcclxuaW1wb3J0IHsgdW53cmFwLCBkZXBlbmRlbmN5RGV0ZWN0aW9uIH0gIGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVkIH0gIGZyb20gJy4uL3Rrby90a28uY29tcHV0ZWQuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJDdHgsIGNyZWF0ZVN0YW1wLCBkdXBsaWNhdGVDdHggfSAgZnJvbSAnLi4vcmVuZGVyQ3R4LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsb2NrQ29tcG9uZW50KHBhcmVudCwgdHBsLCBjdHgsIGxldmVsKXtcclxuXHJcblx0aWYodHBsLmNoaWxkcmVuICYmIHRwbC5jaGlsZHJlbi5sZW5ndGg+MCAmJiB0cGwuYXR0cnMgJiYgdHBsLmF0dHJzWydfbmFtZSddKXtcclxuXHRcdFxyXG5cdFx0dmFyIF9uYW1lID0gdHBsLmF0dHJzWydfbmFtZSddO1xyXG5cdFx0dmFyIHN0YW1wID1cdGNyZWF0ZVN0YW1wKHBhcmVudCwgJ2NvbXBvbmVudCcpO1xyXG5cdFx0aWYobGV2ZWw9PTApIGN0eC5yb290Tm9kZXMucHVzaChzdGFtcFsxXSk7XHJcblxyXG5cdFx0dmFyIGxhc3ROYW1lID0gJyc7XHJcblx0XHR2YXIgbGFzdEN0eCA9IG51bGw7XHJcblxyXG5cdFx0dmFyIGt2ID0gY29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIHZhbDIgPSB2YWx1ZShjdHgubW9kZWwsIGN0eCk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZih2YWwyPT1sYXN0VmFsKSByZXR1cm47XHJcblx0XHRcdGxhc3RWYWwgPSB2YWwyO1xyXG5cclxuXHRcdFx0Ly9yZW1vdmUgb2xkIGNvbXBvbmV0XHJcblx0XHRcdGlmKGxhc3RDdHggJiYgbGFzdEN0eC5kaXNwb3NlKXtcclxuXHRcdFx0XHRkZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0bGFzdEN0eC5kaXNwb3NlKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHZhbDIpe1xyXG5cdFx0XHRcdC8vcmVuZGVyIGNoaWxkcmVuIHRwbFxyXG5cdFx0XHRcdGRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRyZW5kZXJDdHgoc3RhbXAsIHRwbC5jaGlsZHJlbiwgY3R4MCwgMCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0a3YoKTtcclxuXHRcdGlmKGt2LmdldERlcGVuZGVuY2llc0NvdW50KCk+MCl7XHJcblx0XHRcdGN0eC5zdWJzY3JpYmVycy5wdXNoKGt2KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGt2LmRpc3Bvc2UoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQocGFyZW50LCB0cGwsIGN0eCwgbGV2ZWwsIGNvbXBvbmVudERlZil7XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvYmxvY2tzL2Jsb2NrQ29tcG9uZW50LmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUtBO0FBQ0E7QUFOQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!**************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/main.js ***!
  \**************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _tkoUtils = __webpack_require__(/*! ./tko/tko.utils.js */ 1);\n\nvar _ko = __webpack_require__(/*! ./ko6.js */ 8);\n\nwindow.count = 0;\n\nvar startTime;\nvar lastMeasure;\n\nvar startMeasure = function startMeasure(name) {\n\tstartTime = performance.now();\n\tlastMeasure = name;\n};\nvar stopMeasure = function stopMeasure() {\n\twindow.setTimeout(function () {\n\t\tvar stop = performance.now();\n\t\tconsole.log(lastMeasure + \" took \" + (stop - startTime), window.count);\n\t\tif (window.mainModel) window.mainModel.log(lastMeasure + \" took \" + (stop - startTime).toFixed(0) + \"ms subscribers \" + window.count);\n\t}, 0);\n};\n\nvar HomeViewModel = function HomeViewModel() {\n\tvar self = this;\n\tself.id = 1;\n\n\tself.log = (0, _ko.observable)();\n\n\tself.step = (0, _ko.observable)(1);\n\n\tself.tpl1 = (0, _ko.computed)(function () {\n\t\tif (self.step() == 1) return (0, _ko.parserko6)('<p><i><span>step </span>{m.step()}</i></p>');\n\t\tif (self.step() == 2) return (0, _ko.parserko6)('<p><b><span>step </span>{m.step()}</b></p>');\n\t\tif (self.step() == 3) return (0, _ko.parserko6)('<p><b><i><span>step </span>{m.step()}</i></b></p>');\n\t\treturn (0, _ko.parserko6)('<p><span>step </span>{m.step().length}</p>');\n\t}, this);\n\n\tfunction _random(max) {\n\t\treturn Math.round(Math.random() * 1000) % max;\n\t}\n\n\tfunction buildData(count) {\n\t\tvar adjectives = [\"pretty\", \"large\", \"big\", \"small\", \"tall\", \"short\", \"long\", \"handsome\", \"plain\", \"quaint\", \"clean\", \"elegant\", \"easy\", \"angry\", \"crazy\", \"helpful\", \"mushy\", \"odd\", \"unsightly\", \"adorable\", \"important\", \"inexpensive\", \"cheap\", \"expensive\", \"fancy\"];\n\t\tvar colours = [\"red\", \"yellow\", \"blue\", \"green\", \"pink\", \"brown\", \"purple\", \"brown\", \"white\", \"black\", \"orange\"];\n\t\tvar nouns = [\"table\", \"chair\", \"house\", \"bbq\", \"desk\", \"car\", \"pony\", \"cookie\", \"sandwich\", \"burger\", \"pizza\", \"mouse\", \"keyboard\"];\n\t\tvar data = [];\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tdata.push(new ItemViewModel({\n\t\t\t\tid: self.id++,\n\t\t\t\tlabel: adjectives[_random(adjectives.length)] + \" \" + colours[_random(colours.length)] + \" \" + nouns[_random(nouns.length)]\n\t\t\t}, self));\n\t\t}\n\t\treturn data;\n\t}\n\n\tself.selected = (0, _ko.observable)(null);\n\tself.data = (0, _ko.observableArray)();\n\n\tself.run = function () {\n\t\tstartMeasure(\"run\");\n\t\tself.data(buildData(1000));\n\t\tself.selected(null);\n\t\tstopMeasure();\n\t};\n\n\tself.runLots = function () {\n\t\tstartMeasure(\"runLots\");\n\t\tself.data(buildData(10000));\n\t\tself.selected(null);\n\t\tstopMeasure();\n\t};\n\n\tself.add = function () {\n\t\tstartMeasure(\"add\");\n\t\t(0, _tkoUtils.arrayPushAll)(self.data, buildData(1000));\n\t\tstopMeasure();\n\t};\n\n\tself.update = function () {\n\t\tstartMeasure(\"update\");\n\t\tvar tmp = self.data();\n\t\tfor (var i = 0; i < tmp.length; i += 10) {\n\t\t\ttmp[i].label(tmp[i].label() + ' !!!');\n\t\t}\n\t\tstopMeasure();\n\t};\n\n\tself.clear = function () {\n\t\tstartMeasure(\"clear\");\n\t\tself.data.removeAll();\n\t\tself.selected(null);\n\t\tstopMeasure();\n\t};\n\n\tself.swapRows = function () {\n\t\tstartMeasure(\"swapRows\");\n\t\tvar tmp = self.data();\n\t\tif (tmp.length >= 10) {\n\t\t\tvar a = tmp[4];\n\t\t\ttmp[4] = tmp[9];\n\t\t\ttmp[9] = a;\n\t\t\tself.data(tmp);\n\t\t}\n\t\tstopMeasure();\n\t};\n\n\tself.del1000 = function () {\n\t\tstartMeasure(\"delete1000\");\n\t\tvar max = self.data().length;\n\t\tif (max > 1000) self.data.splice(max - 1000, max);\n\t\tconsole.log('new size', self.data().length);\n\t\tstopMeasure();\n\t};\n\n\tself.select = function (id) {\n\t\tstartMeasure(\"select\");\n\t\tself.selected(id);\n\t\tstopMeasure();\n\t};\n\n\tself.del = function (item) {\n\t\tstartMeasure(\"delete\");\n\t\tself.data.remove(function (d) {\n\t\t\treturn d.id === item.id;\n\t\t});\n\t\tstopMeasure();\n\t};\n};\n\nvar ItemViewModel = function ItemViewModel(data, parent) {\n\tvar self = this;\n\n\tself.id = data.id;\n\tself.label = (0, _ko.observable)(data.label);\n\n\tself.del = function () {\n\t\tparent.del(self);\n\t};\n\n\tself.select = function () {\n\t\tparent.select(self.id);\n\t};\n};\n\n/** @jsx kox */\n/** @jsx-arrow(m,ctx) */\nvar x = '\\n    <div class=\"container\">\\n        <div class=\"jumbotron\">\\n            <div class=\"row\">\\n                <div class=\"col-md-6\">\\n                    <h1>Knockout JSX</h1>\\n                    <p>{m.log}</p>\\n\\n                    <If value={m.step()<4}>\\n\\t                   \\t<div><span>step </span>{m.step}</div>\\n\\t                   \\t<Template value={m.tpl1} />\\n\\t\\t\\t\\t\\t\\t<Html value={\\'steppp \\'+m.step()} />\\n\\t                </If>\\n\\n                </div>\\n                <div class=\"col-md-6\">\\n                    <div class=\"row\">\\n                        <div class=\"col-sm-6 smallpad\">\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"run\" click={m.run}>Create 1,000 rows</button>\\n                        </div>\\n                        <div class=\"col-sm-6 smallpad\">\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"runlots\" click={m.runLots}>Create 10,000 rows</button>\\n                        </div>\\n                        <div class=\"col-sm-6 smallpad\">\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"add\" click={m.add}>Append 1,000 rows</button>\\n                        </div>\\n                        <div class=\"col-sm-6 smallpad\">\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"update\" click={m.update}>Update every 10th row</button>\\n                        </div>\\n                        <div class=\"col-sm-6 smallpad\">\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"clear\" click={m.clear}>Clear</button>\\n                        </div>\\n                        <div class=\"col-sm-6 smallpad\">\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"remove1000\" click={m.del1000}>Remove last 1000</button>\\n                            <button type=\"button\" class=\"btn btn-primary btn-block\" id=\"swaprows\" click={m.swapRows}>Swap Rows</button>\\n                        </div>\\n                    </div>\\n                </div>\\n            </div>\\n        </div>\\n        <table class=\"table table-hover table-striped test-data\">\\n\\t\\t\\t<tbody>\\n\\t\\t\\t\\t<tr><td>1</td><td>1</td><td>1</td><td>1</td></tr>\\n\\t\\t\\t\\t<Foreach items={m.data} key={m.id}>\\n\\t\\t\\t\\t\\t<tr>\\n\\t\\t\\t\\t\\t\\t<td class=\"col-md-1\">{m.id}</td>\\n\\t\\t\\t\\t\\t\\t<td class=\"col-md-4\">\\n\\t\\t\\t\\t\\t\\t\\t<a xclick={m.select}>{m.label}</a>\\n\\t\\t\\t\\t\\t\\t</td>\\n\\t\\t\\t\\t\\t\\t<td class=\"col-md-1\"><a xclick={m.del}><span class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></span></a></td>\\n\\t\\t\\t\\t\\t\\t<td class=\"col-md-6\"></td>\\n\\t\\t\\t\\t\\t</tr>\\n\\t\\t\\t\\t</Foreach>\\n\\t\\t\\t\\t<tr><td>2</td><td>2</td><td>2</td><td>2</td></tr>\\n\\t\\t\\t</tbody>\\n        </table>\\n        <span class=\"preloadicon glyphicon glyphicon-remove\" aria-hidden=\"true\"></span>\\n    </div>';\n\nconsole.log('start');\nwindow.mainModel = new HomeViewModel();\n\n/*\r\nsetInterval(function(){ \r\n\tvar raw = window.mainModel.step()+1;\r\n\tif(raw>5) raw = 1;\r\n\twindow.mainModel.step(raw);\r\n}, 1000);\r\n*/\n\nvar el = document.getElementById(\"main\");\n(0, _ko.ko6)(el, x, window.mainModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL21haW4uanM/OTg2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcnJheVB1c2hBbGwgfSAgZnJvbSAnLi90a28vdGtvLnV0aWxzLmpzJztcclxuaW1wb3J0IHsga282LCBwYXJzZXJrbzYsIG9ic2VydmFibGUsIG9ic2VydmFibGVBcnJheSwgY29tcHV0ZWQgfSAgZnJvbSAnLi9rbzYuanMnO1xyXG5cclxud2luZG93LmNvdW50PTA7XHJcblxyXG52YXIgc3RhcnRUaW1lO1xyXG52YXIgbGFzdE1lYXN1cmU7XHJcblxyXG52YXIgc3RhcnRNZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHRsYXN0TWVhc3VyZSA9IG5hbWU7XHJcbn07XHJcbnZhciBzdG9wTWVhc3VyZSA9IGZ1bmN0aW9uICgpIHtcclxuXHR3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3RvcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cdFx0Y29uc29sZS5sb2cobGFzdE1lYXN1cmUgKyBcIiB0b29rIFwiICsgKHN0b3AgLSBzdGFydFRpbWUpLCB3aW5kb3cuY291bnQpO1xyXG5cdFx0aWYod2luZG93Lm1haW5Nb2RlbCkgd2luZG93Lm1haW5Nb2RlbC5sb2cobGFzdE1lYXN1cmUgKyBcIiB0b29rIFwiICsgKHN0b3AgLSBzdGFydFRpbWUpLnRvRml4ZWQoMCkrXCJtcyBzdWJzY3JpYmVycyBcIit3aW5kb3cuY291bnQpO1xyXG5cdH0sIDApO1xyXG59O1xyXG5cclxudmFyIEhvbWVWaWV3TW9kZWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdHNlbGYuaWQgPSAxO1xyXG5cclxuXHRzZWxmLmxvZyA9IG9ic2VydmFibGUoKTtcclxuXHJcblx0c2VsZi5zdGVwID0gb2JzZXJ2YWJsZSgxKTtcclxuXHJcblx0c2VsZi50cGwxID0gY29tcHV0ZWQoIFxyXG5cdFx0ZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYoc2VsZi5zdGVwKCk9PTEpIHJldHVybiBwYXJzZXJrbzYoJzxwPjxpPjxzcGFuPnN0ZXAgPC9zcGFuPnttLnN0ZXAoKX08L2k+PC9wPicpO1xyXG5cdFx0XHRpZihzZWxmLnN0ZXAoKT09MikgcmV0dXJuIHBhcnNlcmtvNignPHA+PGI+PHNwYW4+c3RlcCA8L3NwYW4+e20uc3RlcCgpfTwvYj48L3A+Jyk7XHJcblx0XHRcdGlmKHNlbGYuc3RlcCgpPT0zKSByZXR1cm4gcGFyc2Vya282KCc8cD48Yj48aT48c3Bhbj5zdGVwIDwvc3Bhbj57bS5zdGVwKCl9PC9pPjwvYj48L3A+Jyk7XHJcblx0XHRcdHJldHVybiBwYXJzZXJrbzYoJzxwPjxzcGFuPnN0ZXAgPC9zcGFuPnttLnN0ZXAoKS5sZW5ndGh9PC9wPicpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdGZ1bmN0aW9uIF9yYW5kb20obWF4KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMCkgJSBtYXg7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBidWlsZERhdGEoY291bnQpIHtcclxuXHRcdHZhciBhZGplY3RpdmVzID0gW1wicHJldHR5XCIsIFwibGFyZ2VcIiwgXCJiaWdcIiwgXCJzbWFsbFwiLCBcInRhbGxcIiwgXCJzaG9ydFwiLCBcImxvbmdcIiwgXCJoYW5kc29tZVwiLCBcInBsYWluXCIsIFwicXVhaW50XCIsIFwiY2xlYW5cIiwgXCJlbGVnYW50XCIsIFwiZWFzeVwiLCBcImFuZ3J5XCIsIFwiY3JhenlcIiwgXCJoZWxwZnVsXCIsIFwibXVzaHlcIiwgXCJvZGRcIiwgXCJ1bnNpZ2h0bHlcIiwgXCJhZG9yYWJsZVwiLCBcImltcG9ydGFudFwiLCBcImluZXhwZW5zaXZlXCIsIFwiY2hlYXBcIiwgXCJleHBlbnNpdmVcIiwgXCJmYW5jeVwiXTtcclxuXHRcdHZhciBjb2xvdXJzID0gW1wicmVkXCIsIFwieWVsbG93XCIsIFwiYmx1ZVwiLCBcImdyZWVuXCIsIFwicGlua1wiLCBcImJyb3duXCIsIFwicHVycGxlXCIsIFwiYnJvd25cIiwgXCJ3aGl0ZVwiLCBcImJsYWNrXCIsIFwib3JhbmdlXCJdO1xyXG5cdFx0dmFyIG5vdW5zID0gW1widGFibGVcIiwgXCJjaGFpclwiLCBcImhvdXNlXCIsIFwiYmJxXCIsIFwiZGVza1wiLCBcImNhclwiLCBcInBvbnlcIiwgXCJjb29raWVcIiwgXCJzYW5kd2ljaFwiLCBcImJ1cmdlclwiLCBcInBpenphXCIsIFwibW91c2VcIiwgXCJrZXlib2FyZFwiXTtcclxuXHRcdHZhciBkYXRhID0gW107XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHRcdFx0ZGF0YS5wdXNoKG5ldyBJdGVtVmlld01vZGVsKHtcclxuXHRcdFx0XHRpZDogc2VsZi5pZCsrLFxyXG5cdFx0XHRcdGxhYmVsOiBhZGplY3RpdmVzW19yYW5kb20oYWRqZWN0aXZlcy5sZW5ndGgpXSArIFwiIFwiICsgY29sb3Vyc1tfcmFuZG9tKGNvbG91cnMubGVuZ3RoKV0gKyBcIiBcIiArIG5vdW5zW19yYW5kb20obm91bnMubGVuZ3RoKV1cclxuXHRcdFx0fSwgc2VsZikpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblx0fVxyXG5cclxuXHRzZWxmLnNlbGVjdGVkID0gb2JzZXJ2YWJsZShudWxsKTtcclxuXHRzZWxmLmRhdGEgPSBvYnNlcnZhYmxlQXJyYXkoKTtcclxuXHJcblx0c2VsZi5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRzdGFydE1lYXN1cmUoXCJydW5cIik7XHJcblx0XHRzZWxmLmRhdGEoYnVpbGREYXRhKDEwMDApKTtcclxuXHRcdHNlbGYuc2VsZWN0ZWQobnVsbCk7XHJcblx0XHRzdG9wTWVhc3VyZSgpO1xyXG5cdH07XHJcblxyXG5cdHNlbGYucnVuTG90cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHN0YXJ0TWVhc3VyZShcInJ1bkxvdHNcIik7XHJcblx0XHRzZWxmLmRhdGEoYnVpbGREYXRhKDEwMDAwKSk7XHJcblx0XHRzZWxmLnNlbGVjdGVkKG51bGwpO1xyXG5cdFx0c3RvcE1lYXN1cmUoKTtcclxuXHR9O1xyXG5cclxuXHRzZWxmLmFkZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHN0YXJ0TWVhc3VyZShcImFkZFwiKTtcclxuXHRcdGFycmF5UHVzaEFsbChzZWxmLmRhdGEsIGJ1aWxkRGF0YSgxMDAwKSk7XHJcblx0XHRzdG9wTWVhc3VyZSgpO1xyXG5cdH07XHJcblxyXG5cdHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0c3RhcnRNZWFzdXJlKFwidXBkYXRlXCIpO1xyXG5cdFx0dmFyIHRtcCA9IHNlbGYuZGF0YSgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpICs9IDEwKSB7XHJcblx0XHRcdHRtcFtpXS5sYWJlbCh0bXBbaV0ubGFiZWwoKSArICcgISEhJyk7XHJcblx0XHR9XHJcblx0XHRzdG9wTWVhc3VyZSgpO1xyXG5cdH07XHJcblxyXG5cdHNlbGYuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRzdGFydE1lYXN1cmUoXCJjbGVhclwiKTtcclxuXHRcdHNlbGYuZGF0YS5yZW1vdmVBbGwoKTtcclxuXHRcdHNlbGYuc2VsZWN0ZWQobnVsbCk7XHJcblx0XHRzdG9wTWVhc3VyZSgpO1xyXG5cdH07XHJcblxyXG5cdHNlbGYuc3dhcFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRzdGFydE1lYXN1cmUoXCJzd2FwUm93c1wiKTtcclxuXHRcdHZhciB0bXAgPSBzZWxmLmRhdGEoKTtcclxuXHRcdGlmICh0bXAubGVuZ3RoID49IDEwKSB7XHJcblx0XHRcdHZhciBhID0gdG1wWzRdO1xyXG5cdFx0XHR0bXBbNF0gPSB0bXBbOV07XHJcblx0XHRcdHRtcFs5XSA9IGE7XHJcblx0XHRcdHNlbGYuZGF0YSh0bXApO1xyXG5cdFx0fVxyXG5cdFx0c3RvcE1lYXN1cmUoKTtcclxuXHR9O1xyXG5cclxuXHRzZWxmLmRlbDEwMDAgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRzdGFydE1lYXN1cmUoXCJkZWxldGUxMDAwXCIpO1xyXG5cdFx0dmFyIG1heCA9IHNlbGYuZGF0YSgpLmxlbmd0aDtcclxuXHRcdGlmKG1heD4xMDAwKSBzZWxmLmRhdGEuc3BsaWNlKG1heC0xMDAwLCBtYXgpO1xyXG5cdFx0Y29uc29sZS5sb2coJ25ldyBzaXplJywgc2VsZi5kYXRhKCkubGVuZ3RoKTtcclxuXHRcdHN0b3BNZWFzdXJlKCk7XHJcblx0fTtcclxuXHJcblxyXG5cdHNlbGYuc2VsZWN0ID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRzdGFydE1lYXN1cmUoXCJzZWxlY3RcIik7XHJcblx0XHRzZWxmLnNlbGVjdGVkKGlkKTtcclxuXHRcdHN0b3BNZWFzdXJlKCk7XHJcblx0fTtcclxuXHJcblx0c2VsZi5kZWwgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0c3RhcnRNZWFzdXJlKFwiZGVsZXRlXCIpO1xyXG5cdFx0c2VsZi5kYXRhLnJlbW92ZShkID0+IGQuaWQgPT09IGl0ZW0uaWQpO1xyXG5cdFx0c3RvcE1lYXN1cmUoKTtcclxuXHR9O1xyXG5cclxufTtcclxuXHJcbnZhciBJdGVtVmlld01vZGVsID0gZnVuY3Rpb24gKGRhdGEsIHBhcmVudCkge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHJcblx0c2VsZi5pZCA9IGRhdGEuaWQ7XHJcblx0c2VsZi5sYWJlbCA9IG9ic2VydmFibGUoZGF0YS5sYWJlbCk7XHJcblxyXG5cdHNlbGYuZGVsID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0cGFyZW50LmRlbChzZWxmKTtcclxuXHR9O1xyXG5cclxuXHRzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHBhcmVudC5zZWxlY3Qoc2VsZi5pZCk7XHJcblx0fTtcclxufTtcclxuXHJcbi8qKiBAanN4IGtveCAqL1xyXG4vKiogQGpzeC1hcnJvdyhtLGN0eCkgKi9cclxudmFyIHggPSBgXHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp1bWJvdHJvblwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aDE+S25vY2tvdXQgSlNYPC9oMT5cclxuICAgICAgICAgICAgICAgICAgICA8cD57bS5sb2d9PC9wPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8SWYgdmFsdWU9e20uc3RlcCgpPDR9PlxyXG5cdCAgICAgICAgICAgICAgICAgICBcdDxkaXY+PHNwYW4+c3RlcCA8L3NwYW4+e20uc3RlcH08L2Rpdj5cclxuXHQgICAgICAgICAgICAgICAgICAgXHQ8VGVtcGxhdGUgdmFsdWU9e20udHBsMX0gLz5cclxuXHRcdFx0XHRcdFx0PEh0bWwgdmFsdWU9eydzdGVwcHAgJyttLnN0ZXAoKX0gLz5cclxuXHQgICAgICAgICAgICAgICAgPC9JZj5cclxuXHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02IHNtYWxscGFkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tYmxvY2tcIiBpZD1cInJ1blwiIGNsaWNrPXttLnJ1bn0+Q3JlYXRlIDEsMDAwIHJvd3M8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNiBzbWFsbHBhZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLWJsb2NrXCIgaWQ9XCJydW5sb3RzXCIgY2xpY2s9e20ucnVuTG90c30+Q3JlYXRlIDEwLDAwMCByb3dzPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTYgc21hbGxwYWRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1ibG9ja1wiIGlkPVwiYWRkXCIgY2xpY2s9e20uYWRkfT5BcHBlbmQgMSwwMDAgcm93czwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1zbS02IHNtYWxscGFkXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tYmxvY2tcIiBpZD1cInVwZGF0ZVwiIGNsaWNrPXttLnVwZGF0ZX0+VXBkYXRlIGV2ZXJ5IDEwdGggcm93PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLXNtLTYgc21hbGxwYWRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1ibG9ja1wiIGlkPVwiY2xlYXJcIiBjbGljaz17bS5jbGVhcn0+Q2xlYXI8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tNiBzbWFsbHBhZFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLWJsb2NrXCIgaWQ9XCJyZW1vdmUxMDAwXCIgY2xpY2s9e20uZGVsMTAwMH0+UmVtb3ZlIGxhc3QgMTAwMDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLWJsb2NrXCIgaWQ9XCJzd2Fwcm93c1wiIGNsaWNrPXttLnN3YXBSb3dzfT5Td2FwIFJvd3M8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtaG92ZXIgdGFibGUtc3RyaXBlZCB0ZXN0LWRhdGFcIj5cclxuXHRcdFx0PHRib2R5PlxyXG5cdFx0XHRcdDx0cj48dGQ+MTwvdGQ+PHRkPjE8L3RkPjx0ZD4xPC90ZD48dGQ+MTwvdGQ+PC90cj5cclxuXHRcdFx0XHQ8Rm9yZWFjaCBpdGVtcz17bS5kYXRhfSBrZXk9e20uaWR9PlxyXG5cdFx0XHRcdFx0PHRyPlxyXG5cdFx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJjb2wtbWQtMVwiPnttLmlkfTwvdGQ+XHJcblx0XHRcdFx0XHRcdDx0ZCBjbGFzcz1cImNvbC1tZC00XCI+XHJcblx0XHRcdFx0XHRcdFx0PGEgeGNsaWNrPXttLnNlbGVjdH0+e20ubGFiZWx9PC9hPlxyXG5cdFx0XHRcdFx0XHQ8L3RkPlxyXG5cdFx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJjb2wtbWQtMVwiPjxhIHhjbGljaz17bS5kZWx9PjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+PC9hPjwvdGQ+XHJcblx0XHRcdFx0XHRcdDx0ZCBjbGFzcz1cImNvbC1tZC02XCI+PC90ZD5cclxuXHRcdFx0XHRcdDwvdHI+XHJcblx0XHRcdFx0PC9Gb3JlYWNoPlxyXG5cdFx0XHRcdDx0cj48dGQ+MjwvdGQ+PHRkPjI8L3RkPjx0ZD4yPC90ZD48dGQ+MjwvdGQ+PC90cj5cclxuXHRcdFx0PC90Ym9keT5cclxuICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwicHJlbG9hZGljb24gZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XHJcbiAgICA8L2Rpdj5gXHJcbjtcclxuXHJcbmNvbnNvbGUubG9nKCdzdGFydCcpO1xyXG53aW5kb3cubWFpbk1vZGVsID0gbmV3IEhvbWVWaWV3TW9kZWwoKTtcclxuXHJcbi8qXHJcbnNldEludGVydmFsKGZ1bmN0aW9uKCl7IFxyXG5cdHZhciByYXcgPSB3aW5kb3cubWFpbk1vZGVsLnN0ZXAoKSsxO1xyXG5cdGlmKHJhdz41KSByYXcgPSAxO1xyXG5cdHdpbmRvdy5tYWluTW9kZWwuc3RlcChyYXcpO1xyXG59LCAxMDAwKTtcclxuKi9cclxuXHJcblxyXG52YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW5cIik7XHJcbmtvNihlbCwgeCwgd2luZG93Lm1haW5Nb2RlbCk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL21haW4uanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMkRBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XG59IGNhdGNoKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcblx0XHRnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!*************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/ko6.js ***!
  \*************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.renderCtx = exports.computed = exports.observableArray = exports.observable = exports.parserko6 = exports.ko6 = undefined;\n\nvar _tkoObservable = __webpack_require__(/*! ./tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ./tko/tko.computed.js */ 2);\n\nvar _renderCtx = __webpack_require__(/*! ./renderCtx.js */ 3);\n\nvar _parserko = __webpack_require__(/*! ./parserko6.js */ 9);\n\nvar _blockComponent = __webpack_require__(/*! ./blocks/blockComponent.js */ 5);\n\nvar _blockComponent2 = _interopRequireDefault(_blockComponent);\n\nvar _blockForeach = __webpack_require__(/*! ./blocks/blockForeach.js */ 13);\n\nvar _blockForeach2 = _interopRequireDefault(_blockForeach);\n\nvar _blockIf = __webpack_require__(/*! ./blocks/blockIf.js */ 14);\n\nvar _blockIf2 = _interopRequireDefault(_blockIf);\n\nvar _blockHtml = __webpack_require__(/*! ./blocks/blockHtml.js */ 15);\n\nvar _blockHtml2 = _interopRequireDefault(_blockHtml);\n\nvar _blockTemplate = __webpack_require__(/*! ./blocks/blockTemplate.js */ 16);\n\nvar _blockTemplate2 = _interopRequireDefault(_blockTemplate);\n\nvar _click = __webpack_require__(/*! ./bindings/click.js */ 17);\n\nvar _click2 = _interopRequireDefault(_click);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_renderCtx.renderCtx.blocks['Component'] = _blockComponent2.default;\n_renderCtx.renderCtx.blocks['Foreach'] = _blockForeach2.default;\n_renderCtx.renderCtx.blocks['If'] = _blockIf2.default;\n_renderCtx.renderCtx.blocks['Html'] = _blockHtml2.default;\n_renderCtx.renderCtx.blocks['Template'] = _blockTemplate2.default;\n\n_renderCtx.renderCtx.bindingHandlers['click'] = _click2.default;\n\nfunction ko6(parent, tpl, model) {\n\tvar ctx = (0, _renderCtx.createCtx)(model, null, null);\n\tparent.innerHtml = '';\n\tvar tpl2 = (0, _parserko.parserko6)(tpl);\n\t(0, _renderCtx.renderCtx)(parent, tpl2, ctx, 0);\n\twindow.rootCtx = ctx;\n\treturn ctx;\n};\n\nexports.ko6 = ko6;\nexports.parserko6 = _parserko.parserko6;\nexports.observable = _tkoObservable.observable;\nexports.observableArray = _tkoObservable.observableArray;\nexports.computed = _tkoComputed.computed;\nexports.renderCtx = _renderCtx.renderCtx;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2tvNi5qcz84YmM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG9ic2VydmFibGUsIG9ic2VydmFibGVBcnJheSB9IGZyb20gJy4vdGtvL3Rrby5vYnNlcnZhYmxlLmpzJztcclxuaW1wb3J0IHsgY29tcHV0ZWQgfSAgZnJvbSAnLi90a28vdGtvLmNvbXB1dGVkLmpzJztcclxuaW1wb3J0IHsgcmVuZGVyQ3R4LCBjcmVhdGVDdHggfSAgZnJvbSAnLi9yZW5kZXJDdHguanMnO1xyXG5pbXBvcnQgeyBwYXJzZXJrbzYgfSAgZnJvbSAnLi9wYXJzZXJrbzYuanMnO1xyXG5cclxuaW1wb3J0IGJsb2NrQ29tcG9uZW50ICBmcm9tICcuL2Jsb2Nrcy9ibG9ja0NvbXBvbmVudC5qcyc7XHJcbmltcG9ydCBibG9ja0ZvcmVhY2ggIGZyb20gJy4vYmxvY2tzL2Jsb2NrRm9yZWFjaC5qcyc7XHJcbmltcG9ydCBibG9ja0lmICBmcm9tICcuL2Jsb2Nrcy9ibG9ja0lmLmpzJztcclxuaW1wb3J0IGJsb2NrSHRtbCAgZnJvbSAnLi9ibG9ja3MvYmxvY2tIdG1sLmpzJztcclxuaW1wb3J0IGJsb2NrVGVtcGxhdGUgIGZyb20gJy4vYmxvY2tzL2Jsb2NrVGVtcGxhdGUuanMnO1xyXG5cclxuaW1wb3J0IGNsaWNrSGFuZGxlciAgZnJvbSAnLi9iaW5kaW5ncy9jbGljay5qcyc7XHJcblxyXG5yZW5kZXJDdHguYmxvY2tzWydDb21wb25lbnQnXSA9IGJsb2NrQ29tcG9uZW50O1xyXG5yZW5kZXJDdHguYmxvY2tzWydGb3JlYWNoJ10gPSBibG9ja0ZvcmVhY2g7XHJcbnJlbmRlckN0eC5ibG9ja3NbJ0lmJ10gPSBibG9ja0lmO1xyXG5yZW5kZXJDdHguYmxvY2tzWydIdG1sJ10gPSBibG9ja0h0bWw7XHJcbnJlbmRlckN0eC5ibG9ja3NbJ1RlbXBsYXRlJ10gPSBibG9ja1RlbXBsYXRlO1xyXG5cclxucmVuZGVyQ3R4LmJpbmRpbmdIYW5kbGVyc1snY2xpY2snXSA9IGNsaWNrSGFuZGxlcjtcclxuXHJcbmZ1bmN0aW9uIGtvNihwYXJlbnQsIHRwbCwgbW9kZWwpe1xyXG5cdHZhciBjdHggPSBjcmVhdGVDdHgobW9kZWwsIG51bGwsIG51bGwpO1xyXG5cdHBhcmVudC5pbm5lckh0bWwgPSAnJztcclxuXHR2YXIgdHBsMiA9IHBhcnNlcmtvNih0cGwpO1xyXG5cdHJlbmRlckN0eChwYXJlbnQsIHRwbDIsIGN0eCwgMCk7XHJcblx0d2luZG93LnJvb3RDdHggPSBjdHg7XHJcblx0cmV0dXJuIGN0eDtcclxufTtcclxuXHJcbmV4cG9ydCB7XHJcblx0a282LFxyXG5cdHBhcnNlcmtvNixcclxuXHRvYnNlcnZhYmxlLFxyXG5cdG9ic2VydmFibGVBcnJheSxcclxuXHRjb21wdXRlZCxcclxuXHRyZW5kZXJDdHhcclxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9rbzYuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!*******************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/parserko6.js ***!
  \*******************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDefaults = undefined;\nexports.parserko6 = parserko6;\n\nvar _lexer = __webpack_require__(/*! ./himalaya/lexer.js */ 10);\n\nvar _lexer2 = _interopRequireDefault(_lexer);\n\nvar _parser = __webpack_require__(/*! ./himalaya/parser.js */ 11);\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _tags = __webpack_require__(/*! ./himalaya/tags.js */ 12);\n\nvar _compat = __webpack_require__(/*! ./himalaya/compat.js */ 4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar parseDefaults = exports.parseDefaults = {\n  voidTags: _tags.voidTags,\n  closingTags: _tags.closingTags,\n  childlessTags: _tags.childlessTags,\n  closingTagAncestorBreakers: _tags.closingTagAncestorBreakers\n};\n\nfunction parserko6(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  var startTime = performance.now();\n\n  var tokens = (0, _lexer2.default)(str, options);\n  var nodes = (0, _parser2.default)(tokens, options);\n  var map = format(nodes, options);\n\n  var finishTime = performance.now();\n  console.log('parserko6', finishTime - startTime);\n  return map;\n}\n\nfunction format(nodes) {\n  var arr = [];\n  nodes.forEach(function (node) {\n    var type = node.type;\n    if (type === 'element') {\n      var tag = node.tagName;\n      var attrs = formatAttributes(node.attributes);\n      var children = format(node.children);\n\n      var obj = {};\n      if (tag.toLowerCase() != tag || tag.indexOf('-') > 0) {\n        obj.block = tag;\n      } else {\n        obj.tag = tag;\n      }\n      if (attrs && Object.keys(attrs).length > 0) {\n        obj.attrs = attrs;\n      }\n      if (children && children.length > 0) {\n        obj.children = children;\n      }\n      arr.push(obj);\n    }\n    if (!isEmptyOrSpaces(node.content)) {\n      arr.push(parseJsExression(node.content));\n    }\n  });\n  return arr;\n}\n\nfunction formatAttributes(attributes) {\n  var attrs = {};\n  attributes.forEach(function (attribute) {\n    var parts = splitHead(attribute.trim(), '=');\n    var key = parts[0];\n    var value = typeof parts[1] === 'string' ? unquote(parts[1]) : null;\n    attrs[key] = parseJsExression(value);\n  });\n  return attrs;\n}\n\nfunction splitHead(str, sep) {\n  var idx = str.indexOf(sep);\n  if (idx === -1) return [str];\n  return [str.slice(0, idx), str.slice(idx + sep.length)];\n}\n\nfunction unquote(str) {\n  var car = str.charAt(0);\n  var end = str.length - 1;\n  var isQuoteStart = car === '\"' || car === \"'\";\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end);\n  }\n  return str;\n}\n\nfunction parseJsExression(s) {\n  if ((0, _compat.startsWith)(s, '{') && (0, _compat.endsWith)(s, '}')) {\n    s = s.slice(1, s.length - 1);\n    console.log(s);\n    return new Function('m', 'ctx', 'return ' + s);\n  }\n  return s;\n}\n\nfunction isEmptyOrSpaces(str) {\n  return !str || !str.match || str.match(/^\\s*$/) !== null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL3BhcnNlcmtvNi5qcz9mOWJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsZXhlciBmcm9tICcuL2hpbWFsYXlhL2xleGVyLmpzJ1xyXG5pbXBvcnQgcGFyc2VyIGZyb20gJy4vaGltYWxheWEvcGFyc2VyLmpzJ1xyXG5pbXBvcnQge1xyXG4gIHZvaWRUYWdzLFxyXG4gIGNsb3NpbmdUYWdzLFxyXG4gIGNoaWxkbGVzc1RhZ3MsXHJcbiAgY2xvc2luZ1RhZ0FuY2VzdG9yQnJlYWtlcnNcclxufSBmcm9tICcuL2hpbWFsYXlhL3RhZ3MuanMnXHJcblxyXG5pbXBvcnQge1xyXG4gIHN0YXJ0c1dpdGgsXHJcbiAgZW5kc1dpdGhcclxufSBmcm9tICcuL2hpbWFsYXlhL2NvbXBhdC5qcydcclxuXHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VEZWZhdWx0cyA9IHtcclxuICB2b2lkVGFncyxcclxuICBjbG9zaW5nVGFncyxcclxuICBjaGlsZGxlc3NUYWdzLFxyXG4gIGNsb3NpbmdUYWdBbmNlc3RvckJyZWFrZXJzXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJrbzYgKHN0ciwgb3B0aW9ucyA9IHBhcnNlRGVmYXVsdHMpIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgY29uc3QgdG9rZW5zID0gbGV4ZXIoc3RyLCBvcHRpb25zKVxyXG4gIGNvbnN0IG5vZGVzID0gcGFyc2VyKHRva2Vucywgb3B0aW9ucylcclxuICBjb25zdCBtYXAgPSBmb3JtYXQobm9kZXMsIG9wdGlvbnMpXHJcblxyXG4gIGNvbnN0IGZpbmlzaFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICBjb25zb2xlLmxvZygncGFyc2Vya282JywgKGZpbmlzaFRpbWUtc3RhcnRUaW1lKSk7XHJcbiAgcmV0dXJuIG1hcDtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0IChub2Rlcykge1xyXG4gIHZhciBhcnIgPSBbXTtcclxuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IG5vZGUudHlwZVxyXG4gICAgaWYgKHR5cGUgPT09ICdlbGVtZW50Jykge1xyXG4gICAgICBjb25zdCB0YWcgPSBub2RlLnRhZ05hbWU7XHJcbiAgICAgIGNvbnN0IGF0dHJzID0gZm9ybWF0QXR0cmlidXRlcyhub2RlLmF0dHJpYnV0ZXMpXHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZm9ybWF0KG5vZGUuY2hpbGRyZW4pXHJcblxyXG4gICAgICBjb25zdCBvYmogPSB7fVxyXG4gICAgICBpZih0YWcudG9Mb3dlckNhc2UoKSE9dGFnIHx8IHRhZy5pbmRleE9mKCctJyk+MCl7XHJcbiAgICAgICAgb2JqLmJsb2NrID0gdGFnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9iai50YWcgPSB0YWc7XHJcbiAgICAgIH1cclxuICAgICAgaWYoYXR0cnMgJiYgT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aD4wKXtcclxuICAgICAgICBvYmouYXR0cnMgPSBhdHRycztcclxuICAgICAgfVxyXG4gICAgICBpZihjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg+MCl7XHJcbiAgICAgICAgb2JqLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgIH1cclxuICAgICAgYXJyLnB1c2gob2JqKVxyXG4gICAgfVxyXG4gICAgaWYoIWlzRW1wdHlPclNwYWNlcyhub2RlLmNvbnRlbnQpKXtcclxuICAgICAgYXJyLnB1c2gocGFyc2VKc0V4cmVzc2lvbihub2RlLmNvbnRlbnQpKVxyXG4gICAgfVxyXG4gIH0pXHJcbiAgcmV0dXJuIGFycjtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0QXR0cmlidXRlcyAoYXR0cmlidXRlcykge1xyXG4gIHZhciBhdHRycyA9IHt9XHJcbiAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XHJcbiAgICBjb25zdCBwYXJ0cyA9IHNwbGl0SGVhZChhdHRyaWJ1dGUudHJpbSgpLCAnPScpXHJcbiAgICBjb25zdCBrZXkgPSBwYXJ0c1swXVxyXG4gICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgcGFydHNbMV0gPT09ICdzdHJpbmcnXHJcbiAgICAgID8gdW5xdW90ZShwYXJ0c1sxXSlcclxuICAgICAgOiBudWxsXHJcbiAgICBhdHRyc1trZXldID0gcGFyc2VKc0V4cmVzc2lvbih2YWx1ZSk7XHJcbiAgfSlcclxuICByZXR1cm4gYXR0cnNcclxufSBcclxuXHJcbmZ1bmN0aW9uIHNwbGl0SGVhZCAoc3RyLCBzZXApIHtcclxuICBjb25zdCBpZHggPSBzdHIuaW5kZXhPZihzZXApXHJcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBbc3RyXVxyXG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGlkeCksIHN0ci5zbGljZShpZHggKyBzZXAubGVuZ3RoKV1cclxufVxyXG5cclxuZnVuY3Rpb24gdW5xdW90ZSAoc3RyKSB7XHJcbiAgY29uc3QgY2FyID0gc3RyLmNoYXJBdCgwKVxyXG4gIGNvbnN0IGVuZCA9IHN0ci5sZW5ndGggLSAxXHJcbiAgY29uc3QgaXNRdW90ZVN0YXJ0ID0gY2FyID09PSAnXCInIHx8IGNhciA9PT0gXCInXCJcclxuICBpZiAoaXNRdW90ZVN0YXJ0ICYmIGNhciA9PT0gc3RyLmNoYXJBdChlbmQpKSB7XHJcbiAgICByZXR1cm4gc3RyLnNsaWNlKDEsIGVuZClcclxuICB9XHJcbiAgcmV0dXJuIHN0clxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUpzRXhyZXNzaW9uKHMpe1xyXG4gICAgICBpZihzdGFydHNXaXRoKHMsICd7JykgJiYgZW5kc1dpdGgocywgJ30nKSl7XHJcbiAgICAgICAgcyA9IHMuc2xpY2UoMSwgcy5sZW5ndGgtMSk7XHJcbiAgICAgICAgY29uc29sZS5sb2cocyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbScsICdjdHgnLCAncmV0dXJuICcrcyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHlPclNwYWNlcyhzdHIpe1xyXG4gICAgcmV0dXJuICFzdHIgfHwgIXN0ci5tYXRjaCB8fCBzdHIubWF0Y2goL15cXHMqJC8pICE9PSBudWxsO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvcGFyc2Vya282LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFzQkE7QUFDQTtBQXZCQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBTUE7QUFDQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/lexer.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = lexer;\nexports.lex = lex;\nexports.findTextEnd = findTextEnd;\nexports.lexText = lexText;\nexports.lexComment = lexComment;\nexports.lexTag = lexTag;\nexports.isWhitespaceChar = isWhitespaceChar;\nexports.lexTagName = lexTagName;\nexports.lexTagAttributes = lexTagAttributes;\nexports.lexSkipTag = lexSkipTag;\n\nvar _compat = __webpack_require__(/*! ./compat.js */ 4);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction lexer(str, options) {\n  var state = { str: str, options: options, cursor: 0, tokens: [] };\n  lex(state);\n  return state.tokens;\n}\n\nfunction lex(state) {\n  var str = state.str;\n\n  var len = str.length;\n  while (state.cursor < len) {\n    var start = state.cursor;\n    lexText(state);\n    if (state.cursor === start) {\n      var isComment = (0, _compat.startsWith)(str, '!--', state.cursor + 1);\n      if (isComment) {\n        lexComment(state);\n      } else {\n        var tagName = lexTag(state);\n        var safeTag = tagName.toLowerCase();\n        var childlessTags = state.options.childlessTags;\n\n        if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state);\n        }\n      }\n    }\n  }\n}\n\nvar alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n  while (true) {\n    var textEnd = str.indexOf('<', index);\n    if (textEnd === -1) {\n      return textEnd;\n    }\n    var char = str.charAt(textEnd + 1);\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd;\n    }\n    index = textEnd + 1;\n  }\n}\n\nfunction lexText(state) {\n  var type = 'text';\n  var str = state.str,\n      cursor = state.cursor;\n\n  var textEnd = findTextEnd(str, cursor);\n  if (textEnd === -1) {\n    // there is only text left\n    var _content = str.slice(cursor);\n    state.cursor = str.length;\n    state.tokens.push({ type: type, content: _content });\n    return;\n  }\n\n  if (textEnd === cursor) return;\n\n  var content = str.slice(cursor, textEnd);\n  state.cursor = textEnd;\n  state.tokens.push({ type: type, content: content });\n}\n\nfunction lexComment(state) {\n  state.cursor += 4; // \"<!--\".length\n  var str = state.str,\n      cursor = state.cursor;\n\n  var commentEnd = str.indexOf('-->', cursor);\n  var type = 'comment';\n  if (commentEnd === -1) {\n    // there is only the comment left\n    var _content2 = str.slice(cursor);\n    state.cursor = str.length;\n    state.tokens.push({ type: type, content: _content2 });\n    return;\n  }\n\n  var content = str.slice(cursor, commentEnd);\n  state.cursor = commentEnd + 3; // \"-->\".length\n  state.tokens.push({ type: type, content: content });\n}\n\nfunction lexTag(state) {\n  var str = state.str;\n\n  {\n    var secondChar = str.charAt(state.cursor + 1);\n    var close = secondChar === '/';\n    state.tokens.push({ type: 'tag-start', close: close });\n    state.cursor += close ? 2 : 1;\n  }\n  var tagName = lexTagName(state);\n  lexTagAttributes(state);\n  {\n    var firstChar = str.charAt(state.cursor);\n    var _close = firstChar === '/';\n    state.tokens.push({ type: 'tag-end', close: _close });\n    state.cursor += _close ? 2 : 1;\n  }\n  return tagName;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nvar whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n  return whitespace.test(char);\n}\n\nfunction lexTagName(state) {\n  var str = state.str,\n      cursor = state.cursor;\n\n  var len = str.length;\n  var start = cursor;\n  while (start < len) {\n    var char = str.charAt(start);\n    var isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n    if (isTagChar) break;\n    start++;\n  }\n\n  var end = start + 1;\n  while (end < len) {\n    var _char = str.charAt(end);\n    var _isTagChar = !(isWhitespaceChar(_char) || _char === '/' || _char === '>');\n    if (!_isTagChar) break;\n    end++;\n  }\n\n  state.cursor = end;\n  var tagName = str.slice(start, end);\n  state.tokens.push({ type: 'tag', content: tagName });\n  return tagName;\n}\n\nfunction lexTagAttributes(state) {\n  var str = state.str,\n      tokens = state.tokens;\n\n  var cursor = state.cursor;\n  var quote = null; // null, single-, or double-quote\n  var wordBegin = cursor; // index of word start\n  var words = []; // \"key\", \"key=value\", \"key='value'\", etc\n  var len = str.length;\n  while (cursor < len) {\n    var char = str.charAt(cursor);\n    if (quote) {\n      var isQuoteEnd = char === quote;\n      if (isQuoteEnd) {\n        quote = null;\n      }\n      cursor++;\n      continue;\n    }\n\n    var isTagEnd = char === '/' || char === '>';\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      break;\n    }\n\n    var isWordEnd = isWhitespaceChar(char);\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      wordBegin = cursor + 1;\n      cursor++;\n      continue;\n    }\n\n    var isQuoteStart = char === '\\'' || char === '\"';\n    if (isQuoteStart) {\n      quote = char;\n      cursor++;\n      continue;\n    }\n\n    cursor++;\n  }\n  state.cursor = cursor;\n\n  var wLen = words.length;\n  var type = 'attribute';\n  for (var i = 0; i < wLen; i++) {\n    var word = words[i];\n    var isNotPair = word.indexOf('=') === -1;\n    if (isNotPair) {\n      var secondWord = words[i + 1];\n      if (secondWord && (0, _compat.startsWith)(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          var newWord = word + secondWord;\n          tokens.push({ type: type, content: newWord });\n          i += 1;\n          continue;\n        }\n        var thirdWord = words[i + 2];\n        i += 1;\n        if (thirdWord) {\n          var _newWord = word + '=' + thirdWord;\n          tokens.push({ type: type, content: _newWord });\n          i += 1;\n          continue;\n        }\n      }\n    }\n    if ((0, _compat.endsWith)(word, '=')) {\n      var _secondWord = words[i + 1];\n      if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, '=')) {\n        var _newWord3 = word + _secondWord;\n        tokens.push({ type: type, content: _newWord3 });\n        i += 1;\n        continue;\n      }\n\n      var _newWord2 = word.slice(0, -1);\n      tokens.push({ type: type, content: _newWord2 });\n      continue;\n    }\n\n    tokens.push({ type: type, content: word });\n  }\n}\n\nfunction lexSkipTag(tagName, state) {\n  var str = state.str,\n      cursor = state.cursor,\n      tokens = state.tokens;\n\n  var len = str.length;\n  var index = cursor;\n  while (index < len) {\n    var nextTag = str.indexOf('</', index);\n    if (nextTag === -1) {\n      lexText(state);\n      break;\n    }\n\n    var tagState = { str: str, cursor: nextTag + 2, tokens: [] };\n    var name = lexTagName(tagState);\n    var safeTagName = tagName.toLowerCase();\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.cursor;\n      continue;\n    }\n\n    var content = str.slice(cursor, nextTag);\n    tokens.push({ type: 'text', content: content });\n    var openTag = { type: 'tag-start', close: true };\n    var closeTag = { type: 'tag-end', close: false };\n    lexTagAttributes(tagState);\n    tokens.push.apply(tokens, [openTag].concat(_toConsumableArray(tagState.tokens), [closeTag]));\n    state.cursor = tagState.cursor + 1;\n    break;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS9sZXhlci5qcz84NGM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHN0YXJ0c1dpdGgsXG4gIGVuZHNXaXRoLFxuICBzdHJpbmdJbmNsdWRlcyxcbiAgYXJyYXlJbmNsdWRlc1xufSBmcm9tICcuL2NvbXBhdC5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGV4ZXIgKHN0ciwgb3B0aW9ucykge1xuICBjb25zdCBzdGF0ZSA9IHtzdHIsIG9wdGlvbnMsIGN1cnNvcjogMCwgdG9rZW5zOiBbXX1cbiAgbGV4KHN0YXRlKVxuICByZXR1cm4gc3RhdGUudG9rZW5zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXggKHN0YXRlKSB7XG4gIGNvbnN0IHtzdHJ9ID0gc3RhdGVcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICB3aGlsZSAoc3RhdGUuY3Vyc29yIDwgbGVuKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGF0ZS5jdXJzb3JcbiAgICBsZXhUZXh0KHN0YXRlKVxuICAgIGlmIChzdGF0ZS5jdXJzb3IgPT09IHN0YXJ0KSB7XG4gICAgICBjb25zdCBpc0NvbW1lbnQgPSBzdGFydHNXaXRoKHN0ciwgJyEtLScsIHN0YXRlLmN1cnNvciArIDEpXG4gICAgICBpZiAoaXNDb21tZW50KSB7XG4gICAgICAgIGxleENvbW1lbnQoc3RhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gbGV4VGFnKHN0YXRlKVxuICAgICAgICBjb25zdCBzYWZlVGFnID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGNvbnN0IHtjaGlsZGxlc3NUYWdzfSA9IHN0YXRlLm9wdGlvbnNcbiAgICAgICAgaWYgKGFycmF5SW5jbHVkZXMoY2hpbGRsZXNzVGFncywgc2FmZVRhZykpIHtcbiAgICAgICAgICBsZXhTa2lwVGFnKHRhZ05hbWUsIHN0YXRlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGFscGhhbnVtZXJpYyA9IC9bQS1aYS16MC05XS9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVGV4dEVuZCAoc3RyLCBpbmRleCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHRleHRFbmQgPSBzdHIuaW5kZXhPZignPCcsIGluZGV4KVxuICAgIGlmICh0ZXh0RW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRleHRFbmRcbiAgICB9XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQodGV4dEVuZCArIDEpXG4gICAgaWYgKGNoYXIgPT09ICcvJyB8fCBjaGFyID09PSAnIScgfHwgYWxwaGFudW1lcmljLnRlc3QoY2hhcikpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5kXG4gICAgfVxuICAgIGluZGV4ID0gdGV4dEVuZCArIDFcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGV4dCAoc3RhdGUpIHtcbiAgY29uc3QgdHlwZSA9ICd0ZXh0J1xuICBjb25zdCB7c3RyLCBjdXJzb3J9ID0gc3RhdGVcbiAgY29uc3QgdGV4dEVuZCA9IGZpbmRUZXh0RW5kKHN0ciwgY3Vyc29yKVxuICBpZiAodGV4dEVuZCA9PT0gLTEpIHtcbiAgICAvLyB0aGVyZSBpcyBvbmx5IHRleHQgbGVmdFxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHIuc2xpY2UoY3Vyc29yKVxuICAgIHN0YXRlLmN1cnNvciA9IHN0ci5sZW5ndGhcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZSwgY29udGVudH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodGV4dEVuZCA9PT0gY3Vyc29yKSByZXR1cm5cblxuICBjb25zdCBjb250ZW50ID0gc3RyLnNsaWNlKGN1cnNvciwgdGV4dEVuZClcbiAgc3RhdGUuY3Vyc29yID0gdGV4dEVuZFxuICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZSwgY29udGVudH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXhDb21tZW50IChzdGF0ZSkge1xuICBzdGF0ZS5jdXJzb3IgKz0gNCAvLyBcIjwhLS1cIi5sZW5ndGhcbiAgY29uc3Qge3N0ciwgY3Vyc29yfSA9IHN0YXRlXG4gIGNvbnN0IGNvbW1lbnRFbmQgPSBzdHIuaW5kZXhPZignLS0+JywgY3Vyc29yKVxuICBjb25zdCB0eXBlID0gJ2NvbW1lbnQnXG4gIGlmIChjb21tZW50RW5kID09PSAtMSkge1xuICAgIC8vIHRoZXJlIGlzIG9ubHkgdGhlIGNvbW1lbnQgbGVmdFxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHIuc2xpY2UoY3Vyc29yKVxuICAgIHN0YXRlLmN1cnNvciA9IHN0ci5sZW5ndGhcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZSwgY29udGVudH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBjb250ZW50ID0gc3RyLnNsaWNlKGN1cnNvciwgY29tbWVudEVuZClcbiAgc3RhdGUuY3Vyc29yID0gY29tbWVudEVuZCArIDMgLy8gXCItLT5cIi5sZW5ndGhcbiAgc3RhdGUudG9rZW5zLnB1c2goe3R5cGUsIGNvbnRlbnR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGFnIChzdGF0ZSkge1xuICBjb25zdCB7c3RyfSA9IHN0YXRlXG4gIHtcbiAgICBjb25zdCBzZWNvbmRDaGFyID0gc3RyLmNoYXJBdChzdGF0ZS5jdXJzb3IgKyAxKVxuICAgIGNvbnN0IGNsb3NlID0gc2Vjb25kQ2hhciA9PT0gJy8nXG4gICAgc3RhdGUudG9rZW5zLnB1c2goe3R5cGU6ICd0YWctc3RhcnQnLCBjbG9zZX0pXG4gICAgc3RhdGUuY3Vyc29yICs9IGNsb3NlID8gMiA6IDFcbiAgfVxuICBjb25zdCB0YWdOYW1lID0gbGV4VGFnTmFtZShzdGF0ZSlcbiAgbGV4VGFnQXR0cmlidXRlcyhzdGF0ZSlcbiAge1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IHN0ci5jaGFyQXQoc3RhdGUuY3Vyc29yKVxuICAgIGNvbnN0IGNsb3NlID0gZmlyc3RDaGFyID09PSAnLydcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZTogJ3RhZy1lbmQnLCBjbG9zZX0pXG4gICAgc3RhdGUuY3Vyc29yICs9IGNsb3NlID8gMiA6IDFcbiAgfVxuICByZXR1cm4gdGFnTmFtZVxufVxuXG4vLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zI3NwZWNpYWwtd2hpdGUtc3BhY2VcbmNvbnN0IHdoaXRlc3BhY2UgPSAvXFxzL1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2hpdGVzcGFjZUNoYXIgKGNoYXIpIHtcbiAgcmV0dXJuIHdoaXRlc3BhY2UudGVzdChjaGFyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGFnTmFtZSAoc3RhdGUpIHtcbiAgY29uc3Qge3N0ciwgY3Vyc29yfSA9IHN0YXRlXG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgbGV0IHN0YXJ0ID0gY3Vyc29yXG4gIHdoaWxlIChzdGFydCA8IGxlbikge1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckF0KHN0YXJ0KVxuICAgIGNvbnN0IGlzVGFnQ2hhciA9ICEoaXNXaGl0ZXNwYWNlQ2hhcihjaGFyKSB8fCBjaGFyID09PSAnLycgfHwgY2hhciA9PT0gJz4nKVxuICAgIGlmIChpc1RhZ0NoYXIpIGJyZWFrXG4gICAgc3RhcnQrK1xuICB9XG5cbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMVxuICB3aGlsZSAoZW5kIDwgbGVuKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQoZW5kKVxuICAgIGNvbnN0IGlzVGFnQ2hhciA9ICEoaXNXaGl0ZXNwYWNlQ2hhcihjaGFyKSB8fCBjaGFyID09PSAnLycgfHwgY2hhciA9PT0gJz4nKVxuICAgIGlmICghaXNUYWdDaGFyKSBicmVha1xuICAgIGVuZCsrXG4gIH1cblxuICBzdGF0ZS5jdXJzb3IgPSBlbmRcbiAgY29uc3QgdGFnTmFtZSA9IHN0ci5zbGljZShzdGFydCwgZW5kKVxuICBzdGF0ZS50b2tlbnMucHVzaCh7dHlwZTogJ3RhZycsIGNvbnRlbnQ6IHRhZ05hbWV9KVxuICByZXR1cm4gdGFnTmFtZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4VGFnQXR0cmlidXRlcyAoc3RhdGUpIHtcbiAgY29uc3Qge3N0ciwgdG9rZW5zfSA9IHN0YXRlXG4gIGxldCBjdXJzb3IgPSBzdGF0ZS5jdXJzb3JcbiAgbGV0IHF1b3RlID0gbnVsbCAvLyBudWxsLCBzaW5nbGUtLCBvciBkb3VibGUtcXVvdGVcbiAgbGV0IHdvcmRCZWdpbiA9IGN1cnNvciAvLyBpbmRleCBvZiB3b3JkIHN0YXJ0XG4gIGNvbnN0IHdvcmRzID0gW10gLy8gXCJrZXlcIiwgXCJrZXk9dmFsdWVcIiwgXCJrZXk9J3ZhbHVlJ1wiLCBldGNcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQoY3Vyc29yKVxuICAgIGlmIChxdW90ZSkge1xuICAgICAgY29uc3QgaXNRdW90ZUVuZCA9IGNoYXIgPT09IHF1b3RlXG4gICAgICBpZiAoaXNRdW90ZUVuZCkge1xuICAgICAgICBxdW90ZSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGlzVGFnRW5kID0gY2hhciA9PT0gJy8nIHx8IGNoYXIgPT09ICc+J1xuICAgIGlmIChpc1RhZ0VuZCkge1xuICAgICAgaWYgKGN1cnNvciAhPT0gd29yZEJlZ2luKSB7XG4gICAgICAgIHdvcmRzLnB1c2goc3RyLnNsaWNlKHdvcmRCZWdpbiwgY3Vyc29yKSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgaXNXb3JkRW5kID0gaXNXaGl0ZXNwYWNlQ2hhcihjaGFyKVxuICAgIGlmIChpc1dvcmRFbmQpIHtcbiAgICAgIGlmIChjdXJzb3IgIT09IHdvcmRCZWdpbikge1xuICAgICAgICB3b3Jkcy5wdXNoKHN0ci5zbGljZSh3b3JkQmVnaW4sIGN1cnNvcikpXG4gICAgICB9XG4gICAgICB3b3JkQmVnaW4gPSBjdXJzb3IgKyAxXG4gICAgICBjdXJzb3IrK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBpc1F1b3RlU3RhcnQgPSBjaGFyID09PSAnXFwnJyB8fCBjaGFyID09PSAnXCInXG4gICAgaWYgKGlzUXVvdGVTdGFydCkge1xuICAgICAgcXVvdGUgPSBjaGFyXG4gICAgICBjdXJzb3IrK1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjdXJzb3IrK1xuICB9XG4gIHN0YXRlLmN1cnNvciA9IGN1cnNvclxuXG4gIGNvbnN0IHdMZW4gPSB3b3Jkcy5sZW5ndGhcbiAgY29uc3QgdHlwZSA9ICdhdHRyaWJ1dGUnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd0xlbjsgaSsrKSB7XG4gICAgY29uc3Qgd29yZCA9IHdvcmRzW2ldXG4gICAgY29uc3QgaXNOb3RQYWlyID0gd29yZC5pbmRleE9mKCc9JykgPT09IC0xXG4gICAgaWYgKGlzTm90UGFpcikge1xuICAgICAgY29uc3Qgc2Vjb25kV29yZCA9IHdvcmRzW2kgKyAxXVxuICAgICAgaWYgKHNlY29uZFdvcmQgJiYgc3RhcnRzV2l0aChzZWNvbmRXb3JkLCAnPScpKSB7XG4gICAgICAgIGlmIChzZWNvbmRXb3JkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb25zdCBuZXdXb3JkID0gd29yZCArIHNlY29uZFdvcmRcbiAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZSwgY29udGVudDogbmV3V29yZH0pXG4gICAgICAgICAgaSArPSAxXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlyZFdvcmQgPSB3b3Jkc1tpICsgMl1cbiAgICAgICAgaSArPSAxXG4gICAgICAgIGlmICh0aGlyZFdvcmQpIHtcbiAgICAgICAgICBjb25zdCBuZXdXb3JkID0gd29yZCArICc9JyArIHRoaXJkV29yZFxuICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlLCBjb250ZW50OiBuZXdXb3JkfSlcbiAgICAgICAgICBpICs9IDFcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRzV2l0aCh3b3JkLCAnPScpKSB7XG4gICAgICBjb25zdCBzZWNvbmRXb3JkID0gd29yZHNbaSArIDFdXG4gICAgICBpZiAoc2Vjb25kV29yZCAmJiAhc3RyaW5nSW5jbHVkZXMoc2Vjb25kV29yZCwgJz0nKSkge1xuICAgICAgICBjb25zdCBuZXdXb3JkID0gd29yZCArIHNlY29uZFdvcmRcbiAgICAgICAgdG9rZW5zLnB1c2goe3R5cGUsIGNvbnRlbnQ6IG5ld1dvcmR9KVxuICAgICAgICBpICs9IDFcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3V29yZCA9IHdvcmQuc2xpY2UoMCwgLTEpXG4gICAgICB0b2tlbnMucHVzaCh7dHlwZSwgY29udGVudDogbmV3V29yZH0pXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKHt0eXBlLCBjb250ZW50OiB3b3JkfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGV4U2tpcFRhZyAodGFnTmFtZSwgc3RhdGUpIHtcbiAgY29uc3Qge3N0ciwgY3Vyc29yLCB0b2tlbnN9ID0gc3RhdGVcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICBsZXQgaW5kZXggPSBjdXJzb3JcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB7XG4gICAgY29uc3QgbmV4dFRhZyA9IHN0ci5pbmRleE9mKCc8LycsIGluZGV4KVxuICAgIGlmIChuZXh0VGFnID09PSAtMSkge1xuICAgICAgbGV4VGV4dChzdGF0ZSlcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgdGFnU3RhdGUgPSB7c3RyLCBjdXJzb3I6IG5leHRUYWcgKyAyLCB0b2tlbnM6IFtdfVxuICAgIGNvbnN0IG5hbWUgPSBsZXhUYWdOYW1lKHRhZ1N0YXRlKVxuICAgIGNvbnN0IHNhZmVUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHNhZmVUYWdOYW1lICE9PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGluZGV4ID0gdGFnU3RhdGUuY3Vyc29yXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBzdHIuc2xpY2UoY3Vyc29yLCBuZXh0VGFnKVxuICAgIHRva2Vucy5wdXNoKHt0eXBlOiAndGV4dCcsIGNvbnRlbnR9KVxuICAgIGNvbnN0IG9wZW5UYWcgPSB7dHlwZTogJ3RhZy1zdGFydCcsIGNsb3NlOiB0cnVlfVxuICAgIGNvbnN0IGNsb3NlVGFnID0ge3R5cGU6ICd0YWctZW5kJywgY2xvc2U6IGZhbHNlfVxuICAgIGxleFRhZ0F0dHJpYnV0ZXModGFnU3RhdGUpXG4gICAgdG9rZW5zLnB1c2gob3BlblRhZywgLi4udGFnU3RhdGUudG9rZW5zLCBjbG9zZVRhZylcbiAgICBzdGF0ZS5jdXJzb3IgPSB0YWdTdGF0ZS5jdXJzb3IgKyAxXG4gICAgYnJlYWtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvaGltYWxheWEvbGV4ZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBT0E7QUFNQTtBQXVCQTtBQWNBO0FBbUJBO0FBa0JBO0FBcUJBO0FBSUE7QUF5QkE7QUF5RkE7QUFDQTtBQW5PQTtBQUNBOzs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!*************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/parser.js ***!
  \*************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.parse = parse;\n\nvar _compat = __webpack_require__(/*! ./compat.js */ 4);\n\nfunction parser(tokens, options) {\n  var root = { tagName: null, children: [] };\n  var state = { tokens: tokens, options: options, cursor: 0, stack: [root] };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n      if (parentTagName === tagName) {\n        break;\n      }\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n      currentIndex--;\n    }\n  }\n  return false;\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n    if (token.close) {\n      var item = void 0;\n      while (item = stack.pop()) {\n        if (tagName === item.tagName) break;\n      }\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n      break;\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          stack = stack.slice(0, currentIndex);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    nodes.push({\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children\n    });\n\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n    if (hasChildren) {\n      stack.push({ tagName: tagName, children: children });\n      var innerState = { tokens: tokens, options: options, cursor: cursor, stack: stack };\n      parse(innerState);\n      cursor = innerState.cursor;\n    }\n  }\n  state.cursor = cursor;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS9wYXJzZXIuanM/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2FycmF5SW5jbHVkZXN9IGZyb20gJy4vY29tcGF0LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZXIgKHRva2Vucywgb3B0aW9ucykge1xuICBjb25zdCByb290ID0ge3RhZ05hbWU6IG51bGwsIGNoaWxkcmVuOiBbXX1cbiAgY29uc3Qgc3RhdGUgPSB7dG9rZW5zLCBvcHRpb25zLCBjdXJzb3I6IDAsIHN0YWNrOiBbcm9vdF19XG4gIHBhcnNlKHN0YXRlKVxuICByZXR1cm4gcm9vdC5jaGlsZHJlblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzVGVybWluYWxQYXJlbnQgKHRhZ05hbWUsIHN0YWNrLCB0ZXJtaW5hbHMpIHtcbiAgY29uc3QgdGFnUGFyZW50cyA9IHRlcm1pbmFsc1t0YWdOYW1lXVxuICBpZiAodGFnUGFyZW50cykge1xuICAgIGxldCBjdXJyZW50SW5kZXggPSBzdGFjay5sZW5ndGggLSAxXG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gc3RhY2tbY3VycmVudEluZGV4XS50YWdOYW1lXG4gICAgICBpZiAocGFyZW50VGFnTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGFycmF5SW5jbHVkZXModGFnUGFyZW50cywgcGFyZW50VGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRJbmRleC0tXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UgKHN0YXRlKSB7XG4gIGNvbnN0IHt0b2tlbnMsIG9wdGlvbnN9ID0gc3RhdGVcbiAgbGV0IHtzdGFja30gPSBzdGF0ZVxuICBsZXQgbm9kZXMgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jaGlsZHJlblxuICBjb25zdCBsZW4gPSB0b2tlbnMubGVuZ3RoXG4gIGxldCB7Y3Vyc29yfSA9IHN0YXRlXG4gIHdoaWxlIChjdXJzb3IgPCBsZW4pIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tjdXJzb3JdXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0YWctc3RhcnQnKSB7XG4gICAgICBub2Rlcy5wdXNoKHRva2VuKVxuICAgICAgY3Vyc29yKytcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgdGFnVG9rZW4gPSB0b2tlbnNbKytjdXJzb3JdXG4gICAgY3Vyc29yKytcbiAgICBjb25zdCB0YWdOYW1lID0gdGFnVG9rZW4uY29udGVudC50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKHRva2VuLmNsb3NlKSB7XG4gICAgICBsZXQgaXRlbVxuICAgICAgd2hpbGUgKChpdGVtID0gc3RhY2sucG9wKCkpKSB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSBpdGVtLnRhZ05hbWUpIGJyZWFrXG4gICAgICB9XG4gICAgICB3aGlsZSAoY3Vyc29yIDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IGVuZFRva2VuID0gdG9rZW5zW2N1cnNvcl1cbiAgICAgICAgaWYgKGVuZFRva2VuLnR5cGUgIT09ICd0YWctZW5kJykgYnJlYWtcbiAgICAgICAgY3Vyc29yKytcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgaXNDbG9zaW5nVGFnID0gYXJyYXlJbmNsdWRlcyhvcHRpb25zLmNsb3NpbmdUYWdzLCB0YWdOYW1lKVxuICAgIGxldCBzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSA9IGlzQ2xvc2luZ1RhZ1xuICAgIGlmIChzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSkge1xuICAgICAgY29uc3QgeyBjbG9zaW5nVGFnQW5jZXN0b3JCcmVha2VyczogdGVybWluYWxzIH0gPSBvcHRpb25zXG4gICAgICBzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSA9ICFoYXNUZXJtaW5hbFBhcmVudCh0YWdOYW1lLCBzdGFjaywgdGVybWluYWxzKVxuICAgIH1cblxuICAgIGlmIChzaG91bGRSZXdpbmRUb0F1dG9DbG9zZSkge1xuICAgICAgLy8gcmV3aW5kIHRoZSBzdGFjayB0byBqdXN0IGFib3ZlIHRoZSBwcmV2aW91c1xuICAgICAgLy8gY2xvc2luZyB0YWcgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHN0YWNrLmxlbmd0aCAtIDFcbiAgICAgIHdoaWxlIChjdXJyZW50SW5kZXggPiAwKSB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSBzdGFja1tjdXJyZW50SW5kZXhdLnRhZ05hbWUpIHtcbiAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIGN1cnJlbnRJbmRleClcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gY3VycmVudEluZGV4IC0gMVxuICAgICAgICAgIG5vZGVzID0gc3RhY2tbcHJldmlvdXNJbmRleF0uY2hpbGRyZW5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleCAtIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYXR0cmlidXRlcyA9IFtdXG4gICAgbGV0IGF0dHJUb2tlblxuICAgIHdoaWxlIChjdXJzb3IgPCBsZW4pIHtcbiAgICAgIGF0dHJUb2tlbiA9IHRva2Vuc1tjdXJzb3JdXG4gICAgICBpZiAoYXR0clRva2VuLnR5cGUgPT09ICd0YWctZW5kJykgYnJlYWtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyVG9rZW4uY29udGVudClcbiAgICAgIGN1cnNvcisrXG4gICAgfVxuXG4gICAgY3Vyc29yKytcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICB0YWdOYW1lOiB0YWdUb2tlbi5jb250ZW50LFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcblxuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gIShhdHRyVG9rZW4uY2xvc2UgfHwgYXJyYXlJbmNsdWRlcyhvcHRpb25zLnZvaWRUYWdzLCB0YWdOYW1lKSlcbiAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgIHN0YWNrLnB1c2goe3RhZ05hbWUsIGNoaWxkcmVufSlcbiAgICAgIGNvbnN0IGlubmVyU3RhdGUgPSB7dG9rZW5zLCBvcHRpb25zLCBjdXJzb3IsIHN0YWNrfVxuICAgICAgcGFyc2UoaW5uZXJTdGF0ZSlcbiAgICAgIGN1cnNvciA9IGlubmVyU3RhdGUuY3Vyc29yXG4gICAgfVxuICB9XG4gIHN0YXRlLmN1cnNvciA9IGN1cnNvclxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvaGltYWxheWEvcGFyc2VyLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBO0FBT0E7QUFrQkE7QUFDQTtBQTVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUpBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!***********************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/himalaya/tags.js ***!
  \***********************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Tags which contain arbitary non-parsed content\n  For example: <script> JavaScript should not be parsed\n*/\nvar childlessTags = exports.childlessTags = ['style', 'script', 'template'];\n\n/*\n  Tags which auto-close because they cannot be nested\n  For example: <p>Outer<p>Inner is <p>Outer</p><p>Inner</p>\n*/\nvar closingTags = exports.closingTags = ['html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option', 'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'];\n\n/*\n  Closing tags which have ancestor tags which\n  may exist within them which prevent the\n  closing tag from auto-closing.\n  For example: in <li><ul><li></ul></li>,\n  the top-level <li> should not auto-close.\n*/\nvar closingTagAncestorBreakers = exports.closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n\n  /*\n    Tags which do not need the closing tag\n    For example: <img> does not need </img>\n  */\n};var voidTags = exports.voidTags = ['!doctype', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9oaW1hbGF5YS90YWdzLmpzP2U5MDkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGFncyB3aGljaCBjb250YWluIGFyYml0YXJ5IG5vbi1wYXJzZWQgY29udGVudFxuICBGb3IgZXhhbXBsZTogPHNjcmlwdD4gSmF2YVNjcmlwdCBzaG91bGQgbm90IGJlIHBhcnNlZFxuKi9cbmV4cG9ydCBjb25zdCBjaGlsZGxlc3NUYWdzID0gWydzdHlsZScsICdzY3JpcHQnLCAndGVtcGxhdGUnXVxuXG4vKlxuICBUYWdzIHdoaWNoIGF1dG8tY2xvc2UgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBuZXN0ZWRcbiAgRm9yIGV4YW1wbGU6IDxwPk91dGVyPHA+SW5uZXIgaXMgPHA+T3V0ZXI8L3A+PHA+SW5uZXI8L3A+XG4qL1xuZXhwb3J0IGNvbnN0IGNsb3NpbmdUYWdzID0gW1xuICAnaHRtbCcsICdoZWFkJywgJ2JvZHknLCAncCcsICdkdCcsICdkZCcsICdsaScsICdvcHRpb24nLFxuICAndGhlYWQnLCAndGgnLCAndGJvZHknLCAndHInLCAndGQnLCAndGZvb3QnLCAnY29sZ3JvdXAnXG5dXG5cbi8qXG4gIENsb3NpbmcgdGFncyB3aGljaCBoYXZlIGFuY2VzdG9yIHRhZ3Mgd2hpY2hcbiAgbWF5IGV4aXN0IHdpdGhpbiB0aGVtIHdoaWNoIHByZXZlbnQgdGhlXG4gIGNsb3NpbmcgdGFnIGZyb20gYXV0by1jbG9zaW5nLlxuICBGb3IgZXhhbXBsZTogaW4gPGxpPjx1bD48bGk+PC91bD48L2xpPixcbiAgdGhlIHRvcC1sZXZlbCA8bGk+IHNob3VsZCBub3QgYXV0by1jbG9zZS5cbiovXG5leHBvcnQgY29uc3QgY2xvc2luZ1RhZ0FuY2VzdG9yQnJlYWtlcnMgPSB7XG4gIGxpOiBbJ3VsJywgJ29sJywgJ21lbnUnXSxcbiAgZHQ6IFsnZGwnXSxcbiAgZGQ6IFsnZGwnXSxcbiAgdGJvZHk6IFsndGFibGUnXSxcbiAgdGhlYWQ6IFsndGFibGUnXSxcbiAgdGZvb3Q6IFsndGFibGUnXSxcbiAgdHI6IFsndGFibGUnXSxcbiAgdGQ6IFsndGFibGUnXVxufVxuXG4vKlxuICBUYWdzIHdoaWNoIGRvIG5vdCBuZWVkIHRoZSBjbG9zaW5nIHRhZ1xuICBGb3IgZXhhbXBsZTogPGltZz4gZG9lcyBub3QgbmVlZCA8L2ltZz5cbiovXG5leHBvcnQgY29uc3Qgdm9pZFRhZ3MgPSBbXG4gICchZG9jdHlwZScsICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2NvbW1hbmQnLFxuICAnZW1iZWQnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2tleWdlbicsICdsaW5rJyxcbiAgJ21ldGEnLCAncGFyYW0nLCAnc291cmNlJywgJ3RyYWNrJywgJ3dicidcbl1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2hpbWFsYXlhL3RhZ3MuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBWEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/*!*****************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockForeach.js ***!
  \*****************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockForeach;\n\nvar _tkoUtils = __webpack_require__(/*! ../tko/tko.utils.js */ 1);\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 2);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 3);\n\nfunction blockForeach(parent, tpl, ctx, level) {\n\tif (!(tpl && tpl.children && tpl.children.length > 0)) {\n\t\tconsole.log(\"empty foreach\", tpl);\n\t}\n\tif (tpl.attrs && tpl.attrs['items'] && tpl.attrs['items'].call) {\n\n\t\tvar items = tpl.attrs['items'];\n\t\tvar ctx0 = { subctx: [], tpl: tpl, ctx: ctx };\n\t\tctx0.dispose = function () {\n\t\t\t(0, _tkoUtils.arrayForEach)(ctx0.subctx, function (e) {\n\t\t\t\tif (e.dispose) e.dispose();\n\t\t\t});\n\t\t\tctx0.subctx = [];\n\t\t};\n\t\tctx.subscribers.push(ctx0);\n\n\t\tvar stamp = (0, _renderCtx.createStamp)(parent, 'foreach');\n\t\tif (level == 0) ctx.rootNodes.push(stamp[1]);\n\n\t\tvar renderItems = function renderItems(items2) {\n\n\t\t\tif (items2.length == 0) {\n\t\t\t\t//remove all\n\t\t\t\tconsole.log('removeAll');\n\t\t\t\t(0, _tkoUtils.arrayForEach)(ctx0.subctx, function (e) {\n\t\t\t\t\te.dispose();\n\t\t\t\t});\n\t\t\t\tctx0.subctx = [];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar eqMin = arrEq(ctx0.subctx, items2);\n\n\t\t\tif (eqMin == ctx0.subctx.length) {\n\t\t\t\t//only Append\n\t\t\t\tconsole.log('onlyAppend', eqMin);\n\t\t\t\tfor (var i = eqMin; i < items2.length; i++) {\n\t\t\t\t\tappendItem(items2[i], stamp, ctx0);\n\t\t\t\t}return;\n\t\t\t}\n\t\t\tif (ctx0.subctx.length > items2.length && eqMin == items2.length) {\n\t\t\t\t//only remove\n\t\t\t\tconsole.log('onlyRemove', eqMin, ctx0.subctx.length, '<', items2.length);\n\t\t\t\tfor (var i = ctx0.subctx.length - 1; i >= items2.length; i--) {\n\t\t\t\t\tctx0.subctx[i].dispose();\n\t\t\t\t}ctx0.subctx = ctx0.subctx.slice(0, items2.length);\n\t\t\t\tconsole.log('onlyRemove', eqMin, ctx0.subctx.length, '=', items2.length);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Map && Map.call) {\n\t\t\t\t//merge contenxt in Map\n\t\t\t\tmergeItemsMap(ctx0, items2, eqMin, stamp[0], stamp[1], new Map());\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t(0, _tkoUtils.arrayForEach)(ctx0.subctx, function (e) {\n\t\t\t\te.dispose();\n\t\t\t});\n\t\t\tctx0.subctx = [];\n\t\t\tfor (var i = 0; i < items2.length; i++) {\n\t\t\t\tappendItem(items2[i], stamp, ctx0);\n\t\t\t}\n\t\t};\n\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = items(ctx.model, ctx);\n\t\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\trenderItems(val2);\n\t\t\t});\n\t\t}, this);\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n};\n\nfunction arrEq(subctx, items2, start) {\n\tstart = start || 0;\n\tvar max = subctx.length < items2.length ? subctx.length : items2.length;\n\tfor (var i = 0; i < max; i++) {\n\t\tif (subctx[i].model != items2[i]) return i;\n\t}\n\treturn max;\n}\n\nfunction appendItem(m2, parent, ctx0) {\n\tvar ctx2 = (0, _renderCtx.createCtx)(m2, ctx0.ctx, null);\n\t(0, _renderCtx.renderCtx)(parent, ctx0.tpl.children, ctx2, 0);\n\tctx0.subctx.push(ctx2);\n\treturn ctx2;\n}\n\nfunction mergeItemsMap(ctx0, items2, eqMin, parent, stamp, oldMap) {\n\tvar old = ctx0.subctx;\n\t//index old\n\tfor (var i = eqMin; i < ctx0.subctx.length; i++) {\n\t\tvar ctx2 = ctx0.subctx[i];\n\t\tctx2._oldIndex = i;\n\t\tctx2._newIndex = -1;\n\t\toldMap.set(ctx2.model, ctx2);\n\t}\n\t//index new\n\tvar reusedCtx = [];\n\tfor (var i = eqMin; i < items2.length; i++) {\n\t\tvar ctx2 = oldMap.get(items2[i]);\n\t\tif (ctx2) {\n\t\t\tctx2._newIndex = i;\n\t\t\treusedCtx[i] = ctx2;\n\t\t}\n\t}\n\n\tctx0.subctx = ctx0.subctx.slice(0, eqMin);\n\tvar aktPosOld = nextOldPos(old, eqMin);\n\tfor (var i = eqMin; i < items2.length; i++) {\n\t\tvar m2 = items2[i];\n\t\tif (aktPosOld < old.length && old[aktPosOld].model === m2) {\n\t\t\t//the same models, all is ok\n\t\t\tctx0.subctx.push(old[aktPosOld]);\n\t\t\told[aktPosOld] = null;\n\t\t\taktPosOld = nextOldPos(old, aktPosOld + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tvar beforeNode = aktPosOld < old.length ? old[aktPosOld].rootNodes[0] : stamp;\n\t\tvar ctx2 = reusedCtx[i];\n\t\tif (ctx2) {\n\t\t\t//reuse\n\t\t\t(0, _tkoUtils.arrayForEach)(ctx2.rootNodes, function (n) {\n\t\t\t\tparent.insertBefore(n, beforeNode);\n\t\t\t});\n\t\t\tctx0.subctx.push(ctx2);\n\t\t\told[ctx2._oldIndex] = null;\n\t\t} else {\n\t\t\t//create new\n\t\t\tctx2 = appendItem(m2, beforeNode ? [parent, beforeNode] : parent, ctx0);\n\t\t\tctx0.subctx.push(ctx2);\n\t\t}\n\t}\n}\n\nfunction nextOldPos(old, aktPosOld) {\n\twhile (aktPosOld < old.length) {\n\t\tvar v = old[aktPosOld];\n\t\tif (v != null) {\n\t\t\tif (v._newIndex >= 0) return aktPosOld;\n\t\t\tv.dispose();\n\t\t\told[aktPosOld] = null;\n\t\t}\n\t\taktPosOld++;\n\t}\n\treturn aktPosOld;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tGb3JlYWNoLmpzPzNhODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXJyYXlGb3JFYWNoIH0gIGZyb20gJy4uL3Rrby90a28udXRpbHMuanMnO1xyXG5pbXBvcnQgeyB1bndyYXAsIGRlcGVuZGVuY3lEZXRlY3Rpb24gfSAgZnJvbSAnLi4vdGtvL3Rrby5vYnNlcnZhYmxlLmpzJztcclxuaW1wb3J0IHsgY29tcHV0ZWQgfSAgZnJvbSAnLi4vdGtvL3Rrby5jb21wdXRlZC5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckN0eCwgY3JlYXRlQ3R4LCBjcmVhdGVTdGFtcCB9ICBmcm9tICcuLi9yZW5kZXJDdHguanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvY2tGb3JlYWNoKHBhcmVudCwgdHBsLCBjdHgsIGxldmVsKXtcclxuXHRpZighKHRwbCAmJiB0cGwuY2hpbGRyZW4gJiYgdHBsLmNoaWxkcmVuLmxlbmd0aD4wKSl7XHJcblx0XHRjb25zb2xlLmxvZyhcImVtcHR5IGZvcmVhY2hcIiAsdHBsKTtcclxuXHR9XHJcblx0aWYodHBsLmF0dHJzICYmIHRwbC5hdHRyc1snaXRlbXMnXSAmJiB0cGwuYXR0cnNbJ2l0ZW1zJ10uY2FsbCl7XHJcblxyXG5cdFx0dmFyIGl0ZW1zID0gdHBsLmF0dHJzWydpdGVtcyddO1xyXG5cdFx0dmFyIGN0eDAgPSB7IHN1YmN0eCA6IFtdLCB0cGwgOiB0cGwsIGN0eDogY3R4IH07XHJcblx0XHRjdHgwLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0YXJyYXlGb3JFYWNoKGN0eDAuc3ViY3R4LCBmdW5jdGlvbihlKSB7IGlmKGUuZGlzcG9zZSkgZS5kaXNwb3NlKCk7IH0gKTtcclxuXHRcdFx0Y3R4MC5zdWJjdHggPSBbXTtcclxuXHRcdH07XHJcblx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChjdHgwKTtcclxuXHJcblx0XHR2YXIgc3RhbXAgPVx0Y3JlYXRlU3RhbXAocGFyZW50LCAnZm9yZWFjaCcpO1xyXG5cdFx0aWYobGV2ZWw9PTApIGN0eC5yb290Tm9kZXMucHVzaChzdGFtcFsxXSk7XHJcblxyXG5cdFx0dmFyIHJlbmRlckl0ZW1zID0gZnVuY3Rpb24oaXRlbXMyKXtcclxuXHJcblx0XHRcdGlmKGl0ZW1zMi5sZW5ndGg9PTApe1xyXG5cdFx0XHRcdC8vcmVtb3ZlIGFsbFxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdyZW1vdmVBbGwnKTtcclxuXHRcdFx0XHRhcnJheUZvckVhY2goY3R4MC5zdWJjdHgsIGZ1bmN0aW9uKGUpIHsgZS5kaXNwb3NlKCk7IH0pO1xyXG5cdFx0XHRcdGN0eDAuc3ViY3R4ID0gW107XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZXFNaW4gPSBhcnJFcShjdHgwLnN1YmN0eCwgaXRlbXMyKTtcclxuXHJcblx0XHRcdGlmKGVxTWluPT1jdHgwLnN1YmN0eC5sZW5ndGgpe1xyXG5cdFx0XHRcdC8vb25seSBBcHBlbmRcclxuXHRcdFx0XHRjb25zb2xlLmxvZygnb25seUFwcGVuZCcsIGVxTWluKTtcclxuXHRcdFx0XHRmb3IodmFyIGk9ZXFNaW47IGk8aXRlbXMyLmxlbmd0aDsgaSsrKSBhcHBlbmRJdGVtKGl0ZW1zMltpXSwgc3RhbXAsIGN0eDApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihjdHgwLnN1YmN0eC5sZW5ndGg+aXRlbXMyLmxlbmd0aCAmJiBlcU1pbj09aXRlbXMyLmxlbmd0aCl7XHJcblx0XHRcdFx0Ly9vbmx5IHJlbW92ZVxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdvbmx5UmVtb3ZlJywgZXFNaW4sIGN0eDAuc3ViY3R4Lmxlbmd0aCwgJzwnLCBpdGVtczIubGVuZ3RoKTtcclxuXHRcdFx0XHRmb3IodmFyIGk9Y3R4MC5zdWJjdHgubGVuZ3RoLTE7IGk+PWl0ZW1zMi5sZW5ndGg7IGktLSkgY3R4MC5zdWJjdHhbaV0uZGlzcG9zZSgpO1xyXG5cdFx0XHRcdGN0eDAuc3ViY3R4ID0gY3R4MC5zdWJjdHguc2xpY2UoMCwgaXRlbXMyLmxlbmd0aCk7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coJ29ubHlSZW1vdmUnLCBlcU1pbiwgY3R4MC5zdWJjdHgubGVuZ3RoLCAnPScsIGl0ZW1zMi5sZW5ndGgpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoTWFwICYmIE1hcC5jYWxsKXtcclxuXHRcdFx0XHQvL21lcmdlIGNvbnRlbnh0IGluIE1hcFxyXG5cdFx0XHRcdG1lcmdlSXRlbXNNYXAoY3R4MCwgaXRlbXMyLCBlcU1pbiwgc3RhbXBbMF0sIHN0YW1wWzFdLCBuZXcgTWFwKCkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJyYXlGb3JFYWNoKGN0eDAuc3ViY3R4LCBmdW5jdGlvbihlKSB7IGUuZGlzcG9zZSgpOyB9KTtcclxuXHRcdFx0Y3R4MC5zdWJjdHggPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8aXRlbXMyLmxlbmd0aDsgaSsrKSBhcHBlbmRJdGVtKGl0ZW1zMltpXSwgc3RhbXAsIGN0eDApO1xyXG5cdFx0fTtcclxuXHRcdFxyXG5cdFx0dmFyIGt2ID0gY29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR2YXIgdmFsMiA9IGl0ZW1zKGN0eC5tb2RlbCwgY3R4KTtcclxuXHRcdFx0XHR2YWwyID0gdW53cmFwKHZhbDIpO1xyXG5cdFx0XHRcdGRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRyZW5kZXJJdGVtcyh2YWwyKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0a3YoKTtcclxuXHRcdGlmKGt2LmdldERlcGVuZGVuY2llc0NvdW50KCk+MCl7XHJcblx0XHRcdGN0eC5zdWJzY3JpYmVycy5wdXNoKGt2KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGt2LmRpc3Bvc2UoKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhcnJFcShzdWJjdHgsIGl0ZW1zMiwgc3RhcnQpe1xyXG5cdHN0YXJ0ID0gc3RhcnQgfHwgMDtcclxuXHR2YXIgbWF4ID0gc3ViY3R4Lmxlbmd0aDxpdGVtczIubGVuZ3RoID8gc3ViY3R4Lmxlbmd0aCA6IGl0ZW1zMi5sZW5ndGg7XHJcblx0Zm9yKHZhciBpID0gMDsgaTxtYXg7IGkrKyl7XHJcblx0XHRpZihzdWJjdHhbaV0ubW9kZWwhPWl0ZW1zMltpXSkgcmV0dXJuIGk7XHJcblx0fVxyXG5cdHJldHVybiBtYXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGVuZEl0ZW0obTIsIHBhcmVudCwgY3R4MCl7XHJcblx0dmFyIGN0eDIgPSBjcmVhdGVDdHgobTIsIGN0eDAuY3R4LCBudWxsKTtcclxuXHRyZW5kZXJDdHgocGFyZW50LCBjdHgwLnRwbC5jaGlsZHJlbiwgY3R4MiwgMCk7XHJcblx0Y3R4MC5zdWJjdHgucHVzaChjdHgyKTtcclxuXHRyZXR1cm4gY3R4MjtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VJdGVtc01hcChjdHgwLCBpdGVtczIsIGVxTWluLCBwYXJlbnQsIHN0YW1wLCBvbGRNYXApe1xyXG5cdHZhciBvbGQgPSBjdHgwLnN1YmN0eDtcclxuXHQvL2luZGV4IG9sZFxyXG5cdGZvcih2YXIgaT1lcU1pbjsgaTxjdHgwLnN1YmN0eC5sZW5ndGg7IGkrKyl7XHJcblx0XHR2YXIgY3R4MiA9IGN0eDAuc3ViY3R4W2ldO1xyXG5cdFx0Y3R4Mi5fb2xkSW5kZXggPSBpO1xyXG5cdFx0Y3R4Mi5fbmV3SW5kZXggPSAtMTtcclxuXHRcdG9sZE1hcC5zZXQoY3R4Mi5tb2RlbCwgY3R4Mik7XHJcblx0fVxyXG5cdC8vaW5kZXggbmV3XHJcblx0dmFyIHJldXNlZEN0eCA9IFtdO1xyXG5cdGZvcih2YXIgaT1lcU1pbjsgaTxpdGVtczIubGVuZ3RoOyBpKyspe1xyXG5cdFx0dmFyIGN0eDIgPSBvbGRNYXAuZ2V0KGl0ZW1zMltpXSk7XHJcblx0XHRpZihjdHgyKSB7IFxyXG5cdFx0XHRjdHgyLl9uZXdJbmRleCA9IGk7IFxyXG5cdFx0XHRyZXVzZWRDdHhbaV0gPSBjdHgyOyBcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGN0eDAuc3ViY3R4ID0gY3R4MC5zdWJjdHguc2xpY2UoMCwgZXFNaW4pO1xyXG5cdHZhciBha3RQb3NPbGQgPSBuZXh0T2xkUG9zKG9sZCwgZXFNaW4pO1xyXG5cdGZvcih2YXIgaT1lcU1pbjsgaTxpdGVtczIubGVuZ3RoOyBpKyspe1xyXG5cdFx0dmFyIG0yID0gaXRlbXMyW2ldO1xyXG5cdFx0aWYoYWt0UG9zT2xkPG9sZC5sZW5ndGggJiYgb2xkW2FrdFBvc09sZF0ubW9kZWw9PT1tMikge1xyXG5cdFx0XHQvL3RoZSBzYW1lIG1vZGVscywgYWxsIGlzIG9rXHJcblx0XHRcdGN0eDAuc3ViY3R4LnB1c2gob2xkW2FrdFBvc09sZF0pO1xyXG5cdFx0XHRvbGRbYWt0UG9zT2xkXSA9IG51bGw7XHJcblx0XHRcdGFrdFBvc09sZCA9IG5leHRPbGRQb3Mob2xkLCBha3RQb3NPbGQrMSk7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGJlZm9yZU5vZGUgPSBha3RQb3NPbGQ8b2xkLmxlbmd0aCA/IG9sZFtha3RQb3NPbGRdLnJvb3ROb2Rlc1swXSA6IHN0YW1wO1xyXG5cdFx0dmFyIGN0eDIgPSByZXVzZWRDdHhbaV07XHJcblx0XHRpZihjdHgyKXtcclxuXHRcdFx0Ly9yZXVzZVxyXG5cdFx0XHRhcnJheUZvckVhY2goY3R4Mi5yb290Tm9kZXMsIGZ1bmN0aW9uKG4pIHsgXHJcblx0XHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZShuLGJlZm9yZU5vZGUpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y3R4MC5zdWJjdHgucHVzaChjdHgyKTtcclxuXHRcdFx0b2xkW2N0eDIuX29sZEluZGV4XSA9IG51bGw7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvL2NyZWF0ZSBuZXdcclxuXHRcdFx0Y3R4MiA9IGFwcGVuZEl0ZW0obTIsIGJlZm9yZU5vZGUgPyBbIHBhcmVudCwgYmVmb3JlTm9kZV0gOiBwYXJlbnQgLCBjdHgwKTtcclxuXHRcdFx0Y3R4MC5zdWJjdHgucHVzaChjdHgyKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRPbGRQb3Mob2xkLCBha3RQb3NPbGQpe1xyXG5cdHdoaWxlKGFrdFBvc09sZDxvbGQubGVuZ3RoKSB7XHJcblx0XHR2YXIgdiA9IG9sZFtha3RQb3NPbGRdO1xyXG5cdFx0aWYodiE9bnVsbCl7XHJcblx0XHRcdGlmKHYuX25ld0luZGV4Pj0wKSByZXR1cm4gYWt0UG9zT2xkO1xyXG5cdFx0XHR2LmRpc3Bvc2UoKTtcclxuXHRcdFx0b2xkW2FrdFBvc09sZF0gPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0YWt0UG9zT2xkKys7XHJcblx0fVxyXG5cdHJldHVybiBha3RQb3NPbGQ7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tGb3JlYWNoLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUtBO0FBQ0E7QUFOQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockIf.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockIf;\n\nvar _tkoUtils = __webpack_require__(/*! ../tko/tko.utils.js */ 1);\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 2);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 3);\n\nfunction blockIf(parent, tpl, ctx, level) {\n\n\tif (tpl.children && tpl.children.length > 0 && tpl.attrs && tpl.attrs['value'] && tpl.attrs['value'].call) {\n\n\t\tvar value = tpl.attrs['value'];\n\t\tvar stamp = (0, _renderCtx.createStamp)(parent, 'if');\n\t\tif (level == 0) ctx.rootNodes.push(stamp[1]);\n\n\t\tvar ctx0 = (0, _renderCtx.duplicateCtx)(ctx);\n\t\tctx.subscribers.push(ctx0);\n\n\t\tvar lastVal = false;\n\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = value(ctx.model, ctx);\n\t\t\tval2 = (0, _tkoObservable.unwrap)(val2) ? true : false;\n\t\t\tif (val2 == lastVal) return;\n\n\t\t\tlastVal = val2;\n\t\t\t//remove children tpl\n\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\tctx0.dispose();\n\t\t\t});\n\n\t\t\tif (val2) {\n\t\t\t\t//render children tpl\n\t\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\t\t(0, _renderCtx.renderCtx)(stamp, tpl.children, ctx0, 0);\n\t\t\t\t});\n\t\t\t} else {}\n\t\t}, this);\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tJZi5qcz9iYTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycmF5Rm9yRWFjaCB9ICBmcm9tICcuLi90a28vdGtvLnV0aWxzLmpzJztcclxuaW1wb3J0IHsgdW53cmFwLCBkZXBlbmRlbmN5RGV0ZWN0aW9uIH0gIGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVkIH0gIGZyb20gJy4uL3Rrby90a28uY29tcHV0ZWQuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJDdHgsIGNyZWF0ZVN0YW1wLCBkdXBsaWNhdGVDdHggfSAgZnJvbSAnLi4vcmVuZGVyQ3R4LmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsb2NrSWYocGFyZW50LCB0cGwsIGN0eCwgbGV2ZWwpe1xyXG5cclxuXHRpZih0cGwuY2hpbGRyZW4gJiYgdHBsLmNoaWxkcmVuLmxlbmd0aD4wICYmIHRwbC5hdHRycyAmJiB0cGwuYXR0cnNbJ3ZhbHVlJ10gJiYgdHBsLmF0dHJzWyd2YWx1ZSddLmNhbGwpe1xyXG5cdFx0XHJcblx0XHR2YXIgdmFsdWUgPSB0cGwuYXR0cnNbJ3ZhbHVlJ107XHJcblx0XHR2YXIgc3RhbXAgPVx0Y3JlYXRlU3RhbXAocGFyZW50LCAnaWYnKTtcclxuXHRcdGlmKGxldmVsPT0wKSBjdHgucm9vdE5vZGVzLnB1c2goc3RhbXBbMV0pO1xyXG5cclxuXHRcdHZhciBjdHgwID0gZHVwbGljYXRlQ3R4KGN0eCk7XHJcblx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChjdHgwKTtcclxuXHJcblx0XHR2YXIgbGFzdFZhbCA9IGZhbHNlO1xyXG5cclxuXHRcdHZhciBrdiA9IGNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciB2YWwyID0gdmFsdWUoY3R4Lm1vZGVsLCBjdHgpO1xyXG5cdFx0XHR2YWwyID0gdW53cmFwKHZhbDIpID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0XHRpZih2YWwyPT1sYXN0VmFsKSByZXR1cm47XHJcblxyXG5cdFx0XHRsYXN0VmFsID0gdmFsMjtcclxuXHRcdFx0Ly9yZW1vdmUgY2hpbGRyZW4gdHBsXHJcblx0XHRcdGRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0Y3R4MC5kaXNwb3NlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYodmFsMil7XHJcblx0XHRcdFx0Ly9yZW5kZXIgY2hpbGRyZW4gdHBsXHJcblx0XHRcdFx0ZGVwZW5kZW5jeURldGVjdGlvbi5pZ25vcmUoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRcdHJlbmRlckN0eChzdGFtcCwgdHBsLmNoaWxkcmVuLCBjdHgwLCAwKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRrdigpO1xyXG5cdFx0aWYoa3YuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKT4wKXtcclxuXHRcdFx0Y3R4LnN1YnNjcmliZXJzLnB1c2goa3YpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0a3YuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvYmxvY2tzL2Jsb2NrSWYuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBS0E7QUFDQTtBQU5BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/*!**************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockHtml.js ***!
  \**************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockHtml;\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 2);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 3);\n\nfunction blockHtml(parent, tpl, ctx, level) {\n\n\tif (tpl.attrs && tpl.attrs['value'] && tpl.attrs['value'].call) {\n\n\t\tvar value = tpl.attrs['value'];\n\t\tvar stamp = (0, _renderCtx.createStamp)(parent, 'html');\n\t\tif (level == 0) ctx.rootNodes.push(stamp[1]);\n\n\t\tvar children = [];\n\t\tvar dispose = function dispose() {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tstamp[0].removeChild(children[i]);\n\t\t\t}\n\t\t\tchildren = [];\n\t\t};\n\t\tctx.subscribers.push({ dispose: dispose });\n\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = value(ctx.model, ctx);\n\t\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\n\t\t\t//remove old\n\t\t\tdispose();\n\t\t\tif (typeof val2 != 'undefined' && val2 != null) {\n\t\t\t\t//add new\n\t\t\t\tvar div = document.createElement('div');\n\t\t\t\tdiv.innerHTML = \"\" + val2;\n\t\t\t\tchildren = Array.prototype.slice.call(div.childNodes);\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tstamp[0].insertBefore(children[i], stamp[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tIdG1sLmpzP2Y1MWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW53cmFwLCBkZXBlbmRlbmN5RGV0ZWN0aW9uIH0gIGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVkIH0gIGZyb20gJy4uL3Rrby90a28uY29tcHV0ZWQuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVTdGFtcCB9ICBmcm9tICcuLi9yZW5kZXJDdHguanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvY2tIdG1sKHBhcmVudCwgdHBsLCBjdHgsIGxldmVsKXtcclxuXHJcblx0aWYodHBsLmF0dHJzICYmIHRwbC5hdHRyc1sndmFsdWUnXSAmJiB0cGwuYXR0cnNbJ3ZhbHVlJ10uY2FsbCl7XHJcblx0XHRcclxuXHRcdHZhciB2YWx1ZSA9IHRwbC5hdHRyc1sndmFsdWUnXTtcclxuXHRcdHZhciBzdGFtcCA9XHRjcmVhdGVTdGFtcChwYXJlbnQsICdodG1sJyk7XHJcblx0XHRpZihsZXZlbD09MCkgY3R4LnJvb3ROb2Rlcy5wdXNoKHN0YW1wWzFdKTtcclxuXHJcblx0XHR2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHRcdHZhciBkaXNwb3NlID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykgeyBcclxuXHRcdFx0XHRzdGFtcFswXS5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2hpbGRyZW4gPSBbXTtcclxuXHRcdH07XHJcblx0XHRjdHguc3Vic2NyaWJlcnMucHVzaCh7IGRpc3Bvc2U6IGRpc3Bvc2UgfSk7XHJcblxyXG5cdFx0dmFyIGt2ID0gY29tcHV0ZWQoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR2YXIgdmFsMiA9IHZhbHVlKGN0eC5tb2RlbCwgY3R4KTtcclxuXHRcdFx0XHR2YWwyID0gdW53cmFwKHZhbDIpO1xyXG5cclxuXHRcdFx0XHQvL3JlbW92ZSBvbGRcclxuXHRcdFx0XHRkaXNwb3NlKCk7XHJcbiAgXHRcdFx0XHRpZih0eXBlb2YodmFsMikgIT0gJ3VuZGVmaW5lZCcgJiYgdmFsMiAhPSBudWxsKXtcclxuXHRcdFx0XHRcdC8vYWRkIG5ld1xyXG5cdFx0XHRcdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiXCIrdmFsMjtcclxuXHRcdFx0XHRcdGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGl2LmNoaWxkTm9kZXMpO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykgeyBcclxuXHRcdFx0XHRcdCAgICBzdGFtcFswXS5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baV0sIHN0YW1wWzFdKTtcclxuXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdH1cclxuXHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdGt2KCk7XHJcblx0XHRpZihrdi5nZXREZXBlbmRlbmNpZXNDb3VudCgpPjApe1xyXG5cdFx0XHRjdHguc3Vic2NyaWJlcnMucHVzaChrdik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRrdi5kaXNwb3NlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tIdG1sLmpzIl0sIm1hcHBpbmdzIjoiOzs7OztBQUlBO0FBQ0E7QUFMQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/*!******************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/blocks/blockTemplate.js ***!
  \******************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = blockTemplate;\n\nvar _tkoUtils = __webpack_require__(/*! ../tko/tko.utils.js */ 1);\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nvar _tkoComputed = __webpack_require__(/*! ../tko/tko.computed.js */ 2);\n\nvar _renderCtx = __webpack_require__(/*! ../renderCtx.js */ 3);\n\nfunction blockTemplate(parent, tpl, ctx, level) {\n\n\tif (tpl.attrs && tpl.attrs['value'] && tpl.attrs['value'].call) {\n\n\t\tvar value = tpl.attrs['value'];\n\t\tvar stamp = (0, _renderCtx.createStamp)(parent, 'template');\n\t\tif (level == 0) ctx.rootNodes.push(stamp[1]);\n\n\t\tvar ctx0 = (0, _renderCtx.duplicateCtx)(ctx);\n\t\tctx.subscribers.push(ctx0);\n\n\t\tvar kv = (0, _tkoComputed.computed)(function () {\n\t\t\tvar val2 = value(ctx.model, ctx);\n\t\t\tval2 = (0, _tkoObservable.unwrap)(val2);\n\t\t\tconsole.log('template', val2);\n\n\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\tctx0.dispose();\n\t\t\t});\n\n\t\t\tif (val2) {\n\t\t\t\t//render value tpl\n\t\t\t\t_tkoObservable.dependencyDetection.ignore(function () {\n\t\t\t\t\t(0, _renderCtx.renderCtx)(stamp, val2, ctx0, 0);\n\t\t\t\t});\n\t\t\t}\n\t\t}, this);\n\t\tkv();\n\t\tif (kv.getDependenciesCount() > 0) {\n\t\t\tctx.subscribers.push(kv);\n\t\t} else {\n\t\t\tkv.dispose();\n\t\t}\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9ibG9ja3MvYmxvY2tUZW1wbGF0ZS5qcz85NTVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFycmF5Rm9yRWFjaCB9ICBmcm9tICcuLi90a28vdGtvLnV0aWxzLmpzJztcclxuaW1wb3J0IHsgdW53cmFwLCBkZXBlbmRlbmN5RGV0ZWN0aW9uIH0gIGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVkIH0gIGZyb20gJy4uL3Rrby90a28uY29tcHV0ZWQuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJDdHgsIGNyZWF0ZVN0YW1wLCBkdXBsaWNhdGVDdHggfSAgZnJvbSAnLi4vcmVuZGVyQ3R4LmpzJztcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBibG9ja1RlbXBsYXRlKHBhcmVudCwgdHBsLCBjdHgsIGxldmVsKXtcclxuXHJcblx0aWYodHBsLmF0dHJzICYmIHRwbC5hdHRyc1sndmFsdWUnXSAmJiB0cGwuYXR0cnNbJ3ZhbHVlJ10uY2FsbCl7XHJcblx0XHRcclxuXHRcdHZhciB2YWx1ZSA9IHRwbC5hdHRyc1sndmFsdWUnXTtcclxuXHRcdHZhciBzdGFtcCA9XHRjcmVhdGVTdGFtcChwYXJlbnQsICd0ZW1wbGF0ZScpO1xyXG5cdFx0aWYobGV2ZWw9PTApIGN0eC5yb290Tm9kZXMucHVzaChzdGFtcFsxXSk7XHJcblxyXG5cdFx0dmFyIGN0eDAgPSBkdXBsaWNhdGVDdHgoY3R4KTtcclxuXHRcdGN0eC5zdWJzY3JpYmVycy5wdXNoKGN0eDApO1xyXG5cclxuXHRcdHZhciBrdiA9IGNvbXB1dGVkKGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciB2YWwyID0gdmFsdWUoY3R4Lm1vZGVsLCBjdHgpO1xyXG5cdFx0XHR2YWwyID0gdW53cmFwKHZhbDIpO1xyXG5cdFx0XHRjb25zb2xlLmxvZygndGVtcGxhdGUnLFx0dmFsMik7XHJcblxyXG5cdFx0XHRkZXBlbmRlbmN5RGV0ZWN0aW9uLmlnbm9yZShmdW5jdGlvbigpe1xyXG5cdFx0XHRcdGN0eDAuZGlzcG9zZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmKHZhbDIpe1xyXG5cdFx0XHRcdC8vcmVuZGVyIHZhbHVlIHRwbFxyXG5cdFx0XHRcdGRlcGVuZGVuY3lEZXRlY3Rpb24uaWdub3JlKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRyZW5kZXJDdHgoc3RhbXAsIHZhbDIsIGN0eDAsIDApO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRrdigpO1xyXG5cdFx0aWYoa3YuZ2V0RGVwZW5kZW5jaWVzQ291bnQoKT4wKXtcclxuXHRcdFx0Y3R4LnN1YnNjcmliZXJzLnB1c2goa3YpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0a3YuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGM6L1VzZXJzL3BtL0Rvd25sb2Fkcy9yZWFjdC9qcy1mcmFtZXdvcmstYmVuY2htYXJrL2tvNi9zcmMvYmxvY2tzL2Jsb2NrVGVtcGxhdGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBTUE7QUFDQTtBQVBBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!************************************************************************************!*\
  !*** c:/Users/pm/Downloads/react/js-framework-benchmark/ko6/src/bindings/click.js ***!
  \************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _tkoObservable = __webpack_require__(/*! ../tko/tko.observable.js */ 0);\n\nexports.default = {\n\tinit: function init(el, val) {\n\t\tval = (0, _tkoObservable.unwrap)(val);\n\t\tif (val.call) el.addEventListener(\"click\", val);\n\t}\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYzovVXNlcnMvcG0vRG93bmxvYWRzL3JlYWN0L2pzLWZyYW1ld29yay1iZW5jaG1hcmsva282L3NyYy9iaW5kaW5ncy9jbGljay5qcz82OGE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVud3JhcCB9IGZyb20gJy4uL3Rrby90a28ub2JzZXJ2YWJsZS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdDogZnVuY3Rpb24oZWwsIHZhbCl7XHJcblx0XHR2YWwgPSB1bndyYXAodmFsKTtcclxuXHRcdGlmKHZhbC5jYWxsKSBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdmFsKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjOi9Vc2Vycy9wbS9Eb3dubG9hZHMvcmVhY3QvanMtZnJhbWV3b3JrLWJlbmNobWFyay9rbzYvc3JjL2JpbmRpbmdzL2NsaWNrLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n");

/***/ })
/******/ ]);